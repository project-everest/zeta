@name_title@::@name_title@
(
     @@params|const @host_tname@* @vname@|,n    @@
)
: AppTransFn { @id@, @arity@, @has_output_str@ }@@params|, @vname@_{*@vname@}|n    @@
, paramSerializer_ { this }
{

}

const Record& @name_title@::GetRecord(int idx) const
{
    assert (idx < @arity@);

    @@record_params|if (idx == @record_idx@) return @vname@_;|n    @@

    throw std::invalid_argument("invalid argument");
}

const Value& @name_title@::GetPostValue(int idx) const
{
    assert (idx < @arity@);

    // TODO: Implement: needed for correct merkle updates

    throw std::runtime_error("not implemented");
}

bool @name_title@::Touches(int idx) const
{
    assert (idx < @arity@);

    // TODO: Implement correct Touches for better performance
    // by minimizing merkle tree updates

    return true;
}

void @name_title@::SetOutput(ReadLog& log)
{
#ifdef @has_output_indicator@
    LowParse_Slice_slice inp { const_cast<uint8_t*>(log.Current()), log.LeftToRead() };
    uint32_t len = @c_output_type@_jumper(inp, 0);
    out_ = @c_output_type@_reader(inp, 0);
    log.DeserializeBuf(len);
#endif
}
