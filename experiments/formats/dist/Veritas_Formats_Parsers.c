/* 
  This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
  KreMLin invocation: /home/tahina/everest/master/kremlin/krml -tmpdir ../dist/ -skip-compilation obj/FStar_Pervasives_Native.krml obj/FStar_Pervasives.krml obj/FStar_Mul.krml obj/FStar_Squash.krml obj/FStar_Classical.krml obj/FStar_Preorder.krml obj/FStar_Calc.krml obj/FStar_StrongExcludedMiddle.krml obj/FStar_List_Tot_Base.krml obj/FStar_List_Tot_Properties.krml obj/FStar_List_Tot.krml obj/FStar_Seq_Base.krml obj/FStar_FunctionalExtensionality.krml obj/FStar_Seq_Properties.krml obj/FStar_Seq.krml obj/FStar_Math_Lib.krml obj/FStar_Math_Lemmas.krml obj/FStar_BitVector.krml obj/FStar_UInt.krml obj/FStar_UInt32.krml obj/FStar_Int.krml obj/FStar_Int16.krml obj/FStar_Set.krml obj/FStar_Ghost.krml obj/FStar_ErasedLogic.krml obj/FStar_PropositionalExtensionality.krml obj/FStar_PredicateExtensionality.krml obj/FStar_TSet.krml obj/FStar_Monotonic_Heap.krml obj/FStar_Heap.krml obj/FStar_Map.krml obj/FStar_Monotonic_Witnessed.krml obj/FStar_Monotonic_HyperHeap.krml obj/FStar_Monotonic_HyperStack.krml obj/FStar_HyperStack.krml obj/FStar_HyperStack_ST.krml obj/FStar_Universe.krml obj/FStar_GSet.krml obj/FStar_ModifiesGen.krml obj/FStar_Range.krml obj/FStar_Tactics_Common.krml obj/FStar_VConfig.krml obj/FStar_Reflection_Types.krml obj/FStar_Tactics_Types.krml obj/FStar_Tactics_Result.krml obj/FStar_Tactics_Effect.krml obj/FStar_Reflection_Data.krml obj/FStar_Tactics_Builtins.krml obj/FStar_Reflection_Const.krml obj/FStar_Order.krml obj/FStar_Reflection_Builtins.krml obj/FStar_Reflection_Derived.krml obj/FStar_Reflection_Derived_Lemmas.krml obj/FStar_Reflection.krml obj/FStar_Tactics_Print.krml obj/FStar_Tactics_SyntaxHelpers.krml obj/FStar_Tactics_Util.krml obj/FStar_Reflection_Formula.krml obj/FStar_Tactics_Derived.krml obj/FStar_Tactics_Logic.krml obj/FStar_Tactics.krml obj/FStar_BigOps.krml obj/LowStar_Monotonic_Buffer.krml obj/LowStar_Buffer.krml obj/LowStar_Modifies.krml obj/FStar_Char.krml obj/FStar_Exn.krml obj/FStar_ST.krml obj/FStar_All.krml obj/FStar_List.krml obj/FStar_String.krml obj/FStar_UInt64.krml obj/FStar_UInt16.krml obj/FStar_UInt8.krml obj/FStar_Bytes.krml obj/Spec_Loops.krml obj/LowStar_BufferOps.krml obj/C_Loops.krml obj/FStar_Int64.krml obj/FStar_Int32.krml obj/FStar_Int8.krml obj/FStar_Int_Cast.krml obj/LowParse_Bytes.krml obj/LowParse_Spec_Base.krml obj/LowParse_Spec_Combinators.krml obj/LowParse_Spec_FLData.krml obj/LowStar_Comment.krml obj/LowParse_Math.krml obj/LowParse_BitFields.krml obj/LowParse_Low_ErrorCode.krml obj/LowParse_Slice.krml obj/LowParse_Low_Base_Spec.krml obj/LowParse_Low_Base.krml obj/LowStar_Failure.krml obj/LowParse_Low_Combinators.krml obj/LowParse_Low_FLData.krml obj/FStar_Endianness.krml obj/LowParse_Spec_Seq.krml obj/LowParse_Spec_Int.krml obj/LowParse_Spec_BoundedInt.krml obj/FStar_UInt128.krml obj/LowStar_Endianness.krml obj/LowParse_Low_Endianness.krml obj/LowParse_Endianness.krml obj/LowParse_Endianness_BitFields.krml obj/LowParse_Low_BoundedInt.krml obj/LowParse_Spec_SeqBytes_Base.krml obj/LowParse_Spec_DER.krml obj/LowParse_Spec_BCVLI.krml obj/LowParse_Spec_AllIntegers.krml obj/LowParse_Spec_VLData.krml obj/LowParse_Low_VLData.krml obj/LowParse_Spec_VLGen.krml obj/LowParse_Low_VLGen.krml obj/LowParse_Low_Int.krml obj/LowParse_Low_DER.krml obj/LowParse_Low_BCVLI.krml obj/LowParse_Spec_List.krml obj/LowParse_Low_List.krml obj/LowParse_Spec_Array.krml obj/LowParse_Spec_VCList.krml obj/LowParse_Low_VCList.krml obj/LowParse_Spec_IfThenElse.krml obj/LowParse_Low_IfThenElse.krml obj/LowParse_TacLib.krml obj/LowParse_Spec_Enum.krml obj/LowParse_Spec_Sum.krml obj/LowParse_Low_Enum.krml obj/LowParse_Low_Sum.krml obj/LowParse_Low_Tac_Sum.krml obj/LowParse_Spec_Option.krml obj/LowParse_Low_Option.krml obj/LowParse_Bytes32.krml obj/LowParse_Spec_Bytes.krml obj/LowParse_Low_Bytes.krml obj/LowParse_Low_Array.krml obj/LowParse_Low.krml obj/LowParse_Writers_Parser.krml obj/FStar_Monotonic_Pure.krml obj/LowParse_Writers_Effect.krml obj/LowParse_Writers_Combinators.krml obj/LowParse_Writers_Instances.krml obj/LowParse_SLow_Base.krml obj/LowParse_SLow_Combinators.krml obj/LowParse_SLow_FLData.krml obj/LowParse_SLow_VLGen.krml obj/LowParse_Spec_Endianness.krml obj/LowParse_Spec_Endianness_Instances.krml obj/LowParse_SLow_Endianness.krml obj/LowParse_SLow_BoundedInt.krml obj/LowParse_SLow_Int.krml obj/LowParse_SLow_DER.krml obj/LowParse_SLow_BCVLI.krml obj/LowParse_SLow_List.krml obj/LowParse_SLow_VCList.krml obj/LowParse_SLow_IfThenElse.krml obj/LowParse_SLow_Option.krml obj/LowParse_Spec_Tac_Enum.krml obj/LowParse_Spec_Tac_Sum.krml obj/LowParse_SLow_Enum.krml obj/LowParse_SLow_Sum.krml obj/LowParse_SLow_Tac_Enum.krml obj/LowParse_SLow_VLData.krml obj/LowParse_SLow_Bytes.krml obj/LowParse_SLow_Array.krml obj/LowParse_Spec_Tac_Combinators.krml obj/LowParse_SLow.krml obj/LowParse_Spec_SeqBytes.krml obj/LowParse_Spec.krml obj/Veritas_Formats_Types.krml obj/Veritas_Formats_EverParse_U256.krml obj/Veritas_Formats_EverParse_Hash_value.krml obj/Veritas_Formats_EverParse_Slot_id.krml obj/Veritas_Formats_EverParse_Timestamp.krml obj/Veritas_Formats_EverParse_Vlog_entry_evictb.krml obj/Veritas_Formats_EverParse_Data_t.krml obj/Veritas_Formats_EverParse_Voption.krml obj/Veritas_Formats_EverParse_Vbool.krml obj/Veritas_Formats_EverParse_Key.krml obj/Veritas_Formats_EverParse_Descendent_hash_desc.krml obj/Veritas_Formats_EverParse_Descendent_hash.krml obj/Veritas_Formats_EverParse_Vlog_entry_kind.krml obj/Veritas_Formats_EverParse_Value_kind.krml obj/Veritas_Formats_EverParse_Add_method.krml obj/Veritas_Formats_EverParse_Thread_id.krml obj/Veritas_Formats_EverParse_Data_value.krml obj/Veritas_Formats_EverParse_Mval_value.krml obj/Veritas_Formats_EverParse_Value.krml obj/Veritas_Formats_EverParse_Record.krml obj/Veritas_Formats_EverParse_Vlog_entry_addb.krml obj/Veritas_Formats_EverParse_Vlog_entry_evictbm.krml obj/Veritas_Formats_EverParse_Vlog_entry_evictm.krml obj/Veritas_Formats_EverParse_Vlog_entry_addm.krml obj/Veritas_Formats_EverParse_Vlog_entry_get_put.krml obj/Veritas_Formats_EverParse_Vlog_entry.krml obj/Veritas_Formats_Parsers.krml obj/Veritas_Formats.krml -warn-error @4@5@18 -fparentheses -bundle Veritas.Formats.Parsers=Veritas.Formats,Veritas.Formats.*,LowParse.*,LowStar.*,FStar.*,Prims -o veritasformats.a
  F* version: fda38118
  KreMLin version: f3656741
 */

#include "Veritas_Formats_Parsers.h"

#define VALIDATOR_MAX_LENGTH ((uint64_t)4294967295U)

static inline bool is_error(uint64_t positionOrError)
{
  return positionOrError > VALIDATOR_MAX_LENGTH;
}

#define VALIDATOR_ERROR_GENERIC ((uint64_t)4294967296U)

#define VALIDATOR_ERROR_NOT_ENOUGH_DATA ((uint64_t)8589934592U)

typedef struct slice_s
{
  uint8_t *base;
  uint32_t len;
}
slice;

#define Vnone 0
#define Vsome 1

typedef uint8_t voption;

#define Mval 0
#define Dval 1

typedef uint8_t value_kind;

static uint32_t u256_size32(Veritas_Formats_Types_u256 input)
{
  uint32_t v1 = (uint32_t)8U;
  uint32_t v20 = (uint32_t)8U;
  uint32_t res0;
  if ((uint32_t)4294967295U - v20 < v1)
    res0 = (uint32_t)4294967295U;
  else
    res0 = v1 + v20;
  uint32_t v10 = res0;
  uint32_t v11 = (uint32_t)8U;
  uint32_t v2 = (uint32_t)8U;
  uint32_t res;
  if ((uint32_t)4294967295U - v2 < v11)
    res = (uint32_t)4294967295U;
  else
    res = v11 + v2;
  uint32_t v21 = res;
  if ((uint32_t)4294967295U - v21 < v10)
    return (uint32_t)4294967295U;
  else
    return v10 + v21;
}

static uint32_t u256_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

typedef struct __uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
}
__uint64_t_uint64_t;

typedef struct u256__s
{
  __uint64_t_uint64_t fst;
  __uint64_t_uint64_t snd;
}
u256_;

static Veritas_Formats_Types_u256 u256_reader(slice input, uint32_t pos)
{
  uint8_t *x00 = input.base;
  uint64_t x1 = load64_be(x00 + pos);
  uint32_t pos20 = pos + (uint32_t)8U;
  uint8_t *x01 = input.base;
  uint64_t x2 = load64_be(x01 + pos20);
  __uint64_t_uint64_t x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = pos + (uint32_t)8U + (uint32_t)8U;
  uint8_t *x02 = input.base;
  uint64_t x11 = load64_be(x02 + pos2);
  uint32_t pos21 = pos2 + (uint32_t)8U;
  uint8_t *x0 = input.base;
  uint64_t x20 = load64_be(x0 + pos21);
  __uint64_t_uint64_t x21 = { .fst = x11, .snd = x20 };
  u256_ res = { .fst = x10, .snd = x21 };
  uint64_t v0 = res.snd.snd;
  uint64_t v1 = res.snd.fst;
  uint64_t v2 = res.fst.snd;
  uint64_t v3 = res.fst.fst;
  return ((Veritas_Formats_Types_u256){ .v3 = v3, .v2 = v2, .v1 = v1, .v0 = v0 });
}

static uint32_t u256_lserializer(Veritas_Formats_Types_u256 x, uint8_t *input, uint32_t pos)
{
  store64_be(input + pos, x.v3);
  uint32_t res0 = (uint32_t)8U;
  uint32_t len1 = res0;
  uint32_t pos10 = pos + len1;
  store64_be(input + pos10, x.v2);
  uint32_t res1 = (uint32_t)8U;
  uint32_t len2 = res1;
  uint32_t res2 = len1 + len2;
  uint32_t len10 = res2;
  uint32_t pos1 = pos + len10;
  store64_be(input + pos1, x.v1);
  uint32_t res = (uint32_t)8U;
  uint32_t len11 = res;
  uint32_t pos11 = pos1 + len11;
  store64_be(input + pos11, x.v0);
  uint32_t res3 = (uint32_t)8U;
  uint32_t len20 = res3;
  uint32_t res4 = len11 + len20;
  uint32_t len21 = res4;
  return len10 + len21;
}

static uint32_t (*hash_value_size32)(Veritas_Formats_Types_u256 x0) = u256_size32;

static uint64_t hash_value_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t hash_value_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

static Veritas_Formats_Types_u256 (*hash_value_reader)(slice x0, uint32_t x1) = u256_reader;

static uint32_t
(*hash_value_lserializer)(Veritas_Formats_Types_u256 x0, uint8_t *x1, uint32_t x2) =
  u256_lserializer;

static uint64_t slot_id_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)2U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)2U;
}

static uint32_t slot_id_jumper(uint32_t pos)
{
  return pos + (uint32_t)2U;
}

static uint16_t slot_id_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load16_be(x0 + pos);
}

static uint64_t timestamp_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)8U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)8U;
}

static uint32_t timestamp_jumper(uint32_t pos)
{
  return pos + (uint32_t)8U;
}

static uint64_t timestamp_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load64_be(x0 + pos);
}

static uint64_t vlog_entry_evictb_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)10U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)10U;
}

typedef struct vlog_entry_evictb__s
{
  uint16_t fst;
  uint64_t snd;
}
vlog_entry_evictb_;

static Veritas_Formats_Types_vlog_entry_evictb
vlog_entry_evictb_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  uint64_t x2 = timestamp_reader(input, pos2);
  vlog_entry_evictb_ res = { .fst = x1, .snd = x2 };
  uint16_t veeb_s = res.fst;
  uint64_t veeb_t = res.snd;
  return ((Veritas_Formats_Types_vlog_entry_evictb){ .veeb_s = veeb_s, .veeb_t = veeb_t });
}

static uint32_t (*data_t_size32)(Veritas_Formats_Types_u256 x0) = u256_size32;

static uint64_t data_t_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t data_t_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

static Veritas_Formats_Types_u256 (*data_t_reader)(slice x0, uint32_t x1) = u256_reader;

static uint32_t
(*data_t_lserializer)(Veritas_Formats_Types_u256 x0, uint8_t *x1, uint32_t x2) =
  u256_lserializer;

static uint32_t vbool_size32(Veritas_Formats_Types_vbool x)
{
  return (uint32_t)1U;
}

static uint64_t vbool_validator(slice input, uint64_t pos)
{
  uint64_t res;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    res = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    res = pos + (uint64_t)1U;
  if (is_error(res))
    return res;
  else
  {
    uint8_t va = input.base[(uint32_t)pos];
    bool ite;
    if (va == (uint8_t)0U)
      ite = true;
    else if (va == (uint8_t)1U)
      ite = true;
    else
      ite = false;
    if (!ite)
      return VALIDATOR_ERROR_GENERIC;
    else
      return res;
  }
}

static uint32_t vbool_jumper(uint32_t pos)
{
  return pos + (uint32_t)1U;
}

static Veritas_Formats_Types_vbool vbool_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  if (res == (uint8_t)0U)
    return Veritas_Formats_Types_Vfalse;
  else if (res == (uint8_t)1U)
    return Veritas_Formats_Types_Vtrue;
  else
    return Veritas_Formats_Types_Vfalse;
}

static bool
__eq__Veritas_Formats_Types_vbool(Veritas_Formats_Types_vbool y, Veritas_Formats_Types_vbool x)
{
  switch (x)
  {
    case Veritas_Formats_Types_Vfalse:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Vfalse:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_Vtrue:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Vtrue:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static uint32_t vbool_writer(Veritas_Formats_Types_vbool x, slice input, uint32_t pos)
{
  uint8_t ite;
  if (__eq__Veritas_Formats_Types_vbool(Veritas_Formats_Types_Vfalse, x))
    ite = (uint8_t)0U;
  else
    ite = (uint8_t)1U;
  input.base[pos] = ite;
  uint32_t len = (uint32_t)1U;
  uint32_t res = pos + len;
  uint32_t pos_ = res;
  uint32_t pos_0 = pos_;
  return pos_0;
}

static uint32_t vbool_lserializer(Veritas_Formats_Types_vbool x, uint8_t *b, uint32_t pos)
{
  uint32_t pos_ = vbool_writer(x, ((slice){ .base = b, .len = pos + (uint32_t)1U }), pos);
  return pos_ - pos;
}

static uint32_t key_size32(Veritas_Formats_Types_key input)
{
  uint32_t v1 = u256_size32(input.k);
  uint32_t v2 = (uint32_t)1U;
  if ((uint32_t)4294967295U - v2 < v1)
    return (uint32_t)4294967295U;
  else
    return v1 + v2;
}

static uint64_t key_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)33U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)33U;
}

static uint32_t key_jumper(uint32_t pos)
{
  return pos + (uint32_t)33U;
}

typedef struct key__s
{
  Veritas_Formats_Types_u256 fst;
  uint8_t snd;
}
key_;

static Veritas_Formats_Types_key key_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_u256 x1 = u256_reader(input, pos);
  uint32_t pos2 = u256_jumper(pos);
  uint8_t x2 = input.base[pos2];
  key_ res = { .fst = x1, .snd = x2 };
  Veritas_Formats_Types_u256 k = res.fst;
  uint8_t significant_digits = res.snd;
  return ((Veritas_Formats_Types_key){ .k = k, .significant_digits = significant_digits });
}

static uint32_t key_lserializer(Veritas_Formats_Types_key x, uint8_t *input, uint32_t pos)
{
  uint32_t res = u256_lserializer(x.k, input, pos);
  uint32_t len1 = res;
  uint32_t pos1 = pos + len1;
  input[pos1] = x.significant_digits;
  uint32_t res0 = (uint32_t)1U;
  uint32_t len2 = res0;
  return len1 + len2;
}

static uint32_t descendent_hash_desc_size32(Veritas_Formats_Types_descendent_hash_desc input)
{
  uint32_t v1 = key_size32(input.dhd_key);
  uint32_t v20 = hash_value_size32(input.dhd_h);
  uint32_t res;
  if ((uint32_t)4294967295U - v20 < v1)
    res = (uint32_t)4294967295U;
  else
    res = v1 + v20;
  uint32_t v10 = res;
  uint32_t v2 = vbool_size32(input.evicted_to_blum);
  if ((uint32_t)4294967295U - v2 < v10)
    return (uint32_t)4294967295U;
  else
    return v10 + v2;
}

static uint64_t descendent_hash_desc_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = key_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = hash_value_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
    return vbool_validator(input, pos1);
}

static uint32_t descendent_hash_desc_jumper(uint32_t pos)
{
  return pos + (uint32_t)66U;
}

typedef struct __Veritas_Formats_Types_key_Veritas_Formats_Types_u256_s
{
  Veritas_Formats_Types_key fst;
  Veritas_Formats_Types_u256 snd;
}
__Veritas_Formats_Types_key_Veritas_Formats_Types_u256;

typedef struct descendent_hash_desc__s
{
  __Veritas_Formats_Types_key_Veritas_Formats_Types_u256 fst;
  Veritas_Formats_Types_vbool snd;
}
descendent_hash_desc_;

static Veritas_Formats_Types_descendent_hash_desc
descendent_hash_desc_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_key x1 = key_reader(input, pos);
  uint32_t pos20 = key_jumper(pos);
  Veritas_Formats_Types_u256 x2 = hash_value_reader(input, pos20);
  __Veritas_Formats_Types_key_Veritas_Formats_Types_u256 x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = hash_value_jumper(key_jumper(pos));
  Veritas_Formats_Types_vbool x20 = vbool_reader(input, pos2);
  descendent_hash_desc_ res = { .fst = x10, .snd = x20 };
  Veritas_Formats_Types_vbool evicted_to_blum = res.snd;
  Veritas_Formats_Types_u256 dhd_h = res.fst.snd;
  Veritas_Formats_Types_key dhd_key = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_descendent_hash_desc){
        .dhd_key = dhd_key,
        .dhd_h = dhd_h,
        .evicted_to_blum = evicted_to_blum
      }
    );
}

static uint32_t
descendent_hash_desc_lserializer(
  Veritas_Formats_Types_descendent_hash_desc x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t res = key_lserializer(x.dhd_key, input, pos);
  uint32_t len1 = res;
  uint32_t pos10 = pos + len1;
  uint32_t res0 = hash_value_lserializer(x.dhd_h, input, pos10);
  uint32_t len2 = res0;
  uint32_t res1 = len1 + len2;
  uint32_t len10 = res1;
  uint32_t pos1 = pos + len10;
  uint32_t res2 = vbool_lserializer(x.evicted_to_blum, input, pos1);
  uint32_t len20 = res2;
  return len10 + len20;
}

static bool __eq__Veritas_Formats_Types_voption(voption y, voption x)
{
  switch (x)
  {
    case Vnone:
      {
        switch (y)
        {
          case Vnone:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Vsome:
      {
        switch (y)
        {
          case Vsome:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static uint32_t descendent_hash_size32(Veritas_Formats_Types_descendent_hash x)
{
  voption tg;
  if (x.tag == Veritas_Formats_Types_Dh_vnone)
    tg = Vnone;
  else if (x.tag == Veritas_Formats_Types_Dh_vsome)
    tg = Vsome;
  else
    tg = KRML_EABORT(voption, "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (__eq__Veritas_Formats_Types_voption(Vnone, tg))
    s2 = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_descendent_hash_desc ite;
    if (x.tag == Veritas_Formats_Types_Dh_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_descendent_hash_desc,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = descendent_hash_desc_size32(ite);
  }
  return s1 + s2;
}

static uint64_t descendent_hash_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      if ((uint64_t)input.len - len_after_tag < (uint64_t)0U)
        return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        return len_after_tag + (uint64_t)0U;
    else if (k_ == (uint8_t)1U)
      return descendent_hash_desc_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t descendent_hash_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return pos_after_tag + (uint32_t)0U;
  else if (k_ == (uint8_t)1U)
    return descendent_hash_desc_jumper(pos_after_tag);
  else
    return (uint32_t)0U;
}

static Veritas_Formats_Types_descendent_hash descendent_hash_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  voption k;
  if (res == (uint8_t)0U)
    k = Vnone;
  else if (res == (uint8_t)1U)
    k = Vsome;
  else
    k = Vnone;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_voption(Vnone, k))
    return ((Veritas_Formats_Types_descendent_hash){ .tag = Veritas_Formats_Types_Dh_vnone });
  else
  {
    Veritas_Formats_Types_descendent_hash_desc res = descendent_hash_desc_reader(input, pos_);
    return
      ((Veritas_Formats_Types_descendent_hash){ .tag = Veritas_Formats_Types_Dh_vsome, ._0 = res });
  }
}

static uint32_t
descendent_hash_lserializer(Veritas_Formats_Types_descendent_hash x, uint8_t *b, uint32_t pos)
{
  voption tg;
  if (x.tag == Veritas_Formats_Types_Dh_vnone)
    tg = Vnone;
  else if (x.tag == Veritas_Formats_Types_Dh_vsome)
    tg = Vsome;
  else
    tg = KRML_EABORT(voption, "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (__eq__Veritas_Formats_Types_voption(Vnone, tg))
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (__eq__Veritas_Formats_Types_voption(Vnone, tg))
    res = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_descendent_hash_desc ite;
    if (x.tag == Veritas_Formats_Types_Dh_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_descendent_hash_desc,
          "unreachable (pattern matches are exhaustive in F*)");
    res = descendent_hash_desc_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint64_t add_method_validator(slice input, uint64_t pos)
{
  uint64_t res;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    res = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    res = pos + (uint64_t)1U;
  if (is_error(res))
    return res;
  else
  {
    uint8_t va = input.base[(uint32_t)pos];
    bool ite;
    if (va == (uint8_t)0U)
      ite = true;
    else if (va == (uint8_t)1U)
      ite = true;
    else
      ite = false;
    if (!ite)
      return VALIDATOR_ERROR_GENERIC;
    else
      return res;
  }
}

static uint32_t add_method_jumper(uint32_t pos)
{
  return pos + (uint32_t)1U;
}

static Veritas_Formats_Types_add_method add_method_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  if (res == (uint8_t)0U)
    return Veritas_Formats_Types_MAdd;
  else if (res == (uint8_t)1U)
    return Veritas_Formats_Types_BAdd;
  else
    return Veritas_Formats_Types_MAdd;
}

static uint64_t thread_id_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)2U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)2U;
}

static uint16_t thread_id_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load16_be(x0 + pos);
}

static uint32_t data_value_size32(Veritas_Formats_Types_data_value x)
{
  voption tg;
  if (x.tag == Veritas_Formats_Types_Dv_vnone)
    tg = Vnone;
  else if (x.tag == Veritas_Formats_Types_Dv_vsome)
    tg = Vsome;
  else
    tg = KRML_EABORT(voption, "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (__eq__Veritas_Formats_Types_voption(Vnone, tg))
    s2 = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_u256 ite;
    if (x.tag == Veritas_Formats_Types_Dv_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_u256,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = data_t_size32(ite);
  }
  return s1 + s2;
}

static uint64_t data_value_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      if ((uint64_t)input.len - len_after_tag < (uint64_t)0U)
        return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        return len_after_tag + (uint64_t)0U;
    else if (k_ == (uint8_t)1U)
      return data_t_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t data_value_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return pos_after_tag + (uint32_t)0U;
  else if (k_ == (uint8_t)1U)
    return data_t_jumper(pos_after_tag);
  else
    return (uint32_t)0U;
}

static Veritas_Formats_Types_data_value data_value_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  voption k;
  if (res == (uint8_t)0U)
    k = Vnone;
  else if (res == (uint8_t)1U)
    k = Vsome;
  else
    k = Vnone;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_voption(Vnone, k))
    return ((Veritas_Formats_Types_data_value){ .tag = Veritas_Formats_Types_Dv_vnone });
  else
  {
    Veritas_Formats_Types_u256 res = data_t_reader(input, pos_);
    return
      ((Veritas_Formats_Types_data_value){ .tag = Veritas_Formats_Types_Dv_vsome, ._0 = res });
  }
}

static uint32_t
data_value_lserializer(Veritas_Formats_Types_data_value x, uint8_t *b, uint32_t pos)
{
  voption tg;
  if (x.tag == Veritas_Formats_Types_Dv_vnone)
    tg = Vnone;
  else if (x.tag == Veritas_Formats_Types_Dv_vsome)
    tg = Vsome;
  else
    tg = KRML_EABORT(voption, "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (__eq__Veritas_Formats_Types_voption(Vnone, tg))
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (__eq__Veritas_Formats_Types_voption(Vnone, tg))
    res = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_u256 ite;
    if (x.tag == Veritas_Formats_Types_Dv_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_u256,
          "unreachable (pattern matches are exhaustive in F*)");
    res = data_t_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint32_t mval_value_size32(Veritas_Formats_Types_mval_value input)
{
  uint32_t v1 = descendent_hash_size32(input.l);
  uint32_t v2 = descendent_hash_size32(input.r);
  if ((uint32_t)4294967295U - v2 < v1)
    return (uint32_t)4294967295U;
  else
    return v1 + v2;
}

static uint64_t mval_value_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = descendent_hash_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return descendent_hash_validator(input, pos1);
}

static uint32_t mval_value_jumper(slice input, uint32_t pos)
{
  return descendent_hash_jumper(input, descendent_hash_jumper(input, pos));
}

typedef struct mval_value__s
{
  Veritas_Formats_Types_descendent_hash fst;
  Veritas_Formats_Types_descendent_hash snd;
}
mval_value_;

static Veritas_Formats_Types_mval_value mval_value_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_descendent_hash x1 = descendent_hash_reader(input, pos);
  uint32_t pos2 = descendent_hash_jumper(input, pos);
  Veritas_Formats_Types_descendent_hash x2 = descendent_hash_reader(input, pos2);
  mval_value_ res = { .fst = x1, .snd = x2 };
  Veritas_Formats_Types_descendent_hash l = res.fst;
  Veritas_Formats_Types_descendent_hash r = res.snd;
  return ((Veritas_Formats_Types_mval_value){ .l = l, .r = r });
}

static uint32_t
mval_value_lserializer(Veritas_Formats_Types_mval_value x, uint8_t *input, uint32_t pos)
{
  uint32_t res = descendent_hash_lserializer(x.l, input, pos);
  uint32_t len1 = res;
  uint32_t pos1 = pos + len1;
  uint32_t res0 = descendent_hash_lserializer(x.r, input, pos1);
  uint32_t len2 = res0;
  return len1 + len2;
}

static bool __eq__Veritas_Formats_Types_value_kind(value_kind y, value_kind x)
{
  switch (x)
  {
    case Mval:
      {
        switch (y)
        {
          case Mval:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Dval:
      {
        switch (y)
        {
          case Dval:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static uint32_t value_size32(Veritas_Formats_Types_value x)
{
  value_kind tg;
  if (x.tag == Veritas_Formats_Types_V_mval)
    tg = Mval;
  else if (x.tag == Veritas_Formats_Types_V_dval)
    tg = Dval;
  else
    tg = KRML_EABORT(value_kind, "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (__eq__Veritas_Formats_Types_value_kind(Mval, tg))
  {
    Veritas_Formats_Types_mval_value ite;
    if (x.tag == Veritas_Formats_Types_V_mval)
      ite = x.case_V_mval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_mval_value,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = mval_value_size32(ite);
  }
  else
  {
    Veritas_Formats_Types_data_value ite;
    if (x.tag == Veritas_Formats_Types_V_dval)
      ite = x.case_V_dval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_data_value,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = data_value_size32(ite);
  }
  return s1 + s2;
}

static uint64_t value_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      return mval_value_validator(input, len_after_tag);
    else if (k_ == (uint8_t)1U)
      return data_value_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t value_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return mval_value_jumper(input, pos_after_tag);
  else if (k_ == (uint8_t)1U)
    return data_value_jumper(input, pos_after_tag);
  else
    return (uint32_t)0U;
}

static Veritas_Formats_Types_value value_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  value_kind k;
  if (res == (uint8_t)0U)
    k = Mval;
  else if (res == (uint8_t)1U)
    k = Dval;
  else
    k = Mval;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_value_kind(Mval, k))
  {
    Veritas_Formats_Types_mval_value res = mval_value_reader(input, pos_);
    return
      ((Veritas_Formats_Types_value){ .tag = Veritas_Formats_Types_V_mval, { .case_V_mval = res } });
  }
  else
  {
    Veritas_Formats_Types_data_value res = data_value_reader(input, pos_);
    return
      ((Veritas_Formats_Types_value){ .tag = Veritas_Formats_Types_V_dval, { .case_V_dval = res } });
  }
}

static uint32_t value_lserializer(Veritas_Formats_Types_value x, uint8_t *b, uint32_t pos)
{
  value_kind tg;
  if (x.tag == Veritas_Formats_Types_V_mval)
    tg = Mval;
  else if (x.tag == Veritas_Formats_Types_V_dval)
    tg = Dval;
  else
    tg = KRML_EABORT(value_kind, "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (__eq__Veritas_Formats_Types_value_kind(Mval, tg))
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (__eq__Veritas_Formats_Types_value_kind(Mval, tg))
  {
    Veritas_Formats_Types_mval_value ite;
    if (x.tag == Veritas_Formats_Types_V_mval)
      ite = x.case_V_mval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_mval_value,
          "unreachable (pattern matches are exhaustive in F*)");
    res = mval_value_lserializer(ite, b, pos1);
  }
  else
  {
    Veritas_Formats_Types_data_value ite;
    if (x.tag == Veritas_Formats_Types_V_dval)
      ite = x.case_V_dval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_data_value,
          "unreachable (pattern matches are exhaustive in F*)");
    res = data_value_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint64_t record_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = key_validator(input, pos);
  uint64_t pos12;
  if (is_error(pos10))
    pos12 = pos10;
  else
    pos12 = value_validator(input, pos10);
  uint64_t pos1;
  if (is_error(pos12))
    pos1 = pos12;
  else
  {
    uint64_t pos11 = add_method_validator(input, pos12);
    if (is_error(pos11))
      pos1 = pos11;
    else
      pos1 = vbool_validator(input, pos11);
  }
  if (is_error(pos1))
    return pos1;
  else
    return vbool_validator(input, pos1);
}

static uint32_t record_jumper(slice input, uint32_t pos)
{
  return vbool_jumper(vbool_jumper(add_method_jumper(value_jumper(input, key_jumper(pos)))));
}

typedef struct __Veritas_Formats_Types_key_Veritas_Formats_Types_value_s
{
  Veritas_Formats_Types_key fst;
  Veritas_Formats_Types_value snd;
}
__Veritas_Formats_Types_key_Veritas_Formats_Types_value;

typedef struct __Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool_s
{
  Veritas_Formats_Types_add_method fst;
  Veritas_Formats_Types_vbool snd;
}
__Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool;

typedef struct
__K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool_s
{
  __Veritas_Formats_Types_key_Veritas_Formats_Types_value fst;
  __Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool snd;
}
__K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool;

typedef struct record__s
{
  __K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool
  fst;
  Veritas_Formats_Types_vbool snd;
}
record_;

static Veritas_Formats_Types_record record_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_key x1 = key_reader(input, pos);
  uint32_t pos20 = key_jumper(pos);
  Veritas_Formats_Types_value x2 = value_reader(input, pos20);
  __Veritas_Formats_Types_key_Veritas_Formats_Types_value x10 = { .fst = x1, .snd = x2 };
  uint32_t pos22 = value_jumper(input, key_jumper(pos));
  Veritas_Formats_Types_add_method x11 = add_method_reader(input, pos22);
  uint32_t pos21 = add_method_jumper(pos22);
  Veritas_Formats_Types_vbool x20 = vbool_reader(input, pos21);
  __Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool
  x21 = { .fst = x11, .snd = x20 };
  __K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool
  x12 = { .fst = x10, .snd = x21 };
  uint32_t pos2 = vbool_jumper(add_method_jumper(value_jumper(input, key_jumper(pos))));
  Veritas_Formats_Types_vbool x22 = vbool_reader(input, pos2);
  record_ res = { .fst = x12, .snd = x22 };
  Veritas_Formats_Types_vbool record_r_child_in_store = res.snd;
  Veritas_Formats_Types_vbool record_l_child_in_store = res.fst.snd.snd;
  Veritas_Formats_Types_add_method record_add_method = res.fst.snd.fst;
  Veritas_Formats_Types_value record_value = res.fst.fst.snd;
  Veritas_Formats_Types_key record_key = res.fst.fst.fst;
  return
    (
      (Veritas_Formats_Types_record){
        .record_key = record_key,
        .record_value = record_value,
        .record_add_method = record_add_method,
        .record_l_child_in_store = record_l_child_in_store,
        .record_r_child_in_store = record_r_child_in_store
      }
    );
}

static uint64_t vlog_entry_addb_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = slot_id_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = record_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
  {
    uint64_t pos11 = timestamp_validator(input, pos1);
    if (is_error(pos11))
      return pos11;
    else
      return thread_id_validator(input, pos11);
  }
}

typedef struct __uint16_t_Veritas_Formats_Types_record_s
{
  uint16_t fst;
  Veritas_Formats_Types_record snd;
}
__uint16_t_Veritas_Formats_Types_record;

typedef struct __uint64_t_uint16_t_s
{
  uint64_t fst;
  uint16_t snd;
}
__uint64_t_uint16_t;

typedef struct vlog_entry_addb__s
{
  __uint16_t_Veritas_Formats_Types_record fst;
  __uint64_t_uint16_t snd;
}
vlog_entry_addb_;

static Veritas_Formats_Types_vlog_entry_addb vlog_entry_addb_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  Veritas_Formats_Types_record x2 = record_reader(input, pos20);
  __uint16_t_Veritas_Formats_Types_record x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = record_jumper(input, slot_id_jumper(pos));
  uint64_t x11 = timestamp_reader(input, pos2);
  uint32_t pos21 = timestamp_jumper(pos2);
  uint16_t x20 = thread_id_reader(input, pos21);
  __uint64_t_uint16_t x21 = { .fst = x11, .snd = x20 };
  vlog_entry_addb_ res = { .fst = x10, .snd = x21 };
  uint16_t veab_j = res.snd.snd;
  uint64_t veab_t = res.snd.fst;
  Veritas_Formats_Types_record veab_r = res.fst.snd;
  uint16_t veab_s = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_vlog_entry_addb){
        .veab_s = veab_s,
        .veab_r = veab_r,
        .veab_t = veab_t,
        .veab_j = veab_j
      }
    );
}

static uint64_t vlog_entry_evictbm_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)12U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)12U;
}

typedef struct vlog_entry_evictm__s
{
  uint16_t fst;
  uint16_t snd;
}
vlog_entry_evictm_;

typedef struct vlog_entry_evictbm__s
{
  vlog_entry_evictm_ fst;
  uint64_t snd;
}
vlog_entry_evictbm_;

static Veritas_Formats_Types_vlog_entry_evictbm
vlog_entry_evictbm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  uint16_t x2 = slot_id_reader(input, pos20);
  vlog_entry_evictm_ x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = slot_id_jumper(slot_id_jumper(pos));
  uint64_t x20 = timestamp_reader(input, pos2);
  vlog_entry_evictbm_ res = { .fst = x10, .snd = x20 };
  uint64_t veebm_t = res.snd;
  uint16_t veebm_s2 = res.fst.snd;
  uint16_t veebm_s = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_vlog_entry_evictbm){
        .veebm_s = veebm_s,
        .veebm_s2 = veebm_s2,
        .veebm_t = veebm_t
      }
    );
}

static uint64_t vlog_entry_evictm_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)4U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)4U;
}

static Veritas_Formats_Types_vlog_entry_evictm
vlog_entry_evictm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  uint16_t x2 = slot_id_reader(input, pos2);
  vlog_entry_evictm_ res = { .fst = x1, .snd = x2 };
  uint16_t veem_s = res.fst;
  uint16_t veem_s2 = res.snd;
  return ((Veritas_Formats_Types_vlog_entry_evictm){ .veem_s = veem_s, .veem_s2 = veem_s2 });
}

static uint64_t vlog_entry_addm_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = slot_id_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = record_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
    return slot_id_validator(input, pos1);
}

typedef struct vlog_entry_addm__s
{
  __uint16_t_Veritas_Formats_Types_record fst;
  uint16_t snd;
}
vlog_entry_addm_;

static Veritas_Formats_Types_vlog_entry_addm vlog_entry_addm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  Veritas_Formats_Types_record x2 = record_reader(input, pos20);
  __uint16_t_Veritas_Formats_Types_record x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = record_jumper(input, slot_id_jumper(pos));
  uint16_t x20 = slot_id_reader(input, pos2);
  vlog_entry_addm_ res = { .fst = x10, .snd = x20 };
  uint16_t veam_s2 = res.snd;
  Veritas_Formats_Types_record veam_r = res.fst.snd;
  uint16_t veam_s = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_vlog_entry_addm){
        .veam_s = veam_s,
        .veam_r = veam_r,
        .veam_s2 = veam_s2
      }
    );
}

static uint64_t vlog_entry_get_put_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = slot_id_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return data_value_validator(input, pos1);
}

typedef struct vlog_entry_get_put__s
{
  uint16_t fst;
  Veritas_Formats_Types_data_value snd;
}
vlog_entry_get_put_;

static Veritas_Formats_Types_vlog_entry_get_put
vlog_entry_get_put_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  Veritas_Formats_Types_data_value x2 = data_value_reader(input, pos2);
  vlog_entry_get_put_ res = { .fst = x1, .snd = x2 };
  uint16_t vegp_s = res.fst;
  Veritas_Formats_Types_data_value vegp_v = res.snd;
  return ((Veritas_Formats_Types_vlog_entry_get_put){ .vegp_s = vegp_s, .vegp_v = vegp_v });
}

static uint64_t vlog_entry_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      return vlog_entry_get_put_validator(input, len_after_tag);
    else if (k_ == (uint8_t)1U)
      return vlog_entry_get_put_validator(input, len_after_tag);
    else if (k_ == (uint8_t)2U)
      return vlog_entry_addm_validator(input, len_after_tag);
    else if (k_ == (uint8_t)3U)
      return vlog_entry_evictm_validator(input, len_after_tag);
    else if (k_ == (uint8_t)4U)
      return vlog_entry_addb_validator(input, len_after_tag);
    else if (k_ == (uint8_t)5U)
      return vlog_entry_evictb_validator(input, len_after_tag);
    else if (k_ == (uint8_t)6U)
      return vlog_entry_evictbm_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

bool
__eq__Veritas_Formats_Types_vlog_entry_kind(
  Veritas_Formats_Types_vlog_entry_kind y,
  Veritas_Formats_Types_vlog_entry_kind x
)
{
  switch (x)
  {
    case Veritas_Formats_Types_Get:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Get:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_Put:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Put:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_AddM:
      {
        switch (y)
        {
          case Veritas_Formats_Types_AddM:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_EvictM:
      {
        switch (y)
        {
          case Veritas_Formats_Types_EvictM:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_AddB:
      {
        switch (y)
        {
          case Veritas_Formats_Types_AddB:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_EvictB:
      {
        switch (y)
        {
          case Veritas_Formats_Types_EvictB:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_EvictBM:
      {
        switch (y)
        {
          case Veritas_Formats_Types_EvictBM:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static Veritas_Formats_Types_vlog_entry vlog_entry_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Veritas_Formats_Types_vlog_entry_kind k;
  if (res == (uint8_t)0U)
    k = Veritas_Formats_Types_Get;
  else if (res == (uint8_t)1U)
    k = Veritas_Formats_Types_Put;
  else if (res == (uint8_t)2U)
    k = Veritas_Formats_Types_AddM;
  else if (res == (uint8_t)3U)
    k = Veritas_Formats_Types_EvictM;
  else if (res == (uint8_t)4U)
    k = Veritas_Formats_Types_AddB;
  else if (res == (uint8_t)5U)
    k = Veritas_Formats_Types_EvictB;
  else if (res == (uint8_t)6U)
    k = Veritas_Formats_Types_EvictBM;
  else
    k = Veritas_Formats_Types_Get;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_Get, k))
  {
    Veritas_Formats_Types_vlog_entry_get_put res = vlog_entry_get_put_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_Get,
          { .case_Ve_Get = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_Put, k))
  {
    Veritas_Formats_Types_vlog_entry_get_put res = vlog_entry_get_put_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_Put,
          { .case_Ve_Put = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_AddM, k))
  {
    Veritas_Formats_Types_vlog_entry_addm res = vlog_entry_addm_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_AddM,
          { .case_Ve_AddM = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_EvictM, k))
  {
    Veritas_Formats_Types_vlog_entry_evictm res = vlog_entry_evictm_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_EvictM,
          { .case_Ve_EvictM = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_AddB, k))
  {
    Veritas_Formats_Types_vlog_entry_addb res = vlog_entry_addb_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_AddB,
          { .case_Ve_AddB = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_EvictB, k))
  {
    Veritas_Formats_Types_vlog_entry_evictb res = vlog_entry_evictb_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_EvictB,
          { .case_Ve_EvictB = res }
        }
      );
  }
  else
  {
    Veritas_Formats_Types_vlog_entry_evictbm res = vlog_entry_evictbm_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_EvictBM,
          { .case_Ve_EvictBM = res }
        }
      );
  }
}

uint32_t Veritas_Formats_Parsers_serialize_length(Veritas_Formats_Types_value x)
{
  return value_size32(x);
}

void Veritas_Formats_Parsers_serialize_value(Veritas_Formats_Types_value v, uint8_t *dst)
{
  uint32_t uu____0 = value_lserializer(v, (uint8_t *)dst, (uint32_t)0U);
}

FStar_Pervasives_Native_option__Veritas_Formats_Types_vlog_entry
Veritas_Formats_Parsers_extract_log_entry_from(uint32_t len, uint8_t *buf, uint32_t *bpos)
{
  slice sl = { .base = buf, .len = len };
  uint32_t pos = bpos[0U];
  uint64_t pos_ = vlog_entry_validator(sl, (uint64_t)pos);
  if (is_error(pos_))
    return
      (
        (FStar_Pervasives_Native_option__Veritas_Formats_Types_vlog_entry){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    bpos[0U] = (uint32_t)pos_;
    return
      (
        (FStar_Pervasives_Native_option__Veritas_Formats_Types_vlog_entry){
          .tag = FStar_Pervasives_Native_Some,
          .v = vlog_entry_reader(sl, pos)
        }
      );
  }
}

