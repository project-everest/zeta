/*
  This file has been automatically generated by EverParse.
 */


#include "Veritas_Formats.h"

#define VALIDATOR_MAX_LENGTH ((uint64_t)4294967295U)

static inline bool is_error(uint64_t positionOrError)
{
  return positionOrError > VALIDATOR_MAX_LENGTH;
}

#define VALIDATOR_ERROR_GENERIC ((uint64_t)4294967296U)

#define VALIDATOR_ERROR_NOT_ENOUGH_DATA ((uint64_t)8589934592U)

typedef struct slice_s
{
  uint8_t *base;
  uint32_t len;
}
slice;

static uint32_t u256_size32(Veritas_Formats_Types_u256 input)
{
  uint32_t v1 = (uint32_t)8U;
  uint32_t v20 = (uint32_t)8U;
  uint32_t res0;
  if ((uint32_t)4294967295U - v20 < v1)
    res0 = (uint32_t)4294967295U;
  else
    res0 = v1 + v20;
  uint32_t v10 = res0;
  uint32_t v11 = (uint32_t)8U;
  uint32_t v2 = (uint32_t)8U;
  uint32_t res;
  if ((uint32_t)4294967295U - v2 < v11)
    res = (uint32_t)4294967295U;
  else
    res = v11 + v2;
  uint32_t v21 = res;
  if ((uint32_t)4294967295U - v21 < v10)
    return (uint32_t)4294967295U;
  else
    return v10 + v21;
}

static uint64_t u256_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t u256_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

typedef struct __uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
}
__uint64_t_uint64_t;

typedef struct u256__s
{
  __uint64_t_uint64_t fst;
  __uint64_t_uint64_t snd;
}
u256_;

static Veritas_Formats_Types_u256 u256_reader(slice input, uint32_t pos)
{
  uint8_t *x00 = input.base;
  uint64_t x1 = load64_be(x00 + pos);
  uint32_t pos20 = pos + (uint32_t)8U;
  uint8_t *x01 = input.base;
  uint64_t x2 = load64_be(x01 + pos20);
  __uint64_t_uint64_t x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = pos + (uint32_t)8U + (uint32_t)8U;
  uint8_t *x02 = input.base;
  uint64_t x11 = load64_be(x02 + pos2);
  uint32_t pos21 = pos2 + (uint32_t)8U;
  uint8_t *x0 = input.base;
  uint64_t x20 = load64_be(x0 + pos21);
  __uint64_t_uint64_t x21 = { .fst = x11, .snd = x20 };
  u256_ res = { .fst = x10, .snd = x21 };
  uint64_t v0 = res.snd.snd;
  uint64_t v1 = res.snd.fst;
  uint64_t v2 = res.fst.snd;
  uint64_t v3 = res.fst.fst;
  return ((Veritas_Formats_Types_u256){ .v3 = v3, .v2 = v2, .v1 = v1, .v0 = v0 });
}

static uint32_t u256_lserializer(Veritas_Formats_Types_u256 x, uint8_t *input, uint32_t pos)
{
  store64_be(input + pos, x.v3);
  uint32_t res0 = (uint32_t)8U;
  uint32_t len1 = res0;
  uint32_t pos10 = pos + len1;
  store64_be(input + pos10, x.v2);
  uint32_t res1 = (uint32_t)8U;
  uint32_t len2 = res1;
  uint32_t res2 = len1 + len2;
  uint32_t len10 = res2;
  uint32_t pos1 = pos + len10;
  store64_be(input + pos1, x.v1);
  uint32_t res = (uint32_t)8U;
  uint32_t len11 = res;
  uint32_t pos11 = pos1 + len11;
  store64_be(input + pos11, x.v0);
  uint32_t res3 = (uint32_t)8U;
  uint32_t len20 = res3;
  uint32_t res4 = len11 + len20;
  uint32_t len21 = res4;
  return len10 + len21;
}

static uint32_t (*hash_value_size32)(Veritas_Formats_Types_u256 x0) = u256_size32;

static uint64_t hash_value_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t hash_value_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

static Veritas_Formats_Types_u256 (*hash_value_reader)(slice x0, uint32_t x1) = u256_reader;

static uint32_t
(*hash_value_lserializer)(Veritas_Formats_Types_u256 x0, uint8_t *x1, uint32_t x2) =
  u256_lserializer;

static uint64_t slot_id_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)2U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)2U;
}

static uint32_t slot_id_jumper(uint32_t pos)
{
  return pos + (uint32_t)2U;
}

static uint16_t slot_id_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load16_be(x0 + pos);
}

static uint64_t timestamp_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)8U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)8U;
}

static uint32_t timestamp_jumper(uint32_t pos)
{
  return pos + (uint32_t)8U;
}

static uint64_t timestamp_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load64_be(x0 + pos);
}

static uint32_t timestamp_lserializer(uint64_t v, uint8_t *b, uint32_t pos)
{
  store64_be(b + pos, v);
  return (uint32_t)8U;
}

static uint64_t vlog_entry_evictb_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)10U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)10U;
}

typedef struct vlog_entry_evictb__s
{
  uint16_t fst;
  uint64_t snd;
}
vlog_entry_evictb_;

static Veritas_Formats_Types_vlog_entry_evictb
vlog_entry_evictb_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  uint64_t x2 = timestamp_reader(input, pos2);
  vlog_entry_evictb_ res = { .fst = x1, .snd = x2 };
  uint16_t veeb_s = res.fst;
  uint64_t veeb_t = res.snd;
  return ((Veritas_Formats_Types_vlog_entry_evictb){ .veeb_s = veeb_s, .veeb_t = veeb_t });
}

static uint32_t (*data_t_size32)(Veritas_Formats_Types_u256 x0) = u256_size32;

static uint64_t data_t_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t data_t_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

static Veritas_Formats_Types_u256 (*data_t_reader)(slice x0, uint32_t x1) = u256_reader;

static uint32_t
(*data_t_lserializer)(Veritas_Formats_Types_u256 x0, uint8_t *x1, uint32_t x2) =
  u256_lserializer;

static uint32_t vbool_size32(Veritas_Formats_Types_vbool x)
{
  return (uint32_t)1U;
}

static uint64_t vbool_validator(slice input, uint64_t pos)
{
  uint64_t res;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    res = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    res = pos + (uint64_t)1U;
  if (is_error(res))
    return res;
  else
  {
    uint8_t va = input.base[(uint32_t)pos];
    bool ite;
    if (va == (uint8_t)0U)
      ite = true;
    else if (va == (uint8_t)1U)
      ite = true;
    else
      ite = false;
    if (!ite)
      return VALIDATOR_ERROR_GENERIC;
    else
      return res;
  }
}

static uint32_t vbool_jumper(uint32_t pos)
{
  return pos + (uint32_t)1U;
}

static Veritas_Formats_Types_vbool vbool_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  if (res == (uint8_t)0U)
    return Veritas_Formats_Types_Vfalse;
  else if (res == (uint8_t)1U)
    return Veritas_Formats_Types_Vtrue;
  else
    return Veritas_Formats_Types_Vfalse;
}

static bool
__eq__Veritas_Formats_Types_vbool(Veritas_Formats_Types_vbool y, Veritas_Formats_Types_vbool x)
{
  switch (x)
  {
    case Veritas_Formats_Types_Vfalse:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Vfalse:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_Vtrue:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Vtrue:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static uint32_t vbool_writer(Veritas_Formats_Types_vbool x, slice input, uint32_t pos)
{
  uint8_t ite;
  if (__eq__Veritas_Formats_Types_vbool(Veritas_Formats_Types_Vfalse, x))
    ite = (uint8_t)0U;
  else
    ite = (uint8_t)1U;
  input.base[pos] = ite;
  uint32_t len = (uint32_t)1U;
  uint32_t res = pos + len;
  uint32_t pos_ = res;
  uint32_t pos_0 = pos_;
  return pos_0;
}

static uint32_t vbool_lserializer(Veritas_Formats_Types_vbool x, uint8_t *b, uint32_t pos)
{
  uint32_t pos_ = vbool_writer(x, ((slice){ .base = b, .len = pos + (uint32_t)1U }), pos);
  return pos_ - pos;
}

extern uint32_t
Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_size32(uint16_t uu___);

extern uint64_t
Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_validator(
  slice uu___,
  uint64_t x0
);

extern uint16_t
Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_reader(
  slice uu___,
  uint32_t x0
);

extern uint32_t
Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_lserializer(
  uint16_t uu___,
  uint8_t *x0,
  uint32_t x1
);

static uint32_t key_size32(Veritas_Formats_Types_key input)
{
  uint32_t v1 = u256_size32(input.k);
  uint32_t
  v2 =
    Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_size32(input.significant_digits);
  if ((uint32_t)4294967295U - v2 < v1)
    return (uint32_t)4294967295U;
  else
    return v1 + v2;
}

static uint64_t key_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = u256_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return
      Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_validator(input,
        pos1);
}

static uint32_t key_jumper(uint32_t pos)
{
  return pos + (uint32_t)34U;
}

typedef struct key__s
{
  Veritas_Formats_Types_u256 fst;
  uint16_t snd;
}
key_;

static Veritas_Formats_Types_key key_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_u256 x1 = u256_reader(input, pos);
  uint32_t pos2 = u256_jumper(pos);
  uint16_t
  x2 = Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_reader(input, pos2);
  key_ res = { .fst = x1, .snd = x2 };
  Veritas_Formats_Types_u256 k = res.fst;
  uint16_t significant_digits = res.snd;
  return ((Veritas_Formats_Types_key){ .k = k, .significant_digits = significant_digits });
}

static uint32_t key_lserializer(Veritas_Formats_Types_key x, uint8_t *input, uint32_t pos)
{
  uint32_t res = u256_lserializer(x.k, input, pos);
  uint32_t len1 = res;
  uint32_t pos1 = pos + len1;
  uint32_t
  res0 =
    Veritas_Formats_EverParse_Significant_digits_t_significant_digits_t_lserializer(x.significant_digits,
      input,
      pos1);
  uint32_t len2 = res0;
  return len1 + len2;
}

static uint32_t descendent_hash_desc_size32(Veritas_Formats_Types_descendent_hash_desc input)
{
  uint32_t v1 = key_size32(input.dhd_key);
  uint32_t v20 = hash_value_size32(input.dhd_h);
  uint32_t res;
  if ((uint32_t)4294967295U - v20 < v1)
    res = (uint32_t)4294967295U;
  else
    res = v1 + v20;
  uint32_t v10 = res;
  uint32_t v2 = vbool_size32(input.evicted_to_blum);
  if ((uint32_t)4294967295U - v2 < v10)
    return (uint32_t)4294967295U;
  else
    return v10 + v2;
}

static uint64_t descendent_hash_desc_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = key_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = hash_value_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
    return vbool_validator(input, pos1);
}

static uint32_t descendent_hash_desc_jumper(uint32_t pos)
{
  return pos + (uint32_t)67U;
}

typedef struct __Veritas_Formats_Types_key_Veritas_Formats_Types_u256_s
{
  Veritas_Formats_Types_key fst;
  Veritas_Formats_Types_u256 snd;
}
__Veritas_Formats_Types_key_Veritas_Formats_Types_u256;

typedef struct descendent_hash_desc__s
{
  __Veritas_Formats_Types_key_Veritas_Formats_Types_u256 fst;
  Veritas_Formats_Types_vbool snd;
}
descendent_hash_desc_;

static Veritas_Formats_Types_descendent_hash_desc
descendent_hash_desc_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_key x1 = key_reader(input, pos);
  uint32_t pos20 = key_jumper(pos);
  Veritas_Formats_Types_u256 x2 = hash_value_reader(input, pos20);
  __Veritas_Formats_Types_key_Veritas_Formats_Types_u256 x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = hash_value_jumper(key_jumper(pos));
  Veritas_Formats_Types_vbool x20 = vbool_reader(input, pos2);
  descendent_hash_desc_ res = { .fst = x10, .snd = x20 };
  Veritas_Formats_Types_vbool evicted_to_blum = res.snd;
  Veritas_Formats_Types_u256 dhd_h = res.fst.snd;
  Veritas_Formats_Types_key dhd_key = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_descendent_hash_desc){
        .dhd_key = dhd_key,
        .dhd_h = dhd_h,
        .evicted_to_blum = evicted_to_blum
      }
    );
}

static uint32_t
descendent_hash_desc_lserializer(
  Veritas_Formats_Types_descendent_hash_desc x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t res = key_lserializer(x.dhd_key, input, pos);
  uint32_t len1 = res;
  uint32_t pos10 = pos + len1;
  uint32_t res0 = hash_value_lserializer(x.dhd_h, input, pos10);
  uint32_t len2 = res0;
  uint32_t res1 = len1 + len2;
  uint32_t len10 = res1;
  uint32_t pos1 = pos + len10;
  uint32_t res2 = vbool_lserializer(x.evicted_to_blum, input, pos1);
  uint32_t len20 = res2;
  return len10 + len20;
}

static bool
__eq__Veritas_Formats_Types_voption(
  Veritas_Formats_Types_voption y,
  Veritas_Formats_Types_voption x
)
{
  switch (x)
  {
    case Veritas_Formats_Types_Vnone:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Vnone:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_Vsome:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Vsome:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static uint32_t descendent_hash_size32(Veritas_Formats_Types_descendent_hash x)
{
  Veritas_Formats_Types_voption tg;
  if (x.tag == Veritas_Formats_Types_Dh_vnone)
    tg = Veritas_Formats_Types_Vnone;
  else if (x.tag == Veritas_Formats_Types_Dh_vsome)
    tg = Veritas_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Veritas_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, tg))
    s2 = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_descendent_hash_desc ite;
    if (x.tag == Veritas_Formats_Types_Dh_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_descendent_hash_desc,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = descendent_hash_desc_size32(ite);
  }
  return s1 + s2;
}

static uint64_t descendent_hash_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      if ((uint64_t)input.len - len_after_tag < (uint64_t)0U)
        return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        return len_after_tag + (uint64_t)0U;
    else if (k_ == (uint8_t)1U)
      return descendent_hash_desc_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t descendent_hash_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return pos_after_tag + (uint32_t)0U;
  else if (k_ == (uint8_t)1U)
    return descendent_hash_desc_jumper(pos_after_tag);
  else
    return (uint32_t)0U;
}

static Veritas_Formats_Types_descendent_hash descendent_hash_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Veritas_Formats_Types_voption k;
  if (res == (uint8_t)0U)
    k = Veritas_Formats_Types_Vnone;
  else if (res == (uint8_t)1U)
    k = Veritas_Formats_Types_Vsome;
  else
    k = Veritas_Formats_Types_Vnone;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, k))
    return ((Veritas_Formats_Types_descendent_hash){ .tag = Veritas_Formats_Types_Dh_vnone });
  else
  {
    Veritas_Formats_Types_descendent_hash_desc res = descendent_hash_desc_reader(input, pos_);
    return
      ((Veritas_Formats_Types_descendent_hash){ .tag = Veritas_Formats_Types_Dh_vsome, ._0 = res });
  }
}

static uint32_t
descendent_hash_lserializer(Veritas_Formats_Types_descendent_hash x, uint8_t *b, uint32_t pos)
{
  Veritas_Formats_Types_voption tg;
  if (x.tag == Veritas_Formats_Types_Dh_vnone)
    tg = Veritas_Formats_Types_Vnone;
  else if (x.tag == Veritas_Formats_Types_Dh_vsome)
    tg = Veritas_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Veritas_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, tg))
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, tg))
    res = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_descendent_hash_desc ite;
    if (x.tag == Veritas_Formats_Types_Dh_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_descendent_hash_desc,
          "unreachable (pattern matches are exhaustive in F*)");
    res = descendent_hash_desc_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint64_t add_method_validator(slice input, uint64_t pos)
{
  uint64_t res;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    res = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    res = pos + (uint64_t)1U;
  if (is_error(res))
    return res;
  else
  {
    uint8_t va = input.base[(uint32_t)pos];
    bool ite;
    if (va == (uint8_t)0U)
      ite = true;
    else if (va == (uint8_t)1U)
      ite = true;
    else
      ite = false;
    if (!ite)
      return VALIDATOR_ERROR_GENERIC;
    else
      return res;
  }
}

static uint32_t add_method_jumper(uint32_t pos)
{
  return pos + (uint32_t)1U;
}

static Veritas_Formats_Types_add_method add_method_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  if (res == (uint8_t)0U)
    return Veritas_Formats_Types_MAdd;
  else if (res == (uint8_t)1U)
    return Veritas_Formats_Types_BAdd;
  else
    return Veritas_Formats_Types_MAdd;
}

static bool
__eq__Veritas_Formats_Types_add_method(
  Veritas_Formats_Types_add_method y,
  Veritas_Formats_Types_add_method x
)
{
  switch (x)
  {
    case Veritas_Formats_Types_MAdd:
      {
        switch (y)
        {
          case Veritas_Formats_Types_MAdd:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_BAdd:
      {
        switch (y)
        {
          case Veritas_Formats_Types_BAdd:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static uint32_t
add_method_writer(Veritas_Formats_Types_add_method x, slice input, uint32_t pos)
{
  uint8_t ite;
  if (__eq__Veritas_Formats_Types_add_method(Veritas_Formats_Types_MAdd, x))
    ite = (uint8_t)0U;
  else
    ite = (uint8_t)1U;
  input.base[pos] = ite;
  uint32_t len = (uint32_t)1U;
  uint32_t res = pos + len;
  uint32_t pos_ = res;
  uint32_t pos_0 = pos_;
  return pos_0;
}

static uint32_t
add_method_lserializer(Veritas_Formats_Types_add_method x, uint8_t *b, uint32_t pos)
{
  uint32_t pos_ = add_method_writer(x, ((slice){ .base = b, .len = pos + (uint32_t)1U }), pos);
  return pos_ - pos;
}

static uint64_t thread_id_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)2U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)2U;
}

static uint16_t thread_id_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load16_be(x0 + pos);
}

static uint32_t thread_id_lserializer(uint16_t v, uint8_t *b, uint32_t pos)
{
  store16_be(b + pos, v);
  return (uint32_t)2U;
}

static uint32_t data_value_size32(Veritas_Formats_Types_data_value x)
{
  Veritas_Formats_Types_voption tg;
  if (x.tag == Veritas_Formats_Types_Dv_vnone)
    tg = Veritas_Formats_Types_Vnone;
  else if (x.tag == Veritas_Formats_Types_Dv_vsome)
    tg = Veritas_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Veritas_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, tg))
    s2 = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_u256 ite;
    if (x.tag == Veritas_Formats_Types_Dv_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_u256,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = data_t_size32(ite);
  }
  return s1 + s2;
}

static uint64_t data_value_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      if ((uint64_t)input.len - len_after_tag < (uint64_t)0U)
        return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        return len_after_tag + (uint64_t)0U;
    else if (k_ == (uint8_t)1U)
      return data_t_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t data_value_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return pos_after_tag + (uint32_t)0U;
  else if (k_ == (uint8_t)1U)
    return data_t_jumper(pos_after_tag);
  else
    return (uint32_t)0U;
}

static Veritas_Formats_Types_data_value data_value_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Veritas_Formats_Types_voption k;
  if (res == (uint8_t)0U)
    k = Veritas_Formats_Types_Vnone;
  else if (res == (uint8_t)1U)
    k = Veritas_Formats_Types_Vsome;
  else
    k = Veritas_Formats_Types_Vnone;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, k))
    return ((Veritas_Formats_Types_data_value){ .tag = Veritas_Formats_Types_Dv_vnone });
  else
  {
    Veritas_Formats_Types_u256 res = data_t_reader(input, pos_);
    return
      ((Veritas_Formats_Types_data_value){ .tag = Veritas_Formats_Types_Dv_vsome, ._0 = res });
  }
}

static uint32_t
data_value_lserializer(Veritas_Formats_Types_data_value x, uint8_t *b, uint32_t pos)
{
  Veritas_Formats_Types_voption tg;
  if (x.tag == Veritas_Formats_Types_Dv_vnone)
    tg = Veritas_Formats_Types_Vnone;
  else if (x.tag == Veritas_Formats_Types_Dv_vsome)
    tg = Veritas_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Veritas_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, tg))
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (__eq__Veritas_Formats_Types_voption(Veritas_Formats_Types_Vnone, tg))
    res = (uint32_t)0U;
  else
  {
    Veritas_Formats_Types_u256 ite;
    if (x.tag == Veritas_Formats_Types_Dv_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_u256,
          "unreachable (pattern matches are exhaustive in F*)");
    res = data_t_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint32_t mval_value_size32(Veritas_Formats_Types_mval_value input)
{
  uint32_t v1 = descendent_hash_size32(input.l);
  uint32_t v2 = descendent_hash_size32(input.r);
  if ((uint32_t)4294967295U - v2 < v1)
    return (uint32_t)4294967295U;
  else
    return v1 + v2;
}

static uint64_t mval_value_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = descendent_hash_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return descendent_hash_validator(input, pos1);
}

static uint32_t mval_value_jumper(slice input, uint32_t pos)
{
  return descendent_hash_jumper(input, descendent_hash_jumper(input, pos));
}

typedef struct mval_value__s
{
  Veritas_Formats_Types_descendent_hash fst;
  Veritas_Formats_Types_descendent_hash snd;
}
mval_value_;

static Veritas_Formats_Types_mval_value mval_value_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_descendent_hash x1 = descendent_hash_reader(input, pos);
  uint32_t pos2 = descendent_hash_jumper(input, pos);
  Veritas_Formats_Types_descendent_hash x2 = descendent_hash_reader(input, pos2);
  mval_value_ res = { .fst = x1, .snd = x2 };
  Veritas_Formats_Types_descendent_hash l = res.fst;
  Veritas_Formats_Types_descendent_hash r = res.snd;
  return ((Veritas_Formats_Types_mval_value){ .l = l, .r = r });
}

static uint32_t
mval_value_lserializer(Veritas_Formats_Types_mval_value x, uint8_t *input, uint32_t pos)
{
  uint32_t res = descendent_hash_lserializer(x.l, input, pos);
  uint32_t len1 = res;
  uint32_t pos1 = pos + len1;
  uint32_t res0 = descendent_hash_lserializer(x.r, input, pos1);
  uint32_t len2 = res0;
  return len1 + len2;
}

static bool
__eq__Veritas_Formats_Types_value_kind(
  Veritas_Formats_Types_value_kind y,
  Veritas_Formats_Types_value_kind x
)
{
  switch (x)
  {
    case Veritas_Formats_Types_Mval:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Mval:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_Dval:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Dval:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static uint32_t value_size32(Veritas_Formats_Types_value x)
{
  Veritas_Formats_Types_value_kind tg;
  if (x.tag == Veritas_Formats_Types_V_mval)
    tg = Veritas_Formats_Types_Mval;
  else if (x.tag == Veritas_Formats_Types_V_dval)
    tg = Veritas_Formats_Types_Dval;
  else
    tg =
      KRML_EABORT(Veritas_Formats_Types_value_kind,
        "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (__eq__Veritas_Formats_Types_value_kind(Veritas_Formats_Types_Mval, tg))
  {
    Veritas_Formats_Types_mval_value ite;
    if (x.tag == Veritas_Formats_Types_V_mval)
      ite = x.case_V_mval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_mval_value,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = mval_value_size32(ite);
  }
  else
  {
    Veritas_Formats_Types_data_value ite;
    if (x.tag == Veritas_Formats_Types_V_dval)
      ite = x.case_V_dval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_data_value,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = data_value_size32(ite);
  }
  return s1 + s2;
}

static uint64_t value_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      return mval_value_validator(input, len_after_tag);
    else if (k_ == (uint8_t)1U)
      return data_value_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t value_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return mval_value_jumper(input, pos_after_tag);
  else if (k_ == (uint8_t)1U)
    return data_value_jumper(input, pos_after_tag);
  else
    return (uint32_t)0U;
}

static Veritas_Formats_Types_value value_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Veritas_Formats_Types_value_kind k;
  if (res == (uint8_t)0U)
    k = Veritas_Formats_Types_Mval;
  else if (res == (uint8_t)1U)
    k = Veritas_Formats_Types_Dval;
  else
    k = Veritas_Formats_Types_Mval;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_value_kind(Veritas_Formats_Types_Mval, k))
  {
    Veritas_Formats_Types_mval_value res = mval_value_reader(input, pos_);
    return
      ((Veritas_Formats_Types_value){ .tag = Veritas_Formats_Types_V_mval, { .case_V_mval = res } });
  }
  else
  {
    Veritas_Formats_Types_data_value res = data_value_reader(input, pos_);
    return
      ((Veritas_Formats_Types_value){ .tag = Veritas_Formats_Types_V_dval, { .case_V_dval = res } });
  }
}

static uint32_t value_lserializer(Veritas_Formats_Types_value x, uint8_t *b, uint32_t pos)
{
  Veritas_Formats_Types_value_kind tg;
  if (x.tag == Veritas_Formats_Types_V_mval)
    tg = Veritas_Formats_Types_Mval;
  else if (x.tag == Veritas_Formats_Types_V_dval)
    tg = Veritas_Formats_Types_Dval;
  else
    tg =
      KRML_EABORT(Veritas_Formats_Types_value_kind,
        "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (__eq__Veritas_Formats_Types_value_kind(Veritas_Formats_Types_Mval, tg))
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (__eq__Veritas_Formats_Types_value_kind(Veritas_Formats_Types_Mval, tg))
  {
    Veritas_Formats_Types_mval_value ite;
    if (x.tag == Veritas_Formats_Types_V_mval)
      ite = x.case_V_mval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_mval_value,
          "unreachable (pattern matches are exhaustive in F*)");
    res = mval_value_lserializer(ite, b, pos1);
  }
  else
  {
    Veritas_Formats_Types_data_value ite;
    if (x.tag == Veritas_Formats_Types_V_dval)
      ite = x.case_V_dval;
    else
      ite =
        KRML_EABORT(Veritas_Formats_Types_data_value,
          "unreachable (pattern matches are exhaustive in F*)");
    res = data_value_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint64_t record_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = key_validator(input, pos);
  uint64_t pos12;
  if (is_error(pos10))
    pos12 = pos10;
  else
    pos12 = value_validator(input, pos10);
  uint64_t pos1;
  if (is_error(pos12))
    pos1 = pos12;
  else
  {
    uint64_t pos11 = add_method_validator(input, pos12);
    if (is_error(pos11))
      pos1 = pos11;
    else
      pos1 = vbool_validator(input, pos11);
  }
  if (is_error(pos1))
    return pos1;
  else
    return vbool_validator(input, pos1);
}

static uint32_t record_jumper(slice input, uint32_t pos)
{
  return vbool_jumper(vbool_jumper(add_method_jumper(value_jumper(input, key_jumper(pos)))));
}

typedef struct __Veritas_Formats_Types_key_Veritas_Formats_Types_value_s
{
  Veritas_Formats_Types_key fst;
  Veritas_Formats_Types_value snd;
}
__Veritas_Formats_Types_key_Veritas_Formats_Types_value;

typedef struct __Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool_s
{
  Veritas_Formats_Types_add_method fst;
  Veritas_Formats_Types_vbool snd;
}
__Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool;

typedef struct
__K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool_s
{
  __Veritas_Formats_Types_key_Veritas_Formats_Types_value fst;
  __Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool snd;
}
__K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool;

typedef struct record__s
{
  __K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool
  fst;
  Veritas_Formats_Types_vbool snd;
}
record_;

static Veritas_Formats_Types_record record_reader(slice input, uint32_t pos)
{
  Veritas_Formats_Types_key x1 = key_reader(input, pos);
  uint32_t pos20 = key_jumper(pos);
  Veritas_Formats_Types_value x2 = value_reader(input, pos20);
  __Veritas_Formats_Types_key_Veritas_Formats_Types_value x10 = { .fst = x1, .snd = x2 };
  uint32_t pos22 = value_jumper(input, key_jumper(pos));
  Veritas_Formats_Types_add_method x11 = add_method_reader(input, pos22);
  uint32_t pos21 = add_method_jumper(pos22);
  Veritas_Formats_Types_vbool x20 = vbool_reader(input, pos21);
  __Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool
  x21 = { .fst = x11, .snd = x20 };
  __K___Veritas_Formats_Types_key_Veritas_Formats_Types_value_K___Veritas_Formats_Types_add_method_Veritas_Formats_Types_vbool
  x12 = { .fst = x10, .snd = x21 };
  uint32_t pos2 = vbool_jumper(add_method_jumper(value_jumper(input, key_jumper(pos))));
  Veritas_Formats_Types_vbool x22 = vbool_reader(input, pos2);
  record_ res = { .fst = x12, .snd = x22 };
  Veritas_Formats_Types_vbool record_r_child_in_store = res.snd;
  Veritas_Formats_Types_vbool record_l_child_in_store = res.fst.snd.snd;
  Veritas_Formats_Types_add_method record_add_method = res.fst.snd.fst;
  Veritas_Formats_Types_value record_value = res.fst.fst.snd;
  Veritas_Formats_Types_key record_key = res.fst.fst.fst;
  return
    (
      (Veritas_Formats_Types_record){
        .record_key = record_key,
        .record_value = record_value,
        .record_add_method = record_add_method,
        .record_l_child_in_store = record_l_child_in_store,
        .record_r_child_in_store = record_r_child_in_store
      }
    );
}

static uint32_t
record_lserializer(Veritas_Formats_Types_record x, uint8_t *input, uint32_t pos)
{
  uint32_t res0 = key_lserializer(x.record_key, input, pos);
  uint32_t len1 = res0;
  uint32_t pos10 = pos + len1;
  uint32_t res1 = value_lserializer(x.record_value, input, pos10);
  uint32_t len2 = res1;
  uint32_t res2 = len1 + len2;
  uint32_t len10 = res2;
  uint32_t pos12 = pos + len10;
  uint32_t res = add_method_lserializer(x.record_add_method, input, pos12);
  uint32_t len11 = res;
  uint32_t pos11 = pos12 + len11;
  uint32_t res3 = vbool_lserializer(x.record_l_child_in_store, input, pos11);
  uint32_t len20 = res3;
  uint32_t res4 = len11 + len20;
  uint32_t len21 = res4;
  uint32_t res5 = len10 + len21;
  uint32_t len12 = res5;
  uint32_t pos1 = pos + len12;
  uint32_t res6 = vbool_lserializer(x.record_r_child_in_store, input, pos1);
  uint32_t len22 = res6;
  return len12 + len22;
}

static uint64_t vlog_entry_addb_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = slot_id_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = record_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
  {
    uint64_t pos11 = timestamp_validator(input, pos1);
    if (is_error(pos11))
      return pos11;
    else
      return thread_id_validator(input, pos11);
  }
}

typedef struct __uint16_t_Veritas_Formats_Types_record_s
{
  uint16_t fst;
  Veritas_Formats_Types_record snd;
}
__uint16_t_Veritas_Formats_Types_record;

typedef struct __uint64_t_uint16_t_s
{
  uint64_t fst;
  uint16_t snd;
}
__uint64_t_uint16_t;

typedef struct vlog_entry_addb__s
{
  __uint16_t_Veritas_Formats_Types_record fst;
  __uint64_t_uint16_t snd;
}
vlog_entry_addb_;

static Veritas_Formats_Types_vlog_entry_addb vlog_entry_addb_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  Veritas_Formats_Types_record x2 = record_reader(input, pos20);
  __uint16_t_Veritas_Formats_Types_record x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = record_jumper(input, slot_id_jumper(pos));
  uint64_t x11 = timestamp_reader(input, pos2);
  uint32_t pos21 = timestamp_jumper(pos2);
  uint16_t x20 = thread_id_reader(input, pos21);
  __uint64_t_uint16_t x21 = { .fst = x11, .snd = x20 };
  vlog_entry_addb_ res = { .fst = x10, .snd = x21 };
  uint16_t veab_j = res.snd.snd;
  uint64_t veab_t = res.snd.fst;
  Veritas_Formats_Types_record veab_r = res.fst.snd;
  uint16_t veab_s = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_vlog_entry_addb){
        .veab_s = veab_s,
        .veab_r = veab_r,
        .veab_t = veab_t,
        .veab_j = veab_j
      }
    );
}

static uint32_t
stamped_record_lserializer(
  Veritas_Formats_Types_stamped_record x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t res = record_lserializer(x.sr_record, input, pos);
  uint32_t len1 = res;
  uint32_t pos10 = pos + len1;
  uint32_t res0 = timestamp_lserializer(x.sr_timestamp, input, pos10);
  uint32_t len2 = res0;
  uint32_t res1 = len1 + len2;
  uint32_t len10 = res1;
  uint32_t pos1 = pos + len10;
  uint32_t res2 = thread_id_lserializer(x.sr_thread_id, input, pos1);
  uint32_t len20 = res2;
  return len10 + len20;
}

static uint64_t vlog_entry_evictbm_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)12U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)12U;
}

typedef struct vlog_entry_evictm__s
{
  uint16_t fst;
  uint16_t snd;
}
vlog_entry_evictm_;

typedef struct vlog_entry_evictbm__s
{
  vlog_entry_evictm_ fst;
  uint64_t snd;
}
vlog_entry_evictbm_;

static Veritas_Formats_Types_vlog_entry_evictbm
vlog_entry_evictbm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  uint16_t x2 = slot_id_reader(input, pos20);
  vlog_entry_evictm_ x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = slot_id_jumper(slot_id_jumper(pos));
  uint64_t x20 = timestamp_reader(input, pos2);
  vlog_entry_evictbm_ res = { .fst = x10, .snd = x20 };
  uint64_t veebm_t = res.snd;
  uint16_t veebm_s2 = res.fst.snd;
  uint16_t veebm_s = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_vlog_entry_evictbm){
        .veebm_s = veebm_s,
        .veebm_s2 = veebm_s2,
        .veebm_t = veebm_t
      }
    );
}

static uint64_t vlog_entry_evictm_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)4U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)4U;
}

static Veritas_Formats_Types_vlog_entry_evictm
vlog_entry_evictm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  uint16_t x2 = slot_id_reader(input, pos2);
  vlog_entry_evictm_ res = { .fst = x1, .snd = x2 };
  uint16_t veem_s = res.fst;
  uint16_t veem_s2 = res.snd;
  return ((Veritas_Formats_Types_vlog_entry_evictm){ .veem_s = veem_s, .veem_s2 = veem_s2 });
}

static uint64_t vlog_entry_addm_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = slot_id_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = record_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
    return slot_id_validator(input, pos1);
}

typedef struct vlog_entry_addm__s
{
  __uint16_t_Veritas_Formats_Types_record fst;
  uint16_t snd;
}
vlog_entry_addm_;

static Veritas_Formats_Types_vlog_entry_addm vlog_entry_addm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  Veritas_Formats_Types_record x2 = record_reader(input, pos20);
  __uint16_t_Veritas_Formats_Types_record x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = record_jumper(input, slot_id_jumper(pos));
  uint16_t x20 = slot_id_reader(input, pos2);
  vlog_entry_addm_ res = { .fst = x10, .snd = x20 };
  uint16_t veam_s2 = res.snd;
  Veritas_Formats_Types_record veam_r = res.fst.snd;
  uint16_t veam_s = res.fst.fst;
  return
    (
      (Veritas_Formats_Types_vlog_entry_addm){
        .veam_s = veam_s,
        .veam_r = veam_r,
        .veam_s2 = veam_s2
      }
    );
}

static uint64_t vlog_entry_get_put_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = slot_id_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return data_value_validator(input, pos1);
}

typedef struct vlog_entry_get_put__s
{
  uint16_t fst;
  Veritas_Formats_Types_data_value snd;
}
vlog_entry_get_put_;

static Veritas_Formats_Types_vlog_entry_get_put
vlog_entry_get_put_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  Veritas_Formats_Types_data_value x2 = data_value_reader(input, pos2);
  vlog_entry_get_put_ res = { .fst = x1, .snd = x2 };
  uint16_t vegp_s = res.fst;
  Veritas_Formats_Types_data_value vegp_v = res.snd;
  return ((Veritas_Formats_Types_vlog_entry_get_put){ .vegp_s = vegp_s, .vegp_v = vegp_v });
}

static uint64_t vlog_entry_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      return vlog_entry_get_put_validator(input, len_after_tag);
    else if (k_ == (uint8_t)1U)
      return vlog_entry_get_put_validator(input, len_after_tag);
    else if (k_ == (uint8_t)2U)
      return vlog_entry_addm_validator(input, len_after_tag);
    else if (k_ == (uint8_t)3U)
      return vlog_entry_evictm_validator(input, len_after_tag);
    else if (k_ == (uint8_t)4U)
      return vlog_entry_addb_validator(input, len_after_tag);
    else if (k_ == (uint8_t)5U)
      return vlog_entry_evictb_validator(input, len_after_tag);
    else if (k_ == (uint8_t)6U)
      return vlog_entry_evictbm_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

bool
__eq__Veritas_Formats_Types_vlog_entry_kind(
  Veritas_Formats_Types_vlog_entry_kind y,
  Veritas_Formats_Types_vlog_entry_kind x
)
{
  switch (x)
  {
    case Veritas_Formats_Types_Get:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Get:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_Put:
      {
        switch (y)
        {
          case Veritas_Formats_Types_Put:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_AddM:
      {
        switch (y)
        {
          case Veritas_Formats_Types_AddM:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_EvictM:
      {
        switch (y)
        {
          case Veritas_Formats_Types_EvictM:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_AddB:
      {
        switch (y)
        {
          case Veritas_Formats_Types_AddB:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_EvictB:
      {
        switch (y)
        {
          case Veritas_Formats_Types_EvictB:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Veritas_Formats_Types_EvictBM:
      {
        switch (y)
        {
          case Veritas_Formats_Types_EvictBM:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

static Veritas_Formats_Types_vlog_entry vlog_entry_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Veritas_Formats_Types_vlog_entry_kind k;
  if (res == (uint8_t)0U)
    k = Veritas_Formats_Types_Get;
  else if (res == (uint8_t)1U)
    k = Veritas_Formats_Types_Put;
  else if (res == (uint8_t)2U)
    k = Veritas_Formats_Types_AddM;
  else if (res == (uint8_t)3U)
    k = Veritas_Formats_Types_EvictM;
  else if (res == (uint8_t)4U)
    k = Veritas_Formats_Types_AddB;
  else if (res == (uint8_t)5U)
    k = Veritas_Formats_Types_EvictB;
  else if (res == (uint8_t)6U)
    k = Veritas_Formats_Types_EvictBM;
  else
    k = Veritas_Formats_Types_Get;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_Get, k))
  {
    Veritas_Formats_Types_vlog_entry_get_put res = vlog_entry_get_put_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_Get,
          { .case_Ve_Get = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_Put, k))
  {
    Veritas_Formats_Types_vlog_entry_get_put res = vlog_entry_get_put_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_Put,
          { .case_Ve_Put = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_AddM, k))
  {
    Veritas_Formats_Types_vlog_entry_addm res = vlog_entry_addm_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_AddM,
          { .case_Ve_AddM = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_EvictM, k))
  {
    Veritas_Formats_Types_vlog_entry_evictm res = vlog_entry_evictm_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_EvictM,
          { .case_Ve_EvictM = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_AddB, k))
  {
    Veritas_Formats_Types_vlog_entry_addb res = vlog_entry_addb_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_AddB,
          { .case_Ve_AddB = res }
        }
      );
  }
  else if (__eq__Veritas_Formats_Types_vlog_entry_kind(Veritas_Formats_Types_EvictB, k))
  {
    Veritas_Formats_Types_vlog_entry_evictb res = vlog_entry_evictb_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_EvictB,
          { .case_Ve_EvictB = res }
        }
      );
  }
  else
  {
    Veritas_Formats_Types_vlog_entry_evictbm res = vlog_entry_evictbm_reader(input, pos_);
    return
      (
        (Veritas_Formats_Types_vlog_entry){
          .tag = Veritas_Formats_Types_Ve_EvictBM,
          { .case_Ve_EvictBM = res }
        }
      );
  }
}

bool Veritas_Formats_bool_of_vbool(Veritas_Formats_Types_vbool x)
{
  switch (x)
  {
    case Veritas_Formats_Types_Vfalse:
      {
        return false;
      }
    case Veritas_Formats_Types_Vtrue:
      {
        return true;
      }
    default:
      {
        KRML_HOST_EPRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

Veritas_Formats_Types_vbool Veritas_Formats_vbool_of_bool(bool x)
{
  if (x)
    return Veritas_Formats_Types_Vtrue;
  else
    return Veritas_Formats_Types_Vfalse;
}

uint32_t Veritas_Formats_serialize_length(Veritas_Formats_Types_value x)
{
  return value_size32(x);
}

void Veritas_Formats_serialize_value(Veritas_Formats_Types_value v, uint8_t *dst)
{
  uint32_t uu____0 = value_lserializer(v, (uint8_t *)dst, (uint32_t)0U);
}

FStar_Pervasives_Native_option__Veritas_Formats_Types_vlog_entry
Veritas_Formats_extract_log_entry_from(uint32_t len, uint8_t *buf, uint32_t *bpos)
{
  slice sl = { .base = buf, .len = len };
  uint32_t pos = bpos[0U];
  uint64_t pos_ = vlog_entry_validator(sl, (uint64_t)pos);
  if (is_error(pos_))
    return
      (
        (FStar_Pervasives_Native_option__Veritas_Formats_Types_vlog_entry){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    bpos[0U] = (uint32_t)pos_;
    return
      (
        (FStar_Pervasives_Native_option__Veritas_Formats_Types_vlog_entry){
          .tag = FStar_Pervasives_Native_Some,
          .v = vlog_entry_reader(sl, pos)
        }
      );
  }
}

uint32_t
Veritas_Formats_serialize_stamped_record(uint8_t *dst, Veritas_Formats_Types_stamped_record r)
{
  return stamped_record_lserializer(r, (uint8_t *)dst, (uint32_t)0U);
}

uint64_t Veritas_Formats_Types___proj__Mku256__item__v3(Veritas_Formats_Types_u256 projectee)
{
  return projectee.v3;
}

uint64_t Veritas_Formats_Types___proj__Mku256__item__v2(Veritas_Formats_Types_u256 projectee)
{
  return projectee.v2;
}

uint64_t Veritas_Formats_Types___proj__Mku256__item__v1(Veritas_Formats_Types_u256 projectee)
{
  return projectee.v1;
}

uint64_t Veritas_Formats_Types___proj__Mku256__item__v0(Veritas_Formats_Types_u256 projectee)
{
  return projectee.v0;
}

Veritas_Formats_Types_u256
Veritas_Formats_Types___proj__Mkkey__item__k(Veritas_Formats_Types_key projectee)
{
  return projectee.k;
}

uint16_t
Veritas_Formats_Types___proj__Mkkey__item__significant_digits(
  Veritas_Formats_Types_key projectee
)
{
  return projectee.significant_digits;
}

bool Veritas_Formats_Types_uu___is_Vnone(Veritas_Formats_Types_voption projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Vnone:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_Vsome(Veritas_Formats_Types_voption projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Vsome:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_Dv_vnone(Veritas_Formats_Types_data_value projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Dv_vnone)
    return true;
  else
    return false;
}

bool Veritas_Formats_Types_uu___is_Dv_vsome(Veritas_Formats_Types_data_value projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Dv_vsome)
    return true;
  else
    return false;
}

Veritas_Formats_Types_u256
Veritas_Formats_Types___proj__Dv_vsome__item___0(Veritas_Formats_Types_data_value projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Dv_vsome)
    return projectee._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Vfalse(Veritas_Formats_Types_vbool projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Vfalse:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_Vtrue(Veritas_Formats_Types_vbool projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Vtrue:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

Veritas_Formats_Types_key
Veritas_Formats_Types___proj__Mkdescendent_hash_desc__item__dhd_key(
  Veritas_Formats_Types_descendent_hash_desc projectee
)
{
  return projectee.dhd_key;
}

Veritas_Formats_Types_u256
Veritas_Formats_Types___proj__Mkdescendent_hash_desc__item__dhd_h(
  Veritas_Formats_Types_descendent_hash_desc projectee
)
{
  return projectee.dhd_h;
}

Veritas_Formats_Types_vbool
Veritas_Formats_Types___proj__Mkdescendent_hash_desc__item__evicted_to_blum(
  Veritas_Formats_Types_descendent_hash_desc projectee
)
{
  return projectee.evicted_to_blum;
}

bool Veritas_Formats_Types_uu___is_Dh_vnone(Veritas_Formats_Types_descendent_hash projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Dh_vnone)
    return true;
  else
    return false;
}

bool Veritas_Formats_Types_uu___is_Dh_vsome(Veritas_Formats_Types_descendent_hash projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Dh_vsome)
    return true;
  else
    return false;
}

Veritas_Formats_Types_descendent_hash_desc
Veritas_Formats_Types___proj__Dh_vsome__item___0(
  Veritas_Formats_Types_descendent_hash projectee
)
{
  if (projectee.tag == Veritas_Formats_Types_Dh_vsome)
    return projectee._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Mval(Veritas_Formats_Types_value_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Mval:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_Dval(Veritas_Formats_Types_value_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Dval:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

Veritas_Formats_Types_descendent_hash
Veritas_Formats_Types___proj__Mkmval_value__item__l(Veritas_Formats_Types_mval_value projectee)
{
  return projectee.l;
}

Veritas_Formats_Types_descendent_hash
Veritas_Formats_Types___proj__Mkmval_value__item__r(Veritas_Formats_Types_mval_value projectee)
{
  return projectee.r;
}

bool Veritas_Formats_Types_uu___is_V_mval(Veritas_Formats_Types_value projectee)
{
  if (projectee.tag == Veritas_Formats_Types_V_mval)
    return true;
  else
    return false;
}

Veritas_Formats_Types_mval_value
Veritas_Formats_Types___proj__V_mval__item___0(Veritas_Formats_Types_value projectee)
{
  if (projectee.tag == Veritas_Formats_Types_V_mval)
    return projectee.case_V_mval;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_V_dval(Veritas_Formats_Types_value projectee)
{
  if (projectee.tag == Veritas_Formats_Types_V_dval)
    return true;
  else
    return false;
}

Veritas_Formats_Types_data_value
Veritas_Formats_Types___proj__V_dval__item___0(Veritas_Formats_Types_value projectee)
{
  if (projectee.tag == Veritas_Formats_Types_V_dval)
    return projectee.case_V_dval;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_MAdd(Veritas_Formats_Types_add_method projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_MAdd:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_BAdd(Veritas_Formats_Types_add_method projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_BAdd:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

Veritas_Formats_Types_key
Veritas_Formats_Types___proj__Mkrecord__item__record_key(
  Veritas_Formats_Types_record projectee
)
{
  return projectee.record_key;
}

Veritas_Formats_Types_value
Veritas_Formats_Types___proj__Mkrecord__item__record_value(
  Veritas_Formats_Types_record projectee
)
{
  return projectee.record_value;
}

Veritas_Formats_Types_add_method
Veritas_Formats_Types___proj__Mkrecord__item__record_add_method(
  Veritas_Formats_Types_record projectee
)
{
  return projectee.record_add_method;
}

Veritas_Formats_Types_vbool
Veritas_Formats_Types___proj__Mkrecord__item__record_l_child_in_store(
  Veritas_Formats_Types_record projectee
)
{
  return projectee.record_l_child_in_store;
}

Veritas_Formats_Types_vbool
Veritas_Formats_Types___proj__Mkrecord__item__record_r_child_in_store(
  Veritas_Formats_Types_record projectee
)
{
  return projectee.record_r_child_in_store;
}

bool Veritas_Formats_Types_uu___is_Get(Veritas_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Get:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_Put(Veritas_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_Put:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_AddM(Veritas_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_AddM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_EvictM(Veritas_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_EvictM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_AddB(Veritas_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_AddB:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_EvictB(Veritas_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_EvictB:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Veritas_Formats_Types_uu___is_EvictBM(Veritas_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Veritas_Formats_Types_EvictBM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_get_put__item__vegp_s(
  Veritas_Formats_Types_vlog_entry_get_put projectee
)
{
  return projectee.vegp_s;
}

Veritas_Formats_Types_data_value
Veritas_Formats_Types___proj__Mkvlog_entry_get_put__item__vegp_v(
  Veritas_Formats_Types_vlog_entry_get_put projectee
)
{
  return projectee.vegp_v;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_addm__item__veam_s(
  Veritas_Formats_Types_vlog_entry_addm projectee
)
{
  return projectee.veam_s;
}

Veritas_Formats_Types_record
Veritas_Formats_Types___proj__Mkvlog_entry_addm__item__veam_r(
  Veritas_Formats_Types_vlog_entry_addm projectee
)
{
  return projectee.veam_r;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_addm__item__veam_s2(
  Veritas_Formats_Types_vlog_entry_addm projectee
)
{
  return projectee.veam_s2;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_evictm__item__veem_s(
  Veritas_Formats_Types_vlog_entry_evictm projectee
)
{
  return projectee.veem_s;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_evictm__item__veem_s2(
  Veritas_Formats_Types_vlog_entry_evictm projectee
)
{
  return projectee.veem_s2;
}

Veritas_Formats_Types_record
Veritas_Formats_Types___proj__Mkstamped_record__item__sr_record(
  Veritas_Formats_Types_stamped_record projectee
)
{
  return projectee.sr_record;
}

uint64_t
Veritas_Formats_Types___proj__Mkstamped_record__item__sr_timestamp(
  Veritas_Formats_Types_stamped_record projectee
)
{
  return projectee.sr_timestamp;
}

uint16_t
Veritas_Formats_Types___proj__Mkstamped_record__item__sr_thread_id(
  Veritas_Formats_Types_stamped_record projectee
)
{
  return projectee.sr_thread_id;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_addb__item__veab_s(
  Veritas_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_s;
}

Veritas_Formats_Types_record
Veritas_Formats_Types___proj__Mkvlog_entry_addb__item__veab_r(
  Veritas_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_r;
}

uint64_t
Veritas_Formats_Types___proj__Mkvlog_entry_addb__item__veab_t(
  Veritas_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_t;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_addb__item__veab_j(
  Veritas_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_j;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_evictb__item__veeb_s(
  Veritas_Formats_Types_vlog_entry_evictb projectee
)
{
  return projectee.veeb_s;
}

uint64_t
Veritas_Formats_Types___proj__Mkvlog_entry_evictb__item__veeb_t(
  Veritas_Formats_Types_vlog_entry_evictb projectee
)
{
  return projectee.veeb_t;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_evictbm__item__veebm_s(
  Veritas_Formats_Types_vlog_entry_evictbm projectee
)
{
  return projectee.veebm_s;
}

uint16_t
Veritas_Formats_Types___proj__Mkvlog_entry_evictbm__item__veebm_s2(
  Veritas_Formats_Types_vlog_entry_evictbm projectee
)
{
  return projectee.veebm_s2;
}

uint64_t
Veritas_Formats_Types___proj__Mkvlog_entry_evictbm__item__veebm_t(
  Veritas_Formats_Types_vlog_entry_evictbm projectee
)
{
  return projectee.veebm_t;
}

bool Veritas_Formats_Types_uu___is_Ve_Get(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_Get)
    return true;
  else
    return false;
}

Veritas_Formats_Types_vlog_entry_get_put
Veritas_Formats_Types___proj__Ve_Get__item___0(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_Get)
    return projectee.case_Ve_Get;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Ve_Put(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_Put)
    return true;
  else
    return false;
}

Veritas_Formats_Types_vlog_entry_get_put
Veritas_Formats_Types___proj__Ve_Put__item___0(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_Put)
    return projectee.case_Ve_Put;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Ve_AddM(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_AddM)
    return true;
  else
    return false;
}

Veritas_Formats_Types_vlog_entry_addm
Veritas_Formats_Types___proj__Ve_AddM__item___0(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_AddM)
    return projectee.case_Ve_AddM;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Ve_EvictM(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_EvictM)
    return true;
  else
    return false;
}

Veritas_Formats_Types_vlog_entry_evictm
Veritas_Formats_Types___proj__Ve_EvictM__item___0(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_EvictM)
    return projectee.case_Ve_EvictM;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Ve_AddB(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_AddB)
    return true;
  else
    return false;
}

Veritas_Formats_Types_vlog_entry_addb
Veritas_Formats_Types___proj__Ve_AddB__item___0(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_AddB)
    return projectee.case_Ve_AddB;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Ve_EvictB(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_EvictB)
    return true;
  else
    return false;
}

Veritas_Formats_Types_vlog_entry_evictb
Veritas_Formats_Types___proj__Ve_EvictB__item___0(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_EvictB)
    return projectee.case_Ve_EvictB;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Veritas_Formats_Types_uu___is_Ve_EvictBM(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_EvictBM)
    return true;
  else
    return false;
}

Veritas_Formats_Types_vlog_entry_evictbm
Veritas_Formats_Types___proj__Ve_EvictBM__item___0(Veritas_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Veritas_Formats_Types_Ve_EvictBM)
    return projectee.case_Ve_EvictBM;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

