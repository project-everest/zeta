module Record

(* This file has been automatically generated by EverParse. *)
open FStar.Bytes
module U8 = FStar.UInt8
module U16 = FStar.UInt16
module U32 = FStar.UInt32
module U64 = FStar.UInt64
module LP = LowParse.Spec
module LT = LowParse.TacLib
module LS = LowParse.SLow
module LPI = LowParse.Spec.AllIntegers
module LL = LowParse.Low
module L = FStar.List.Tot
module B = LowStar.Buffer
module BY = FStar.Bytes
module HS = FStar.HyperStack
module HST = FStar.HyperStack.ST
module LWP = LowParse.Writers.Instances

#reset-options "--using_facts_from '* -FStar.Tactics -FStar.Reflection' --z3rlimit 16 --z3cliopt smt.arith.nl=false --max_fuel 2 --max_ifuel 2"

type record' = (U64.t & U64.t)

inline_for_extraction let synth_record (x: record') : record =
  match x with (k,v) -> {
    k = k;
    v = v;
  }

inline_for_extraction let synth_record_recip (x: record) : record' = (x.k,x.v)

let synth_record_recip_inverse () : Lemma (LP.synth_inverse synth_record_recip synth_record) = ()

let synth_record_injective () : Lemma (LP.synth_injective synth_record) =
  LP.synth_inverse_synth_injective synth_record_recip synth_record;
  synth_record_recip_inverse ()

let synth_record_inverse () : Lemma (LP.synth_inverse synth_record synth_record_recip) =
  assert_norm (LP.synth_inverse synth_record synth_record_recip)

let synth_record_recip_injective () : Lemma (LP.synth_injective synth_record_recip) =
  synth_record_recip_inverse ();
  LP.synth_inverse_synth_injective synth_record synth_record_recip

noextract let record'_parser : LP.parser _ record' = (LPI.parse_u64 `LP.nondep_then` LPI.parse_u64)

noextract let record'_parser_kind = LP.get_parser_kind record'_parser

let record_parser =
  synth_record_injective ();
  assert_norm (record_parser_kind == record'_parser_kind);
  record'_parser `LP.parse_synth` synth_record

noextract let record'_serializer : LP.serializer record'_parser = (LPI.serialize_u64 `LP.serialize_nondep_then` LPI.serialize_u64)

let record_serializer =
  [@inline_let] let _ = synth_record_injective () in
  [@inline_let] let _ = synth_record_inverse () in
  [@inline_let] let _ = assert_norm (record_parser_kind == record'_parser_kind) in
  LP.serialize_synth _ synth_record record'_serializer synth_record_recip ()

let record_bytesize (x:record) : GTot nat = Seq.length (record_serializer x)

let record_bytesize_eq x = ()

inline_for_extraction let record'_parser32 : LS.parser32 record'_parser = (LS.parse32_u64 `LS.parse32_nondep_then` LS.parse32_u64)

let record_parser32 =
  [@inline_let] let _ = synth_record_injective () in
  [@inline_let] let _ = assert_norm (record_parser_kind == record'_parser_kind) in
  LS.parse32_synth _ synth_record (fun x -> synth_record x) record'_parser32 ()

inline_for_extraction let record'_serializer32 : LS.serializer32 record'_serializer = (LS.serialize32_u64 `LS.serialize32_nondep_then` LS.serialize32_u64)

let record_serializer32 =
  [@inline_let] let _ = synth_record_injective () in
  [@inline_let] let _ = synth_record_inverse () in
  [@inline_let] let _ = assert_norm (record_parser_kind == record'_parser_kind) in
  LS.serialize32_synth _ synth_record _ record'_serializer32 synth_record_recip (fun x -> synth_record_recip x) ()

inline_for_extraction let record'_size32 : LS.size32 record'_serializer = (LS.size32_u64 `LS.size32_nondep_then` LS.size32_u64)

let record_size32 =
  [@inline_let] let _ = synth_record_injective () in
  [@inline_let] let _ = synth_record_inverse () in
  [@inline_let] let _ = assert_norm (record_parser_kind == record'_parser_kind) in
  LS.size32_synth _ synth_record _ record'_size32 synth_record_recip (fun x -> synth_record_recip x) ()

inline_for_extraction let record'_reader : LL.leaf_reader record'_parser = (LL.read_nondep_then LL.jump_u64 LL.read_u64 LL.read_u64)

let record_reader =
  [@inline_let] let _ = synth_record_injective () in
  [@inline_let] let _ = assert_norm (record_parser_kind == record'_parser_kind) in
  LL.read_synth _ synth_record (fun x -> synth_record x) record'_reader ()

inline_for_extraction let record'_lserializer : LL.serializer32 record'_serializer = (LL.serialize32_u64 `LL.serialize32_nondep_then` LL.serialize32_u64)

let record_lserializer =
  [@inline_let] let _ = synth_record_injective () in
  [@inline_let] let _ = synth_record_inverse () in
  [@inline_let] let _ = assert_norm (record_parser_kind == record'_parser_kind) in
  LL.serialize32_synth record'_lserializer synth_record synth_record_recip (fun x -> synth_record_recip x) ()

let record_bytesize_eqn x =
  [@inline_let] let _ = synth_record_injective () in
  [@inline_let] let _ = synth_record_inverse () in
  [@inline_let] let _ = assert_norm (record_parser_kind == record'_parser_kind) in
  LP.serialize_synth_eq _ synth_record record'_serializer synth_record_recip () x;
LP.length_serialize_nondep_then LPI.serialize_u64 LPI.serialize_u64 x.k x.v;
  (assert (FStar.Seq.length (LP.serialize LP.serialize_u64 (x.k)) == 8));
  (assert (FStar.Seq.length (LP.serialize LP.serialize_u64 (x.v)) == 8));
  assert(record_bytesize x == Seq.length (LP.serialize LPI.serialize_u64 x.k) + Seq.length (LP.serialize LPI.serialize_u64 x.v))

let gaccessor'_record_k : LL.gaccessor record'_parser LPI.parse_u64 _ = (LL.gaccessor_then_fst (LL.gaccessor_id record'_parser))

let gaccessor'_record_v : LL.gaccessor record'_parser LPI.parse_u64 _ = (LL.gaccessor_then_snd (LL.gaccessor_id record'_parser))

inline_for_extraction noextract let accessor'_record_k : LL.accessor gaccessor'_record_k = (LL.accessor_then_fst (LL.accessor_id record'_parser))

inline_for_extraction noextract let accessor'_record_v : LL.accessor gaccessor'_record_v = (LL.accessor_then_snd (LL.accessor_id record'_parser) LL.jump_u64)

noextract let clens_record_record' : LL.clens record record' = synth_record_recip_inverse (); synth_record_recip_injective (); LL.clens_synth synth_record_recip synth_record

let gaccessor_record_record' : LL.gaccessor record_parser record'_parser clens_record_record' = synth_record_inverse (); synth_record_injective (); synth_record_recip_inverse (); LL.gaccessor_synth record'_parser synth_record synth_record_recip ()

inline_for_extraction noextract let accessor_record_record' : LL.accessor gaccessor_record_record' = synth_record_inverse (); synth_record_injective (); synth_record_recip_inverse (); LL.accessor_synth record'_parser synth_record synth_record_recip ()

let gaccessor_record_k = LL.gaccessor_ext (gaccessor_record_record' `LL.gaccessor_compose` gaccessor'_record_k) clens_record_k ()

let accessor_record_k = LL.accessor_ext (LL.accessor_compose accessor_record_record' accessor'_record_k ()) clens_record_k ()

let gaccessor_record_v = LL.gaccessor_ext (gaccessor_record_record' `LL.gaccessor_compose` gaccessor'_record_v) clens_record_v ()

let accessor_record_v = LL.accessor_ext (LL.accessor_compose accessor_record_record' accessor'_record_v ()) clens_record_v ()

let record_valid h #_ #_ input pos0 =
  let k = LL.contents LPI.parse_u64 h input pos0 in
  let pos1 = LL.get_valid_pos LPI.parse_u64 h input pos0 in
  let v = LL.contents LPI.parse_u64 h input pos1 in
  let pos2 = LL.get_valid_pos LPI.parse_u64 h input pos1 in
  LL.valid_nondep_then_intro h LPI.parse_u64 LPI.parse_u64 input pos0;
  assert_norm (record' == LP.get_parser_type record'_parser);
  assert_norm (record_parser_kind == record'_parser_kind);
  synth_record_injective ();
  LL.valid_synth_intro h record'_parser synth_record input pos0

