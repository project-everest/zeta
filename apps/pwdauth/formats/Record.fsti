module Record

(* This file has been automatically generated by EverParse. *)
open FStar.Bytes
module U8 = FStar.UInt8
module U16 = FStar.UInt16
module U32 = FStar.UInt32
module U64 = FStar.UInt64
module LP = LowParse.Spec.Base
module LS = LowParse.SLow.Base
module LPI = LowParse.Spec.AllIntegers
module LL = LowParse.Low.Base
module L = FStar.List.Tot
module B = LowStar.Buffer
module BY = FStar.Bytes
module HS = FStar.HyperStack
module HST = FStar.HyperStack.ST
module LWP = LowParse.Writers.Combinators


type record = {
  k : U64.t;
  v : U64.t;
}

inline_for_extraction noextract let record_parser_kind = LP.strong_parser_kind 16 16 (Some LP.ParserKindMetadataTotal)

noextract val record_parser: LP.parser record_parser_kind record

noextract val record_serializer: LP.serializer record_parser

noextract val record_bytesize (x:record) : GTot nat

noextract val record_bytesize_eq (x:record) : Lemma (record_bytesize x == Seq.length (LP.serialize record_serializer x))

val record_parser32: LS.parser32 record_parser

val record_serializer32: LS.serializer32 record_serializer

val record_size32: LS.size32 record_serializer

let record_validator: LL.validator record_parser = LL.validate_total_constant_size record_parser 16uL ()

let record_jumper: LL.jumper record_parser = LL.jump_constant_size record_parser 16ul ()

inline_for_extraction noextract let lwp_record = LWP.make_parser record_parser record_serializer record_jumper
val record_reader : LL.leaf_reader record_parser

val record_lserializer : LL.serializer32 record_serializer

val record_bytesize_eqn (x: record) : Lemma (record_bytesize x == 8 + 8) [SMTPat (record_bytesize x)]

noextract let clens_record_k : LL.clens record U64.t = {
  LL.clens_cond = (fun _ -> True);
  LL.clens_get = (fun x -> x.k);
}

noextract let clens_record_v : LL.clens record U64.t = {
  LL.clens_cond = (fun _ -> True);
  LL.clens_get = (fun x -> x.v);
}

val gaccessor_record_k : LL.gaccessor record_parser LPI.parse_u64 clens_record_k

val accessor_record_k : LL.accessor gaccessor_record_k

inline_for_extraction noextract let lwp_accessor_record_k  : LWP.access_t lwp_record LWP.parse_u64 (accessor_record_k ) = LWP.access _ _ _

val gaccessor_record_v : LL.gaccessor record_parser LPI.parse_u64 clens_record_v

val accessor_record_v : LL.accessor gaccessor_record_v

inline_for_extraction noextract let lwp_accessor_record_v  : LWP.access_t lwp_record LWP.parse_u64 (accessor_record_v ) = LWP.access _ _ _

val record_valid (h:HS.mem) (#rrel: _) (#rel: _) (input:LL.slice rrel rel) (pos0:U32.t) : Lemma
  (requires (
  LL.valid LPI.parse_u64 h input pos0 /\ (
  let pos1 = LL.get_valid_pos LPI.parse_u64 h input pos0 in
  LL.valid LPI.parse_u64 h input pos1 /\ (
  let pos2 = LL.get_valid_pos LPI.parse_u64 h input pos1 in
  True
  ))))
  (ensures (
  let k = LL.contents LPI.parse_u64 h input pos0 in
  let pos1 = LL.get_valid_pos LPI.parse_u64 h input pos0 in
  let v = LL.contents LPI.parse_u64 h input pos1 in
  let pos2 = LL.get_valid_pos LPI.parse_u64 h input pos1 in
  LL.valid_content_pos record_parser h input pos0 ({
      k = k;
      v = v;
    }) pos2))

