0. Generation of Null values is busted;
   krmlinit static initializers?;
   Proof things.

1. (Nik) Regenerate code with an --add-include "application_types.h"
   Done


2. We would provide an application_types.h, with

   - definition for
       Zeta_Steel_ApplicationTypes_value_type
       Zeta_Steel_ApplicationTypes_key_type

   - implementation of an equality function on that type

extern bool
__eq__Zeta_Steel_ApplicationTypes_value_type(
  Zeta_Steel_ApplicationTypes_value_type x,
  Zeta_Steel_ApplicationTypes_value_type y
);

3. In .c, we have

extern void
Hacl_Blake2b_32_blake2b(
  uint32_t sout,
  uint8_t *p,
  uint32_t sd,
  uint8_t *nn,
  uint32_t output,
  uint8_t *ll
);


  This is implemented in hacl-star-v0.3.0/gcc-compatible/Hacl_Blake2b_32.h

  It's possible to build this file as a .o using the makefile provided by Hacl
    - ./configure --disable-ocaml
    - make Hacl_Blake2b_32.o

4. Implement "steel_atomics.h", with

   static inline bool Steel_ST_Reference_cas_u32(uint32_t *ref, uint32_t old_value, uint32_t new_value);


5. Some config values, to be provided

extern uint16_t Zeta_Steel_ApplicationTypes_store_size;

extern uint32_t Zeta_Steel_ApplicationTypes_n_threads;

6. parsers: These are already in ZetaFormats.h. We can compile that separately and link?

extern option__K___Zeta_Steel_LogEntry_Types_log_entry_uint32_t
zeta__parser_log_entry(uint32_t x0, uint32_t x1, uint32_t x2, uint8_t *x3);

extern uint32_t
zeta__serialize_stamped_record(uint32_t x0, uint32_t x1, uint8_t *x2, stamped_record x3);

extern uint32_t
zeta__serialize_value(
  uint32_t x0,
  uint32_t x1,
  uint8_t *x2,
  Zeta_Steel_LogEntry_Types_value x3
);

But in ZetaFormats.h, we have additional externs for parsing application keys and values

extern uint32_t
Zeta_Formats_Aux_Application_key_Size_application_key_size32(
  Zeta_Steel_ApplicationTypes_key_type uu___
);

But, these could be generated by writing a .qd file for the application formats and generate them automatically.

So, we need to decide on the formats for vget and vput.

Note: This one is already implemented in formats
extern uint32_t zeta__runapp_payload_offset(log_entry e);

6.5 (Nik) We need to expose an API to the thread store, i.e., in Zeta_Steel_Main.h, we'll have

    Done

We have:


typedef struct FStar_Pervasives_Native_option__Zeta_Steel_VerifierTypes_kv_s
{
  FStar_Pervasives_Native_option__Zeta_Steel_ApplicationTypes_value_type_tags tag;
  Zeta_Steel_VerifierTypes_kv v;
}
FStar_Pervasives_Native_option__Zeta_Steel_VerifierTypes_kv;

FStar_Pervasives_Native_option__Zeta_Steel_VerifierTypes_kv
Zeta_Steel_Main_read_store(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t slot);

void
Zeta_Steel_Main_write_store(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t slot,
  Zeta_Steel_LogEntry_Types_value v
);


7. The main callback to be provided by the application is:

//the parameter names are mangled ...

extern verify_runapp_result
Zeta_Steel_Application_run_app_function(
  runApp_payload pl,
  uint32_t pl_pos,
  uint8_t *log_array,
  uint32_t out_len,
  uint32_t out_offset,
  uint8_t *out,
  Zeta_Steel_VerifierTypes_thread_state_t t
);

////////////////////////////////////////////////////////////////////////////////

typedef struct runApp_payload_s
{
  uint8_t fid;   //name of the function fid
  uint32_t rest; //the length in bytes of the arguments to the function
}
runApp_payload;


AppFormats.rfc: (input to the qd tool)

uint64 key_type;
uint64 value_type;
uint64 slot_type;

struct {
  key_type k;
  slot_type s;
  value_type v;
} put;

struct {
  key_type k;
  slot_type s;
} get;

These will generate:

typedef struct  _put {
  uint64 k;
  uint64 v;
} PUT_T;

Boolean validate_put(uint8_t *array, uint32_t pos, uint32_t len);
PUT_T read_put(uint8_t *array, uint32_t pos, uint32_t len);


verify_runapp_result
Zeta_Steel_Application_run_app_function(
  runApp_payload pl,
  uint32_t pl_pos,
  uint8_t *log_array,
  uint32_t out_len,
  uint32_t out_offset,
  uint8_t *out,
  Zeta_Steel_VerifierTypes_thread_state_t t
)
{

   switch (pl.fid) {
   case VPUT:

      if (validate_put(log_array, pl_pos, pl.rest))
      {

          PUT_T args = read_put((log_array, pl_pos, pl.rest);
          _ maybe_entry = Zeta_Steel_Main_read_store(t, args.s);
          match maybe_entry with
          | None -> return app_failure;
          | Some entry ->
            if entry.v <> application_null_value
            || entry.k <> v.k
            then return app_failure
            else (Zeta_Steel_Main_write_store(t, args.s, {k,v});
                  return )

      }
      else { return fail ... }

      break;

   case VGET:

      break;

   default:
     return { tag:Run_app_parsing_failure, wrote:0 };

   }
}

==

1. Zeta_Steel_Main.c includes "internal/Zeta_Steel_Main.h" - why? this file is in the same directory.
   (fixed)

2. The following have to be moved to Zeta_Steel_Main.h from .c

typedef struct Zeta_Steel_HashAccumulator_ha_s
{
  uint8_t *acc;
  uint32_t *ctr;
}
Zeta_Steel_HashAccumulator_ha;

typedef struct Zeta_Steel_ThreadStateModel_store_entry_s
{
  Zeta_Steel_LogEntry_Types_key key;
  Zeta_Steel_LogEntry_Types_value value;
  Zeta_Steel_ThreadStateModel_add_method add_method;
  FStar_Pervasives_Native_option__uint16_t l_child_in_store;
  FStar_Pervasives_Native_option__uint16_t r_child_in_store;
  FStar_Pervasives_Native_option__K___uint16_t_bool parent_slot;
}
Zeta_Steel_ThreadStateModel_store_entry;

typedef struct Zeta_Steel_EpochHashes_epoch_hashes_t_s
{
  Zeta_Steel_HashAccumulator_ha hadd;
  Zeta_Steel_HashAccumulator_ha hevict;
}
Zeta_Steel_EpochHashes_epoch_hashes_t;
