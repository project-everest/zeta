/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/nswamy/everest/karamel/krml -warn-error +9 -skip-compilation -bundle Zeta.Steel.Main=Zeta.*,Prims,FStar.*,Hacl.*,Steel.* -library Steel.ST.Loops -library Steel.ST.Reference -static-header Steel.ST.Reference -no-prefix Zeta.Steel.LogEntry -no-prefix Zeta.Steel.LogEntry.Spec -hand-written Steel.ST.Reference ../_output/FStar_Algebra_CommMonoid_Equiv.krml ../_output/FStar_All.krml ../_output/FStar_BV.krml ../_output/FStar_BitVector.krml ../_output/FStar_Calc.krml ../_output/FStar_Char.krml ../_output/FStar_Classical.krml ../_output/FStar_Classical_Sugar.krml ../_output/FStar_ErasedLogic.krml ../_output/FStar_Exn.krml ../_output/FStar_FunctionalExtensionality.krml ../_output/FStar_Ghost.krml ../_output/FStar_Heap.krml ../_output/FStar_IndefiniteDescription.krml ../_output/FStar_Int.krml ../_output/FStar_Int16.krml ../_output/FStar_Int32.krml ../_output/FStar_Int64.krml ../_output/FStar_Int8.krml ../_output/FStar_Int_Cast.krml ../_output/FStar_List.krml ../_output/FStar_List_Tot.krml ../_output/FStar_List_Tot_Base.krml ../_output/FStar_List_Tot_Properties.krml ../_output/FStar_Map.krml ../_output/FStar_Math_Lemmas.krml ../_output/FStar_Math_Lib.krml ../_output/FStar_Monotonic_Heap.krml ../_output/FStar_Monotonic_Pure.krml ../_output/FStar_Monotonic_Witnessed.krml ../_output/FStar_Mul.krml ../_output/FStar_Order.krml ../_output/FStar_PCM.krml ../_output/FStar_PartialMap.krml ../_output/FStar_Pervasives.krml ../_output/FStar_Pervasives_Native.krml ../_output/FStar_PredicateExtensionality.krml ../_output/FStar_Preorder.krml ../_output/FStar_PropositionalExtensionality.krml ../_output/FStar_Range.krml ../_output/FStar_Real.krml ../_output/FStar_Reflection.krml ../_output/FStar_Reflection_Builtins.krml ../_output/FStar_Reflection_Const.krml ../_output/FStar_Reflection_Data.krml ../_output/FStar_Reflection_Derived.krml ../_output/FStar_Reflection_Derived_Lemmas.krml ../_output/FStar_Reflection_Formula.krml ../_output/FStar_Reflection_Types.krml ../_output/FStar_ST.krml ../_output/FStar_Seq.krml ../_output/FStar_Seq_Base.krml ../_output/FStar_Seq_Permutation.krml ../_output/FStar_Seq_Properties.krml ../_output/FStar_Set.krml ../_output/FStar_Squash.krml ../_output/FStar_String.krml ../_output/FStar_StrongExcludedMiddle.krml ../_output/FStar_TSet.krml ../_output/FStar_Tactics.krml ../_output/FStar_Tactics_Builtins.krml ../_output/FStar_Tactics_CanonCommMonoidSimple_Equiv.krml ../_output/FStar_Tactics_CanonCommSwaps.krml ../_output/FStar_Tactics_Common.krml ../_output/FStar_Tactics_Derived.krml ../_output/FStar_Tactics_Effect.krml ../_output/FStar_Tactics_Logic.krml ../_output/FStar_Tactics_Print.krml ../_output/FStar_Tactics_Result.krml ../_output/FStar_Tactics_SyntaxHelpers.krml ../_output/FStar_Tactics_Types.krml ../_output/FStar_Tactics_Util.krml ../_output/FStar_UInt.krml ../_output/FStar_UInt16.krml ../_output/FStar_UInt32.krml ../_output/FStar_UInt64.krml ../_output/FStar_UInt8.krml ../_output/FStar_Universe.krml ../_output/FStar_Universe_PCM.krml ../_output/FStar_VConfig.krml ../_output/FStar_WellFounded.krml ../_output/Hacl_Blake2b_32.krml ../_output/Steel_ST_Array_Util.krml ../_output/Steel_ST_CancellableSpinLock.krml ../_output/Steel_ST_EphemeralHashtbl.krml ../_output/Steel_ST_Loops.krml ../_output/Steel_ST_Reference.krml ../_output/Steel_ST_SpinLock.krml ../_output/Zeta_App.krml ../_output/Zeta_AppSimulate.krml ../_output/Zeta_AppSimulate_Helper.krml ../_output/Zeta_BinTree.krml ../_output/Zeta_BinTreePtr.krml ../_output/Zeta_Correctness.krml ../_output/Zeta_EAC.krml ../_output/Zeta_GenKey.krml ../_output/Zeta_GenericVerifier.krml ../_output/Zeta_Generic_Blum.krml ../_output/Zeta_Generic_Global.krml ../_output/Zeta_Generic_Interleave.krml ../_output/Zeta_Generic_TSLog.krml ../_output/Zeta_Generic_Thread.krml ../_output/Zeta_Hash.krml ../_output/Zeta_HashCollision.krml ../_output/Zeta_HashFunction.krml ../_output/Zeta_High_Blum.krml ../_output/Zeta_High_Global.krml ../_output/Zeta_High_Interleave.krml ../_output/Zeta_High_Merkle.krml ../_output/Zeta_High_SeqConsistent.krml ../_output/Zeta_High_TSLog.krml ../_output/Zeta_High_Thread.krml ../_output/Zeta_High_Verifier.krml ../_output/Zeta_High_Verifier_EAC.krml ../_output/Zeta_IdxFn.krml ../_output/Zeta_Interleave.krml ../_output/Zeta_Intermediate_Blum.krml ../_output/Zeta_Intermediate_Correctness.krml ../_output/Zeta_Intermediate_Global.krml ../_output/Zeta_Intermediate_Interleave.krml ../_output/Zeta_Intermediate_Logs.krml ../_output/Zeta_Intermediate_SlotKeyRel.krml ../_output/Zeta_Intermediate_StateRel.krml ../_output/Zeta_Intermediate_Store.krml ../_output/Zeta_Intermediate_TSLog.krml ../_output/Zeta_Intermediate_Thread.krml ../_output/Zeta_Intermediate_Verifier.krml ../_output/Zeta_Intermediate_VerifierConfig.krml ../_output/Zeta_Key.krml ../_output/Zeta_Merkle.krml ../_output/Zeta_MultiSet.krml ../_output/Zeta_MultiSetHashDomain.krml ../_output/Zeta_MultiSet_SSeq.krml ../_output/Zeta_Record.krml ../_output/Zeta_SMap.krml ../_output/Zeta_SSeq.krml ../_output/Zeta_SeqAux.krml ../_output/Zeta_SeqIdx.krml ../_output/Zeta_SeqMachine.krml ../_output/Zeta_Steel_AddMRel.krml ../_output/Zeta_Steel_AggregateEpochHashes.krml ../_output/Zeta_Steel_AppSim.krml ../_output/Zeta_Steel_Application.krml ../_output/Zeta_Steel_ApplicationRecord.krml ../_output/Zeta_Steel_ApplicationTypes.krml ../_output/Zeta_Steel_BitUtils.krml ../_output/Zeta_Steel_EpochHashes.krml ../_output/Zeta_Steel_EpochMap.krml ../_output/Zeta_Steel_FormatsManual.krml ../_output/Zeta_Steel_GlobalRel.krml ../_output/Zeta_Steel_HashAccumulator.krml ../_output/Zeta_Steel_HashValue.krml ../_output/Zeta_Steel_KeyUtils.krml ../_output/Zeta_Steel_Log.krml ../_output/Zeta_Steel_LogEntry.krml ../_output/Zeta_Steel_LogEntry_Spec.krml ../_output/Zeta_Steel_LogEntry_Types.krml ../_output/Zeta_Steel_LogRel.krml ../_output/Zeta_Steel_Main.krml ../_output/Zeta_Steel_MultiSetHash.krml ../_output/Zeta_Steel_Parser.krml ../_output/Zeta_Steel_Rel.krml ../_output/Zeta_Steel_StoreRel.krml ../_output/Zeta_Steel_Thread.krml ../_output/Zeta_Steel_ThreadLogMap.krml ../_output/Zeta_Steel_ThreadRel.krml ../_output/Zeta_Steel_ThreadRelDef.krml ../_output/Zeta_Steel_ThreadSim.krml ../_output/Zeta_Steel_ThreadStateModel.krml ../_output/Zeta_Steel_Util.krml ../_output/Zeta_Steel_Verifier.krml ../_output/Zeta_Steel_VerifierSteps.krml ../_output/Zeta_Steel_VerifierTypes.krml ../_output/Zeta_Thread.krml ../_output/Zeta_Time.krml ../_output/out.krml -tmpdir=../_output -add-include "steel_atomics.h" -add-include "zeta_application.h"
  F* version: 46cbaf03
  KaRaMeL version: 70084646
 */

#include "Zeta_Steel_Main.h"



extern void
Hacl_Blake2b_32_blake2b(
  uint32_t nn,
  uint8_t *output,
  uint32_t ll,
  uint8_t *d,
  uint32_t kk,
  uint8_t *_dummy
);

typedef uint32_t *lock_t;

static uint32_t *new_lock()
{
  uint32_t *r = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
  return r;
}

static uint32_t *fst___uint32_t____(uint32_t *x)
{
  return x;
}

static void acquire(uint32_t *l)
{
  bool b0 = Steel_ST_Reference_cas_u32(fst___uint32_t____(l), (uint32_t)0U, (uint32_t)1U);
  bool cond;
  if (b0)
    cond = false;
  else
    cond = true;
  while (cond)
  {
    bool b = Steel_ST_Reference_cas_u32(fst___uint32_t____(l), (uint32_t)0U, (uint32_t)1U);
    bool ite;
    if (b)
      ite = false;
    else
      ite = true;
    cond = ite;
  }
}

static void release(uint32_t *l)
{
  bool b = Steel_ST_Reference_cas_u32(fst___uint32_t____(l), (uint32_t)1U, (uint32_t)0U);
}

static Steel_ST_CancellableSpinLock_cancellable_lock new_cancellable_lock()
{
  KRML_CHECK_SIZE(sizeof (bool), (uint32_t)1U);
  bool *r = KRML_HOST_MALLOC(sizeof (bool));
  r[0U] = true;
  uint32_t *l = new_lock();
  return ((Steel_ST_CancellableSpinLock_cancellable_lock){ .lref = r, .llock = l });
}

static bool acquire0(Steel_ST_CancellableSpinLock_cancellable_lock c)
{
  acquire(c.llock);
  bool b = c.lref[0U];
  if (!b)
    release(c.llock);
  return b;
}

static void release0(Steel_ST_CancellableSpinLock_cancellable_lock c)
{
  release(c.llock);
}

static void cancel(Steel_ST_CancellableSpinLock_cancellable_lock c)
{
  KRML_HOST_FREE(c.lref);
}

typedef uint32_t uninterpreted;

static bool uu___is_ApplicationKey(Zeta_Steel_LogEntry_Types_key projectee)
{
  if (projectee.tag == Zeta_Steel_LogEntry_Types_ApplicationKey)
    return true;
  else
    return false;
}

typedef struct evictM_payload_s
{
  uint16_t s;
  uint16_t s_;
}
evictM_payload;

typedef struct evictB_payload_s
{
  uint16_t s1;
  uint64_t t;
}
evictB_payload;

typedef struct evictBM_payload_s
{
  uint16_t s2;
  uint16_t s_1;
  uint64_t t1;
}
evictBM_payload;

typedef struct runApp_payload_s
{
  uint8_t fid;
  uint32_t rest;
}
runApp_payload;

static bool uu___is_MValue(Zeta_Steel_LogEntry_Types_value projectee)
{
  if (projectee.tag == Zeta_Steel_LogEntry_Types_MValue)
    return true;
  else
    return false;
}

static bool uu___is_DValue(Zeta_Steel_LogEntry_Types_value projectee)
{
  if (projectee.tag == Zeta_Steel_LogEntry_Types_DValue)
    return true;
  else
    return false;
}

static bool is_value_of(Zeta_Steel_LogEntry_Types_key k, Zeta_Steel_LogEntry_Types_value v)
{
  if (uu___is_ApplicationKey(k))
    return uu___is_DValue(v);
  else
    return uu___is_MValue(v);
}

typedef struct record_s
{
  Zeta_Steel_LogEntry_Types_key fst;
  Zeta_Steel_LogEntry_Types_value snd;
}
record;

#define AddM 0
#define AddB 1
#define RunApp 2
#define EvictM 3
#define EvictB 4
#define EvictBM 5
#define NextEpoch 6
#define VerifyEpoch 7

typedef uint8_t log_entry_tags;

typedef struct log_entry_s
{
  log_entry_tags tag;
  union {
    struct 
    {
      uint16_t s;
      uint16_t s_;
      record r;
    }
    case_AddM;
    struct 
    {
      uint16_t s;
      uint64_t ts;
      uint16_t tid;
      record r;
    }
    case_AddB;
    runApp_payload case_RunApp;
    evictM_payload case_EvictM;
    evictB_payload case_EvictB;
    evictBM_payload case_EvictBM;
  }
  ;
}
log_entry;

typedef struct stamped_record_s
{
  record record;
  uint64_t timestamp;
  uint16_t thread_id;
}
stamped_record;

extern uint16_t Zeta_Steel_ApplicationTypes_store_size;

extern uint32_t Zeta_Steel_ApplicationTypes_n_threads;

typedef struct Zeta_Steel_HashAccumulator_ha_s
{
  uint8_t *acc;
  uint32_t *ctr;
}
Zeta_Steel_HashAccumulator_ha;

static Zeta_Steel_HashAccumulator_ha create()
{
  uint8_t *acc = KRML_HOST_CALLOC((uint32_t)32U, sizeof (uint8_t));
  uint32_t *ctr = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
  return ((Zeta_Steel_HashAccumulator_ha){ .acc = acc, .ctr = ctr });
}

static void reclaim(Zeta_Steel_HashAccumulator_ha s)
{
  KRML_HOST_FREE(s.ctr);
  KRML_HOST_FREE(s.acc);
}

static void aggregate_raw_hashes(uint8_t *b1, uint8_t *b2)
{
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i++)
  {
    uint8_t x1 = b1[i];
    uint8_t x2 = b2[i];
    b1[i] = x1 ^ x2;
  }
}

static bool aggregate(Zeta_Steel_HashAccumulator_ha b1, Zeta_Steel_HashAccumulator_ha b2)
{
  uint32_t ctr1 = b1.ctr[0U];
  uint32_t ctr2 = b2.ctr[0U];
  uint64_t ctr = (uint64_t)ctr1 + (uint64_t)ctr2;
  if (ctr > (uint64_t)0xffffffffU)
    return false;
  else
  {
    aggregate_raw_hashes(b1.acc, b2.acc);
    b1.ctr[0U] = (uint32_t)ctr;
    return true;
  }
}

static bool compare__uint8_t(uint8_t *a0, uint8_t *a1, uint32_t n)
{
  bool b = n == (uint32_t)0U;
  if (b)
    return true;
  else
  {
    uint32_t *r = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
    uint32_t i0 = r[0U];
    bool b10 = i0 == n;
    bool res0;
    if (b10)
      res0 = false;
    else
    {
      uint8_t elt0 = a0[i0];
      uint8_t elt1 = a1[i0];
      res0 = elt0 == elt1;
    }
    bool cond = res0;
    while (cond)
    {
      uint32_t i = r[0U];
      r[0U] = i + (uint32_t)1U;
      uint32_t i0 = r[0U];
      bool b1 = i0 == n;
      bool res;
      if (b1)
        res = false;
      else
      {
        uint8_t elt0 = a0[i0];
        uint8_t elt1 = a1[i0];
        res = elt0 == elt1;
      }
      cond = res;
    }
    uint32_t i = r[0U];
    KRML_HOST_FREE(r);
    return i == n;
  }
}

static bool compare(Zeta_Steel_HashAccumulator_ha b1, Zeta_Steel_HashAccumulator_ha b2)
{
  uint32_t c1 = b1.ctr[0U];
  uint32_t c2 = b2.ctr[0U];
  if (c1 != c2)
    return false;
  else
  {
    bool b = compare__uint8_t(b1.acc, b2.acc, (uint32_t)32U);
    return b;
  }
}

static bool add(Zeta_Steel_HashAccumulator_ha ha1, uint8_t *input, uint32_t l)
{
  uint8_t *acc = KRML_HOST_CALLOC((uint32_t)32U, sizeof (uint8_t));
  uint32_t *ctr = KRML_HOST_MALLOC(sizeof (uint32_t));
  ctr[0U] = (uint32_t)1U;
  uint8_t *_dummy = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint8_t));
  Hacl_Blake2b_32_blake2b((uint32_t)32U, acc, l, input, (uint32_t)0U, _dummy);
  Zeta_Steel_HashAccumulator_ha ha_ = { .acc = acc, .ctr = ctr };
  bool v = aggregate(ha1, ha_);
  reclaim(ha_);
  return v;
}

static FStar_Pervasives_Native_option__uint32_t check_overflow_add32(uint32_t x, uint32_t y)
{
  uint64_t res = (uint64_t)x + (uint64_t)y;
  if (res > (uint64_t)0xffffffffU)
    return ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_None });
  else
  {
    uint32_t res1 = (uint32_t)res;
    return
      ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_Some, .v = res1 });
  }
}

typedef struct option__uint64_t_s
{
  FStar_Pervasives_Native_option__Zeta_Steel_ApplicationTypes_value_type_tags tag;
  uint64_t v;
}
option__uint64_t;

static option__uint64_t check_overflow_add(uint64_t x, uint64_t y)
{
  uint64_t res = x + y;
  if (res < x)
    return ((option__uint64_t){ .tag = FStar_Pervasives_Native_None });
  else if (res - x == y)
    return ((option__uint64_t){ .tag = FStar_Pervasives_Native_Some, .v = res });
  else
    return ((option__uint64_t){ .tag = FStar_Pervasives_Native_None });
}

static FStar_Pervasives_Native_option__uint32_t st_check_overflow_add32(uint32_t x, uint32_t y)
{
  FStar_Pervasives_Native_option__uint32_t r = check_overflow_add32(x, y);
  return r;
}

typedef struct Zeta_Steel_ThreadStateModel_store_entry_s
{
  Zeta_Steel_LogEntry_Types_key key;
  Zeta_Steel_LogEntry_Types_value value;
  Zeta_Steel_ThreadStateModel_add_method add_method;
  FStar_Pervasives_Native_option__uint16_t l_child_in_store;
  FStar_Pervasives_Native_option__uint16_t r_child_in_store;
  FStar_Pervasives_Native_option__K___uint16_t_bool parent_slot;
}
Zeta_Steel_ThreadStateModel_store_entry;

static bool check_slot_bounds(uint16_t s)
{
  return s < Zeta_Steel_ApplicationTypes_store_size;
}

Zeta_Steel_LogEntry_Types_base_key Zeta_Steel_ThreadStateModel_root_base_key;

Zeta_Steel_LogEntry_Types_key Zeta_Steel_ThreadStateModel_root_key;

static Zeta_Steel_LogEntry_Types_value init_value(Zeta_Steel_LogEntry_Types_key k)
{
  if (uu___is_ApplicationKey(k))
    return
      (
        (Zeta_Steel_LogEntry_Types_value){
          .tag = Zeta_Steel_LogEntry_Types_DValue,
          { .case_DValue = { .tag = FStar_Pervasives_Native_None } }
        }
      );
  else
    return
      (
        (Zeta_Steel_LogEntry_Types_value){
          .tag = Zeta_Steel_LogEntry_Types_MValue,
          {
            .case_MValue = {
              .l = { .tag = Zeta_Steel_LogEntry_Types_Dh_vnone },
              .r = { .tag = Zeta_Steel_LogEntry_Types_Dh_vnone }
            }
          }
        }
      );
}

static Zeta_Steel_ThreadStateModel_store_entry
mk_entry_full(
  Zeta_Steel_LogEntry_Types_key k,
  Zeta_Steel_LogEntry_Types_value v,
  Zeta_Steel_ThreadStateModel_add_method a,
  FStar_Pervasives_Native_option__uint16_t l,
  FStar_Pervasives_Native_option__uint16_t r,
  FStar_Pervasives_Native_option__K___uint16_t_bool p
)
{
  return
    (
      (Zeta_Steel_ThreadStateModel_store_entry){
        .key = k,
        .value = v,
        .add_method = a,
        .l_child_in_store = l,
        .r_child_in_store = r,
        .parent_slot = p
      }
    );
}

static Zeta_Steel_ThreadStateModel_store_entry
mk_entry(
  Zeta_Steel_LogEntry_Types_key k,
  Zeta_Steel_LogEntry_Types_value v,
  Zeta_Steel_ThreadStateModel_add_method a
)
{
  return
    mk_entry_full(k,
      v,
      a,
      ((FStar_Pervasives_Native_option__uint16_t){ .tag = FStar_Pervasives_Native_None }),
      ((FStar_Pervasives_Native_option__uint16_t){ .tag = FStar_Pervasives_Native_None }),
      ((FStar_Pervasives_Native_option__K___uint16_t_bool){ .tag = FStar_Pervasives_Native_None }));
}

typedef struct option__Zeta_Steel_LogEntry_Types_mval_value_s
{
  FStar_Pervasives_Native_option__Zeta_Steel_ApplicationTypes_value_type_tags tag;
  Zeta_Steel_LogEntry_Types_mval_value v;
}
option__Zeta_Steel_LogEntry_Types_mval_value;

static option__Zeta_Steel_LogEntry_Types_mval_value
to_merkle_value(Zeta_Steel_LogEntry_Types_value v)
{
  if (v.tag == Zeta_Steel_LogEntry_Types_MValue)
  {
    Zeta_Steel_LogEntry_Types_mval_value v1 = v.case_MValue;
    return
      (
        (option__Zeta_Steel_LogEntry_Types_mval_value){
          .tag = FStar_Pervasives_Native_Some,
          .v = v1
        }
      );
  }
  else
    return ((option__Zeta_Steel_LogEntry_Types_mval_value){ .tag = FStar_Pervasives_Native_None });
}

static Zeta_Steel_LogEntry_Types_descendent_hash
desc_hash_dir(Zeta_Steel_LogEntry_Types_mval_value v, bool d)
{
  if (d)
    return v.l;
  else
    return v.r;
}

static Zeta_Steel_LogEntry_Types_mval_value
update_merkle_value(
  Zeta_Steel_LogEntry_Types_mval_value v,
  bool d,
  Zeta_Steel_LogEntry_Types_base_key k,
  Zeta_Steel_LogEntry_Types_u256 h,
  bool b
)
{
  Zeta_Steel_LogEntry_Types_vbool ite;
  if (b)
    ite = Zeta_Steel_LogEntry_Types_Vtrue;
  else
    ite = Zeta_Steel_LogEntry_Types_Vfalse;
  Zeta_Steel_LogEntry_Types_descendent_hash
  desc_hash =
    {
      .tag = Zeta_Steel_LogEntry_Types_Dh_vsome,
      ._0 = { .dhd_key = k, .dhd_h = h, .evicted_to_blum = ite }
    };
  if (d)
    return ((Zeta_Steel_LogEntry_Types_mval_value){ .l = desc_hash, .r = v.r });
  else
    return ((Zeta_Steel_LogEntry_Types_mval_value){ .l = v.l, .r = desc_hash });
}

Zeta_Steel_LogEntry_Types_u256 Zeta_Steel_ThreadStateModel_zero;

static Zeta_Steel_ThreadStateModel_store_entry
update_parent_slot(Zeta_Steel_ThreadStateModel_store_entry r, K___uint16_t_bool s)
{
  return
    (
      (Zeta_Steel_ThreadStateModel_store_entry){
        .key = r.key,
        .value = r.value,
        .add_method = r.add_method,
        .l_child_in_store = r.l_child_in_store,
        .r_child_in_store = r.r_child_in_store,
        .parent_slot = { .tag = FStar_Pervasives_Native_Some, .v = s }
      }
    );
}

static Zeta_Steel_ThreadStateModel_store_entry
update_child(Zeta_Steel_ThreadStateModel_store_entry r, bool d, uint16_t s)
{
  if (d)
    return
      (
        (Zeta_Steel_ThreadStateModel_store_entry){
          .key = r.key,
          .value = r.value,
          .add_method = r.add_method,
          .l_child_in_store = { .tag = FStar_Pervasives_Native_Some, .v = s },
          .r_child_in_store = r.r_child_in_store,
          .parent_slot = r.parent_slot
        }
      );
  else
    return
      (
        (Zeta_Steel_ThreadStateModel_store_entry){
          .key = r.key,
          .value = r.value,
          .add_method = r.add_method,
          .l_child_in_store = r.l_child_in_store,
          .r_child_in_store = { .tag = FStar_Pervasives_Native_Some, .v = s },
          .parent_slot = r.parent_slot
        }
      );
}

static FStar_Pervasives_Native_option__uint16_t
child_slot(Zeta_Steel_ThreadStateModel_store_entry r, bool d)
{
  if (d)
    return r.l_child_in_store;
  else
    return r.r_child_in_store;
}

static bool timestamp_lt(uint64_t t0, uint64_t t1)
{
  return t0 < t1;
}

static uint32_t epoch_of_timestamp(uint64_t t)
{
  return (uint32_t)(t >> (uint32_t)32U);
}

static bool is_root_key(Zeta_Steel_LogEntry_Types_key k)
{
  if (k.tag == Zeta_Steel_LogEntry_Types_InternalKey)
  {
    Zeta_Steel_LogEntry_Types_base_key k1 = k.case_InternalKey;
    return k1.significant_digits == (uint16_t)0U;
  }
  else
    return false;
}

static bool
epoch_greater_than_last_verified_epoch(
  FStar_Pervasives_Native_option__uint32_t lve,
  uint32_t e
)
{
  if (lve.tag == FStar_Pervasives_Native_None)
    return true;
  else if (lve.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t e_ = lve.v;
    return e_ < e;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Pervasives_Native_option__uint32_t
maybe_increment_last_verified_epoch(FStar_Pervasives_Native_option__uint32_t e)
{
  if (e.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = (uint32_t)0U
        }
      );
  else if (e.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t e1 = e.v;
    return check_overflow_add32(e1, (uint32_t)1U);
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

typedef struct Zeta_Steel_EpochHashes_epoch_hashes_t_s
{
  Zeta_Steel_HashAccumulator_ha hadd;
  Zeta_Steel_HashAccumulator_ha hevict;
}
Zeta_Steel_EpochHashes_epoch_hashes_t;

typedef struct Zeta_Steel_AggregateEpochHashes_all_epoch_hashes_s
{
  Steel_ST_EphemeralHashtbl_tbl__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t etbl;
  uint32_t *high;
}
Zeta_Steel_AggregateEpochHashes_all_epoch_hashes;

typedef struct Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps_s
{
  Steel_ST_EphemeralHashtbl_tbl__uint32_t__bool_ etbl;
  uint32_t *high;
}
Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps;

typedef struct Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes_s
{
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes hashes;
  Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps tid_bitmaps;
  FStar_Pervasives_Native_option__uint32_t *max_certified_epoch;
  Steel_ST_CancellableSpinLock_cancellable_lock lock;
}
Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes;

static uint32_t all_hashes_size = (uint32_t)32U;

static uint32_t tid_bitmaps_size = (uint32_t)32U;

static Zeta_Steel_AggregateEpochHashes_all_epoch_hashes
create__Zeta_Steel_EpochHashes_epoch_hashes_t(uint32_t n)
{
  KRML_CHECK_SIZE(sizeof (
      FStar_Pervasives_Native_option__K___uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t
    ),
    n);
  FStar_Pervasives_Native_option__K___uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t
  *store =
    KRML_HOST_MALLOC(sizeof (
        FStar_Pervasives_Native_option__K___uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t
      )
      * n);
  for (uint32_t _i = 0U; _i < n; ++_i)
    store[_i]
    =
      (
        (FStar_Pervasives_Native_option__K___uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  Steel_ST_EphemeralHashtbl_tbl__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t
  etbl = { .store_len = n, .store = store };
  uint32_t *high = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
  return ((Zeta_Steel_AggregateEpochHashes_all_epoch_hashes){ .etbl = etbl, .high = high });
}

static Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps create___bool_(uint32_t n)
{
  KRML_CHECK_SIZE(sizeof (FStar_Pervasives_Native_option__K___uint32_t__bool_), n);
  FStar_Pervasives_Native_option__K___uint32_t__bool_
  *store = KRML_HOST_MALLOC(sizeof (FStar_Pervasives_Native_option__K___uint32_t__bool_) * n);
  for (uint32_t _i = 0U; _i < n; ++_i)
    store[_i]
    =
      ((FStar_Pervasives_Native_option__K___uint32_t__bool_){ .tag = FStar_Pervasives_Native_None });
  Steel_ST_EphemeralHashtbl_tbl__uint32_t__bool_ etbl = { .store_len = n, .store = store };
  uint32_t *high = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
  return ((Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps){ .etbl = etbl, .high = high });
}

static Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes create0()
{
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes
  hashes = create__Zeta_Steel_EpochHashes_epoch_hashes_t(all_hashes_size);
  Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps
  tid_bitmaps = create___bool_(tid_bitmaps_size);
  KRML_CHECK_SIZE(sizeof (FStar_Pervasives_Native_option__uint32_t), (uint32_t)1U);
  FStar_Pervasives_Native_option__uint32_t
  *max_certified_epoch = KRML_HOST_MALLOC(sizeof (FStar_Pervasives_Native_option__uint32_t));
  max_certified_epoch[0U]
  = ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_None });
  Steel_ST_CancellableSpinLock_cancellable_lock lock = new_cancellable_lock();
  return
    (
      (Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes){
        .hashes = hashes,
        .tid_bitmaps = tid_bitmaps,
        .max_certified_epoch = max_certified_epoch,
        .lock = lock
      }
    );
}

static bool check_all_ones(bool *a)
{
  bool b = Zeta_Steel_ApplicationTypes_n_threads == (uint32_t)0U;
  if (b)
    return true;
  else
  {
    uint32_t *r = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint32_t));
    uint32_t i0 = r[0U];
    bool b10 = i0 == Zeta_Steel_ApplicationTypes_n_threads;
    bool res0;
    if (b10)
      res0 = false;
    else
      res0 = a[i0];
    bool cond = res0;
    while (cond)
    {
      uint32_t i = r[0U];
      r[0U] = i + (uint32_t)1U;
      uint32_t i0 = r[0U];
      bool b1 = i0 == Zeta_Steel_ApplicationTypes_n_threads;
      bool res;
      if (b1)
        res = false;
      else
        res = a[i0];
      cond = res;
    }
    uint32_t i = r[0U];
    KRML_HOST_FREE(r);
    return i == Zeta_Steel_ApplicationTypes_n_threads;
  }
}

#define Found 0
#define Fresh 1
#define NotFound 2

typedef uint8_t get_result___bool__tags;

typedef struct get_result___bool__s
{
  get_result___bool__tags tag;
  bool *_0;
}
get_result___bool_;

#define Present 0
#define Absent 1
#define Missing 2

typedef uint8_t get_result__uint32_t__bool__tags;

typedef struct get_result__uint32_t__bool__s
{
  get_result__uint32_t__bool__tags tag;
  union {
    bool *case_Present;
    uint32_t case_Missing;
  }
  ;
}
get_result__uint32_t__bool_;

static get_result___bool_
get___bool_(Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps a, uint32_t i)
{
  uint32_t high_value = a.high[0U];
  bool r = high_value < i;
  if (r)
    return ((get_result___bool_){ .tag = Fresh });
  else
  {
    uint32_t idx = i % a.etbl.store_len;
    FStar_Pervasives_Native_option__K___uint32_t__bool_ vopt = a.etbl.store[idx];
    get_result__uint32_t__bool_ r1;
    if (vopt.tag == FStar_Pervasives_Native_None)
      r1 = ((get_result__uint32_t__bool_){ .tag = Absent });
    else if (vopt.tag == FStar_Pervasives_Native_Some)
    {
      bool *x = vopt.v.snd;
      uint32_t i_ = vopt.v.fst;
      if (i != i_)
        r1 = ((get_result__uint32_t__bool_){ .tag = Missing, { .case_Missing = i_ } });
      else
        r1 = ((get_result__uint32_t__bool_){ .tag = Present, { .case_Present = x } });
    }
    else
      r1 =
        KRML_EABORT(get_result__uint32_t__bool_,
          "unreachable (pattern matches are exhaustive in F*)");
    get_result__uint32_t__bool_ x = r1;
    if (x.tag == Missing)
      return ((get_result___bool_){ .tag = NotFound });
    else if (x.tag == Absent)
      return ((get_result___bool_){ .tag = NotFound });
    else if (x.tag == Present)
    {
      bool *x1 = x.case_Present;
      return ((get_result___bool_){ .tag = Found, ._0 = x1 });
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static bool
check_bitmap_for_epoch(
  Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps tid_bitmaps,
  uint32_t e
)
{
  get_result___bool_ res = get___bool_(tid_bitmaps, e);
  if (res.tag == Found)
  {
    bool *a = res._0;
    bool b = check_all_ones(a);
    return b;
  }
  else
    return false;
}

typedef struct get_result__Zeta_Steel_EpochHashes_epoch_hashes_t_s
{
  get_result___bool__tags tag;
  Zeta_Steel_EpochHashes_epoch_hashes_t _0;
}
get_result__Zeta_Steel_EpochHashes_epoch_hashes_t;

typedef struct get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t_s
{
  get_result__uint32_t__bool__tags tag;
  union {
    Zeta_Steel_EpochHashes_epoch_hashes_t case_Present;
    uint32_t case_Missing;
  }
  ;
}
get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t;

static get_result__Zeta_Steel_EpochHashes_epoch_hashes_t
get__Zeta_Steel_EpochHashes_epoch_hashes_t(
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes a,
  uint32_t i
)
{
  uint32_t high_value = a.high[0U];
  bool r = high_value < i;
  if (r)
    return ((get_result__Zeta_Steel_EpochHashes_epoch_hashes_t){ .tag = Fresh });
  else
  {
    uint32_t idx = i % a.etbl.store_len;
    FStar_Pervasives_Native_option__K___uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t
    vopt = a.etbl.store[idx];
    get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t r1;
    if (vopt.tag == FStar_Pervasives_Native_None)
      r1 = ((get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t){ .tag = Absent });
    else if (vopt.tag == FStar_Pervasives_Native_Some)
    {
      Zeta_Steel_EpochHashes_epoch_hashes_t x = vopt.v.snd;
      uint32_t i_ = vopt.v.fst;
      if (i != i_)
        r1 =
          (
            (get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t){
              .tag = Missing,
              { .case_Missing = i_ }
            }
          );
      else
        r1 =
          (
            (get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t){
              .tag = Present,
              { .case_Present = x }
            }
          );
    }
    else
      r1 =
        KRML_EABORT(get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t,
          "unreachable (pattern matches are exhaustive in F*)");
    get_result__uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t x = r1;
    if (x.tag == Missing)
      return ((get_result__Zeta_Steel_EpochHashes_epoch_hashes_t){ .tag = NotFound });
    else if (x.tag == Absent)
      return ((get_result__Zeta_Steel_EpochHashes_epoch_hashes_t){ .tag = NotFound });
    else if (x.tag == Present)
    {
      Zeta_Steel_EpochHashes_epoch_hashes_t x1 = x.case_Present;
      return ((get_result__Zeta_Steel_EpochHashes_epoch_hashes_t){ .tag = Found, ._0 = x1 });
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static bool
check_hash_equality_for_epoch(
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes hashes,
  uint32_t e
)
{
  get_result__Zeta_Steel_EpochHashes_epoch_hashes_t
  res = get__Zeta_Steel_EpochHashes_epoch_hashes_t(hashes, e);
  if (res.tag == Found)
  {
    Zeta_Steel_EpochHashes_epoch_hashes_t ehs = res._0;
    bool b = compare(ehs.hadd, ehs.hevict);
    return b;
  }
  else
    return false;
}

static bool
try_increment_max(
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes hashes,
  Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps bitmaps,
  FStar_Pervasives_Native_option__uint32_t *max
)
{
  FStar_Pervasives_Native_option__uint32_t e = max[0U];
  FStar_Pervasives_Native_option__uint32_t v;
  if (e.tag == FStar_Pervasives_Native_None)
    v =
      (
        (FStar_Pervasives_Native_option__uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = (uint32_t)0U
        }
      );
  else if (e.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t e1 = e.v;
    v = check_overflow_add32(e1, (uint32_t)1U);
  }
  else
    v =
      KRML_EABORT(FStar_Pervasives_Native_option__uint32_t,
        "unreachable (pattern matches are exhaustive in F*)");
  if (v.tag == FStar_Pervasives_Native_None)
    return false;
  else if (v.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t e_ = v.v;
    bool ready = check_bitmap_for_epoch(bitmaps, e_);
    if (!ready)
      return false;
    else
    {
      bool b = check_hash_equality_for_epoch(hashes, e_);
      if (!b)
        return false;
      else
      {
        max[0U] =
          (
            (FStar_Pervasives_Native_option__uint32_t){
              .tag = FStar_Pervasives_Native_Some,
              .v = e_
            }
          );
        return true;
      }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static FStar_Pervasives_Native_option__uint32_t
try_advance_max(
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes hashes,
  Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps bitmaps,
  FStar_Pervasives_Native_option__uint32_t *max
)
{
  KRML_CHECK_SIZE(sizeof (bool), (uint32_t)1U);
  bool *r = KRML_HOST_MALLOC(sizeof (bool));
  r[0U] = true;
  while (r[0U])
  {
    bool b = try_increment_max(hashes, bitmaps, max);
    r[0U] = b;
  }
  KRML_HOST_FREE(r);
  return max[0U];
}

static void release_lock(Steel_ST_CancellableSpinLock_cancellable_lock lock)
{
  release0(lock);
}

static Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result
advance_and_read_max_certified_epoch(
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh
)
{
  bool b = acquire0(aeh.lock);
  bool b1 = !b;
  if (b1)
    return
      (
        (Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result){
          .tag = Zeta_Steel_AggregateEpochHashes_Read_max_error
        }
      );
  else
  {
    FStar_Pervasives_Native_option__uint32_t
    max = try_advance_max(aeh.hashes, aeh.tid_bitmaps, aeh.max_certified_epoch);
    if (max.tag == FStar_Pervasives_Native_None)
    {
      Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result
      r = { .tag = Zeta_Steel_AggregateEpochHashes_Read_max_none };
      release_lock(aeh.lock);
      return r;
    }
    else if (max.tag == FStar_Pervasives_Native_Some)
    {
      uint32_t max_v = max.v;
      release_lock(aeh.lock);
      return
        (
          (Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result){
            .tag = Zeta_Steel_AggregateEpochHashes_Read_max_some,
            ._0 = max_v
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

typedef struct __Zeta_Steel_LogEntry_Types_log_entry_uint32_t_s
{
  log_entry fst;
  uint32_t snd;
}
__Zeta_Steel_LogEntry_Types_log_entry_uint32_t;

typedef struct option__K___Zeta_Steel_LogEntry_Types_log_entry_uint32_t_s
{
  FStar_Pervasives_Native_option__Zeta_Steel_ApplicationTypes_value_type_tags tag;
  __Zeta_Steel_LogEntry_Types_log_entry_uint32_t v;
}
option__K___Zeta_Steel_LogEntry_Types_log_entry_uint32_t;

extern option__K___Zeta_Steel_LogEntry_Types_log_entry_uint32_t
zeta__parser_log_entry(uint32_t x0, uint32_t x1, uint32_t x2, uint8_t *x3);

extern uint32_t
zeta__serialize_stamped_record(uint32_t x0, uint32_t x1, uint8_t *x2, stamped_record x3);

extern uint32_t
zeta__serialize_value(
  uint32_t x0,
  uint32_t x1,
  uint8_t *x2,
  Zeta_Steel_LogEntry_Types_value x3
);

typedef struct __Zeta_Steel_LogEntry_Types_u256_uint32_t_s
{
  Zeta_Steel_LogEntry_Types_u256 fst;
  uint32_t snd;
}
__Zeta_Steel_LogEntry_Types_u256_uint32_t;

typedef struct option__K___Zeta_Steel_LogEntry_Types_u256_uint32_t_s
{
  FStar_Pervasives_Native_option__Zeta_Steel_ApplicationTypes_value_type_tags tag;
  __Zeta_Steel_LogEntry_Types_u256_uint32_t v;
}
option__K___Zeta_Steel_LogEntry_Types_u256_uint32_t;

extern option__K___Zeta_Steel_LogEntry_Types_u256_uint32_t
zeta__parser_u256(uint32_t x0, uint32_t x1, uint32_t x2, uint8_t *x3);

typedef struct Zeta_Steel_HashValue_hasher_t_s
{
  uint8_t *serialization_buffer;
  uint8_t *hash_buffer;
  uint8_t *dummy;
}
Zeta_Steel_HashValue_hasher_t;

static Zeta_Steel_HashValue_hasher_t alloc()
{
  uint8_t *hb = KRML_HOST_CALLOC((uint32_t)32U, sizeof (uint8_t));
  uint8_t *sb = KRML_HOST_CALLOC((uint32_t)4096U, sizeof (uint8_t));
  uint8_t *dummy = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint8_t));
  return
    (
      (Zeta_Steel_HashValue_hasher_t){
        .serialization_buffer = sb,
        .hash_buffer = hb,
        .dummy = dummy
      }
    );
}

static Zeta_Steel_LogEntry_Types_u256 read_hash_u256(uint8_t *hb)
{
  option__K___Zeta_Steel_LogEntry_Types_u256_uint32_t
  res = zeta__parser_u256((uint32_t)32U, (uint32_t)0U, (uint32_t)32U, hb);
  if (res.tag == FStar_Pervasives_Native_Some)
    return res.v.fst;
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Zeta_Steel_LogEntry_Types_u256
hash_value(Zeta_Steel_HashValue_hasher_t h, Zeta_Steel_LogEntry_Types_value v)
{
  uint32_t n = zeta__serialize_value((uint32_t)4096U, (uint32_t)0U, h.serialization_buffer, v);
  Hacl_Blake2b_32_blake2b((uint32_t)32U,
    h.hash_buffer,
    n,
    h.serialization_buffer,
    (uint32_t)0U,
    h.dummy);
  Zeta_Steel_LogEntry_Types_u256 res = read_hash_u256(h.hash_buffer);
  return res;
}

typedef struct Zeta_Steel_VerifierTypes_thread_state_t_s
{
  uint16_t thread_id;
  bool *failed;
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry *store;
  uint64_t *clock;
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes epoch_hashes;
  FStar_Pervasives_Native_option__uint32_t *last_verified_epoch;
  uint8_t *serialization_buffer;
  Zeta_Steel_HashValue_hasher_t hasher;
}
Zeta_Steel_VerifierTypes_thread_state_t;

static uint32_t as_u32(uint16_t s)
{
  return (uint32_t)s;
}

#define Run_app_parsing_failure 0
#define Run_app_verify_failure 1
#define Run_app_success 2

typedef uint8_t verify_runapp_result_tags;

typedef struct verify_runapp_result_s
{
  verify_runapp_result_tags tag;
  uint32_t wrote;
}
verify_runapp_result;

extern verify_runapp_result
Zeta_Steel_Application_run_app_function(
  runApp_payload pl,
  uint32_t pl_pos,
  uint8_t *log_array,
  uint32_t out_len,
  uint32_t out_offset,
  uint8_t *out,
  Zeta_Steel_VerifierTypes_thread_state_t t
);

extern Zeta_Steel_LogEntry_Types_base_key
Zeta_Steel_Application_key_type_to_base_key(Zeta_Steel_ApplicationTypes_key_type k);

typedef struct __uint32_t_uint32_t_s
{
  uint32_t fst;
  uint32_t snd;
}
__uint32_t_uint32_t;

static __uint32_t_uint32_t bit_offset_in_word(uint16_t i)
{
  if (i < (uint16_t)64U)
    return ((__uint32_t_uint32_t){ .fst = (uint32_t)0U, .snd = (uint32_t)i });
  else if (i < (uint16_t)128U)
    return ((__uint32_t_uint32_t){ .fst = (uint32_t)1U, .snd = (uint32_t)(i - (uint16_t)64U) });
  else if (i < (uint16_t)192U)
    return ((__uint32_t_uint32_t){ .fst = (uint32_t)2U, .snd = (uint32_t)(i - (uint16_t)128U) });
  else
    return ((__uint32_t_uint32_t){ .fst = (uint32_t)3U, .snd = (uint32_t)(i - (uint16_t)192U) });
}

static uint64_t truncate_word(uint64_t k, uint32_t index)
{
  if (index == (uint32_t)0U)
    return (uint64_t)0U;
  else
  {
    uint32_t shift_index = (uint32_t)64U - index;
    uint64_t mask = (uint64_t)0xffffffffffffffffU >> shift_index;
    return k & mask;
  }
}

static Zeta_Steel_LogEntry_Types_base_key
truncate_key(Zeta_Steel_LogEntry_Types_base_key k, uint16_t w)
{
  if (w == k.significant_digits)
    return k;
  else
  {
    __uint32_t_uint32_t scrut = bit_offset_in_word(w);
    uint32_t word = scrut.fst;
    uint32_t index = scrut.snd;
    Zeta_Steel_LogEntry_Types_u256 kk = k.k;
    Zeta_Steel_LogEntry_Types_u256 kk_;
    if (word == (uint32_t)0U)
      kk_ =
        (
          (Zeta_Steel_LogEntry_Types_u256){
            .v3 = (uint64_t)0U,
            .v2 = (uint64_t)0U,
            .v1 = (uint64_t)0U,
            .v0 = truncate_word(kk.v0, index)
          }
        );
    else if (word == (uint32_t)1U)
      kk_ =
        (
          (Zeta_Steel_LogEntry_Types_u256){
            .v3 = (uint64_t)0U,
            .v2 = (uint64_t)0U,
            .v1 = truncate_word(kk.v1, index),
            .v0 = kk.v0
          }
        );
    else if (word == (uint32_t)2U)
      kk_ =
        (
          (Zeta_Steel_LogEntry_Types_u256){
            .v3 = (uint64_t)0U,
            .v2 = truncate_word(kk.v2, index),
            .v1 = kk.v1,
            .v0 = kk.v0
          }
        );
    else
      kk_ =
        (
          (Zeta_Steel_LogEntry_Types_u256){
            .v3 = truncate_word(kk.v3, index),
            .v2 = kk.v2,
            .v1 = kk.v1,
            .v0 = kk.v0
          }
        );
    return ((Zeta_Steel_LogEntry_Types_base_key){ .k = kk_, .significant_digits = w });
  }
}

static bool
__eq__Zeta_Steel_LogEntry_Types_u256(
  Zeta_Steel_LogEntry_Types_u256 y,
  Zeta_Steel_LogEntry_Types_u256 x
)
{
  return true && x.v3 == y.v3 && x.v2 == y.v2 && x.v1 == y.v1 && x.v0 == y.v0;
}

static bool
__eq__Zeta_Steel_LogEntry_Types_base_key(
  Zeta_Steel_LogEntry_Types_base_key y,
  Zeta_Steel_LogEntry_Types_base_key x
)
{
  return
    true
    && __eq__Zeta_Steel_LogEntry_Types_u256(x.k, y.k)
    && x.significant_digits == y.significant_digits;
}

static bool
is_proper_descendent(
  Zeta_Steel_LogEntry_Types_base_key k0,
  Zeta_Steel_LogEntry_Types_base_key k1
)
{
  return
    k0.significant_digits
    > k1.significant_digits
    && __eq__Zeta_Steel_LogEntry_Types_base_key(truncate_key(k0, k1.significant_digits), k1);
}

static bool ith_bit_64(uint64_t x, uint32_t i)
{
  return (x >> i) % (uint64_t)2U == (uint64_t)1U;
}

static bool ith_bit(Zeta_Steel_LogEntry_Types_base_key k0, uint16_t i)
{
  Zeta_Steel_LogEntry_Types_u256 kk = k0.k;
  __uint32_t_uint32_t scrut = bit_offset_in_word(i);
  uint32_t word = scrut.fst;
  uint32_t bit = scrut.snd;
  if (word == (uint32_t)0U)
    return ith_bit_64(kk.v0, bit);
  else if (word == (uint32_t)1U)
    return ith_bit_64(kk.v1, bit);
  else if (word == (uint32_t)2U)
    return ith_bit_64(kk.v2, bit);
  else
    return ith_bit_64(kk.v3, bit);
}

static bool
desc_dir(Zeta_Steel_LogEntry_Types_base_key k0, Zeta_Steel_LogEntry_Types_base_key k1)
{
  return !ith_bit(k0, k1.significant_digits);
}

extern uint32_t zeta__runapp_payload_offset(log_entry e);

static uint32_t as_u320(uint16_t s)
{
  return (uint32_t)s;
}

static void fail(Zeta_Steel_VerifierTypes_thread_state_t t)
{
  t.failed[0U] = true;
}

static bool fail_as(Zeta_Steel_VerifierTypes_thread_state_t t)
{
  t.failed[0U] = true;
  return true;
}

static Zeta_Steel_LogEntry_Types_base_key to_base_key(Zeta_Steel_LogEntry_Types_key x)
{
  if (x.tag == Zeta_Steel_LogEntry_Types_InternalKey)
    return x.case_InternalKey;
  else if (x.tag == Zeta_Steel_LogEntry_Types_ApplicationKey)
  {
    Zeta_Steel_ApplicationTypes_key_type k = x.case_ApplicationKey;
    Zeta_Steel_LogEntry_Types_base_key k_ = Zeta_Steel_Application_key_type_to_base_key(k);
    return k_;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool check_failed(Zeta_Steel_VerifierTypes_thread_state_t t)
{
  return t.failed[0U];
}

static void
madd_to_store_split(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t s,
  Zeta_Steel_LogEntry_Types_key k,
  Zeta_Steel_LogEntry_Types_value v,
  uint16_t s_,
  bool d,
  bool d2
)
{
  bool b = is_value_of(k, v);
  if (!b)
    fail(t);
  else
  {
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    ropt = t.store[as_u320(s)];
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    ropt_ = t.store[as_u320(s_)];
    if (ropt.tag == FStar_Pervasives_Native_Some)
      fail(t);
    else if (ropt_.tag == FStar_Pervasives_Native_None)
      fail(t);
    else if (ropt_.tag == FStar_Pervasives_Native_Some)
    {
      Zeta_Steel_ThreadStateModel_store_entry r_ = ropt_.v;
      K___uint16_t_bool p = { .fst = s_, .snd = d };
      FStar_Pervasives_Native_option__uint16_t s2_opt = child_slot(r_, d);
      if (s2_opt.tag == FStar_Pervasives_Native_None)
        fail(t);
      else if (s2_opt.tag == FStar_Pervasives_Native_Some)
      {
        uint16_t s2 = s2_opt.v;
        FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
        r2opt = t.store[as_u320(s2)];
        if (r2opt.tag == FStar_Pervasives_Native_None)
          fail(t);
        else if (r2opt.tag == FStar_Pervasives_Native_Some)
        {
          Zeta_Steel_ThreadStateModel_store_entry r2 = r2opt.v;
          Zeta_Steel_ThreadStateModel_store_entry
          e =
            mk_entry_full(k,
              v,
              Zeta_Steel_ThreadStateModel_MAdd,
              ((FStar_Pervasives_Native_option__uint16_t){ .tag = FStar_Pervasives_Native_None }),
              ((FStar_Pervasives_Native_option__uint16_t){ .tag = FStar_Pervasives_Native_None }),
              (
                (FStar_Pervasives_Native_option__K___uint16_t_bool){
                  .tag = FStar_Pervasives_Native_Some,
                  .v = p
                }
              ));
          Zeta_Steel_ThreadStateModel_store_entry e1 = update_child(e, d2, s2);
          Zeta_Steel_ThreadStateModel_store_entry e_ = update_child(r_, d, s);
          K___uint16_t_bool p2new = { .fst = s, .snd = d2 };
          Zeta_Steel_ThreadStateModel_store_entry e2 = update_parent_slot(r2, p2new);
          t.store[as_u320(s)] =
            (
              (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
                .tag = FStar_Pervasives_Native_Some,
                .v = e1
              }
            );
          t.store[as_u320(s_)] =
            (
              (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
                .tag = FStar_Pervasives_Native_Some,
                .v = e_
              }
            );
          t.store[as_u320(s2)] =
            (
              (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
                .tag = FStar_Pervasives_Native_Some,
                .v = e2
              }
            );
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static void
madd_to_store(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t s,
  Zeta_Steel_LogEntry_Types_key k,
  Zeta_Steel_LogEntry_Types_value v,
  uint16_t s_,
  bool d
)
{
  bool b = is_value_of(k, v);
  if (!b)
    fail(t);
  else
  {
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    ropt = t.store[as_u320(s)];
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    ropt_ = t.store[as_u320(s_)];
    if (ropt.tag == FStar_Pervasives_Native_Some)
      fail(t);
    else if (ropt_.tag == FStar_Pervasives_Native_None)
      fail(t);
    else if (ropt_.tag == FStar_Pervasives_Native_Some)
    {
      Zeta_Steel_ThreadStateModel_store_entry r_ = ropt_.v;
      Zeta_Steel_ThreadStateModel_store_entry
      new_entry =
        {
          .key = k, .value = v, .add_method = Zeta_Steel_ThreadStateModel_MAdd,
          .l_child_in_store = { .tag = FStar_Pervasives_Native_None },
          .r_child_in_store = { .tag = FStar_Pervasives_Native_None },
          .parent_slot = { .tag = FStar_Pervasives_Native_Some, .v = { .fst = s_, .snd = d } }
        };
      t.store[as_u320(s)] =
        (
          (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
            .tag = FStar_Pervasives_Native_Some,
            .v = new_entry
          }
        );
      Zeta_Steel_ThreadStateModel_store_entry r_1;
      if (d)
        r_1 =
          (
            (Zeta_Steel_ThreadStateModel_store_entry){
              .key = r_.key,
              .value = r_.value,
              .add_method = r_.add_method,
              .l_child_in_store = { .tag = FStar_Pervasives_Native_Some, .v = s },
              .r_child_in_store = r_.r_child_in_store,
              .parent_slot = r_.parent_slot
            }
          );
      else
        r_1 =
          (
            (Zeta_Steel_ThreadStateModel_store_entry){
              .key = r_.key,
              .value = r_.value,
              .add_method = r_.add_method,
              .l_child_in_store = r_.l_child_in_store,
              .r_child_in_store = { .tag = FStar_Pervasives_Native_Some, .v = s },
              .parent_slot = r_.parent_slot
            }
          );
      t.store[as_u320(s_)] =
        (
          (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
            .tag = FStar_Pervasives_Native_Some,
            .v = r_1
          }
        );
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static bool uu___is_Some__uint16_t(FStar_Pervasives_Native_option__uint16_t projectee)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static bool entry_points_to_some_slot(Zeta_Steel_ThreadStateModel_store_entry r, bool d)
{
  if (d)
    return uu___is_Some__uint16_t(r.l_child_in_store);
  else
    return uu___is_Some__uint16_t(r.r_child_in_store);
}

static void
update_value(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t s,
  Zeta_Steel_LogEntry_Types_value r
)
{
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
  scrut = t.store[as_u320(s)];
  if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    Zeta_Steel_ThreadStateModel_store_entry v = scrut.v;
    t.store[as_u320(s)] =
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
          .tag = FStar_Pervasives_Native_Some,
          .v = {
            .key = v.key, .value = r, .add_method = v.add_method,
            .l_child_in_store = v.l_child_in_store, .r_child_in_store = v.r_child_in_store,
            .parent_slot = v.parent_slot
          }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

extern bool
Zeta_Steel_VerifierSteps_eq_value(
  Zeta_Steel_LogEntry_Types_value v0,
  Zeta_Steel_LogEntry_Types_value v1
);

static bool
vaddm_core(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint16_t s_, record r)
{
  bool b = !check_slot_bounds(s) || !check_slot_bounds(s_);
  if (b)
  {
    fail(t);
    return true;
  }
  else
  {
    Zeta_Steel_LogEntry_Types_key gk = r.fst;
    Zeta_Steel_LogEntry_Types_value gv = r.snd;
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    ropt = t.store[as_u320(s_)];
    if (ropt.tag == FStar_Pervasives_Native_None)
    {
      fail(t);
      return true;
    }
    else if (ropt.tag == FStar_Pervasives_Native_Some)
    {
      Zeta_Steel_ThreadStateModel_store_entry r_ = ropt.v;
      Zeta_Steel_LogEntry_Types_base_key k_ = to_base_key(r_.key);
      Zeta_Steel_LogEntry_Types_value v_ = r_.value;
      Zeta_Steel_LogEntry_Types_base_key k = to_base_key(gk);
      if (!is_proper_descendent(k, k_))
      {
        fail(t);
        return true;
      }
      else
      {
        FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
        sopt = t.store[as_u320(s)];
        if (sopt.tag == FStar_Pervasives_Native_Some)
        {
          fail(t);
          return true;
        }
        else
        {
          option__Zeta_Steel_LogEntry_Types_mval_value scrut0 = to_merkle_value(v_);
          if (scrut0.tag == FStar_Pervasives_Native_None)
          {
            fail(t);
            return true;
          }
          else if (scrut0.tag == FStar_Pervasives_Native_Some)
          {
            Zeta_Steel_LogEntry_Types_mval_value v_1 = scrut0.v;
            bool d = desc_dir(k, k_);
            Zeta_Steel_LogEntry_Types_descendent_hash dh_ = desc_hash_dir(v_1, d);
            Zeta_Steel_LogEntry_Types_u256 h = hash_value(t.hasher, gv);
            if (dh_.tag == Zeta_Steel_LogEntry_Types_Dh_vnone)
              if (!Zeta_Steel_VerifierSteps_eq_value(gv, init_value(gk)))
              {
                bool b1 = fail_as(t);
                return b1;
              }
              else if (entry_points_to_some_slot(r_, d))
              {
                bool b1 = fail_as(t);
                return b1;
              }
              else
              {
                madd_to_store(t, s, gk, gv, s_, d);
                Zeta_Steel_LogEntry_Types_mval_value
                v__upd = update_merkle_value(v_1, d, k, Zeta_Steel_ThreadStateModel_zero, false);
                update_value(t,
                  s_,
                  (
                    (Zeta_Steel_LogEntry_Types_value){
                      .tag = Zeta_Steel_LogEntry_Types_MValue,
                      { .case_MValue = v__upd }
                    }
                  ));
                return true;
              }
            else if (dh_.tag == Zeta_Steel_LogEntry_Types_Dh_vsome)
            {
              Zeta_Steel_LogEntry_Types_vbool b2 = dh_._0.evicted_to_blum;
              Zeta_Steel_LogEntry_Types_u256 h2 = dh_._0.dhd_h;
              Zeta_Steel_LogEntry_Types_base_key k2 = dh_._0.dhd_key;
              if (__eq__Zeta_Steel_LogEntry_Types_base_key(k2, k))
                if
                (
                  !(__eq__Zeta_Steel_LogEntry_Types_u256(h2,
                    h)
                  && b2 == Zeta_Steel_LogEntry_Types_Vfalse)
                )
                {
                  bool b1 = fail_as(t);
                  return b1;
                }
                else if (entry_points_to_some_slot(r_, d))
                {
                  bool b1 = fail_as(t);
                  return b1;
                }
                else
                {
                  madd_to_store(t, s, gk, gv, s_, d);
                  return true;
                }
              else if (!Zeta_Steel_VerifierSteps_eq_value(gv, init_value(gk)))
              {
                bool b1 = fail_as(t);
                return b1;
              }
              else if (!is_proper_descendent(k2, k))
              {
                bool b1 = fail_as(t);
                return b1;
              }
              else
              {
                bool d2 = desc_dir(k2, k);
                option__Zeta_Steel_LogEntry_Types_mval_value scrut = to_merkle_value(gv);
                if (scrut.tag == FStar_Pervasives_Native_Some)
                {
                  Zeta_Steel_LogEntry_Types_mval_value mv = scrut.v;
                  Zeta_Steel_LogEntry_Types_mval_value
                  mv_upd =
                    update_merkle_value(mv,
                      d2,
                      k2,
                      h2,
                      b2 == Zeta_Steel_LogEntry_Types_Vtrue);
                  Zeta_Steel_LogEntry_Types_mval_value
                  v__upd = update_merkle_value(v_1, d, k, Zeta_Steel_ThreadStateModel_zero, false);
                  bool b1 = entry_points_to_some_slot(r_, d);
                  if (b1)
                  {
                    madd_to_store_split(t,
                      s,
                      gk,
                      (
                        (Zeta_Steel_LogEntry_Types_value){
                          .tag = Zeta_Steel_LogEntry_Types_MValue,
                          { .case_MValue = mv_upd }
                        }
                      ),
                      s_,
                      d,
                      d2);
                    update_value(t,
                      s_,
                      (
                        (Zeta_Steel_LogEntry_Types_value){
                          .tag = Zeta_Steel_LogEntry_Types_MValue,
                          { .case_MValue = v__upd }
                        }
                      ));
                    return true;
                  }
                  else
                  {
                    madd_to_store(t,
                      s,
                      gk,
                      (
                        (Zeta_Steel_LogEntry_Types_value){
                          .tag = Zeta_Steel_LogEntry_Types_MValue,
                          { .case_MValue = mv_upd }
                        }
                      ),
                      s_,
                      d);
                    update_value(t,
                      s_,
                      (
                        (Zeta_Steel_LogEntry_Types_value){
                          .tag = Zeta_Steel_LogEntry_Types_MValue,
                          { .case_MValue = v__upd }
                        }
                      ));
                    return true;
                  }
                }
                else
                {
                  KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
                    __FILE__,
                    __LINE__,
                    "unreachable (pattern matches are exhaustive in F*)");
                  KRML_HOST_EXIT(255U);
                }
              }
            }
            else
            {
              KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static bool vaddm(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint16_t s_, record r)
{
  bool b = vaddm_core(t, s, s_, r);
  return b;
}

static option__uint64_t next(uint64_t t)
{
  return check_overflow_add(t, (uint64_t)1U);
}

static uint64_t max(uint64_t t0, uint64_t t1)
{
  if (t0 >= t1)
    return t0;
  else
    return t1;
}

#define HAdd 0
#define HEvict 1

typedef uint8_t htype;

static bool ha_add(Zeta_Steel_HashAccumulator_ha ha, uint32_t l, uint8_t *input)
{
  bool x = add(ha, input, l);
  return x;
}

static bool
update_ht(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint32_t e,
  record r,
  uint64_t ts,
  uint16_t thread_id,
  htype ht
)
{
  get_result__Zeta_Steel_EpochHashes_epoch_hashes_t
  vopt = get__Zeta_Steel_EpochHashes_epoch_hashes_t(t.epoch_hashes, e);
  if (vopt.tag == NotFound)
    return false;
  else if (vopt.tag == Fresh)
    return false;
  else if (vopt.tag == Found)
  {
    Zeta_Steel_EpochHashes_epoch_hashes_t v = vopt._0;
    stamped_record sr = { .record = r, .timestamp = ts, .thread_id = thread_id };
    uint32_t
    n = zeta__serialize_stamped_record((uint32_t)4096U, (uint32_t)0U, t.serialization_buffer, sr);
    Zeta_Steel_HashAccumulator_ha ha;
    if (ht == HAdd)
      ha = v.hadd;
    else
      ha = v.hevict;
    switch (ht)
    {
      case HAdd:
        {
          bool b = ha_add(v.hadd, n, t.serialization_buffer);
          return b;
        }
      case HEvict:
        {
          bool b = ha_add(v.hevict, n, t.serialization_buffer);
          return b;
        }
      default:
        {
          KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
          KRML_HOST_EXIT(253U);
        }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
uu___is_Some__Zeta_Steel_ThreadStateModel_store_entry(
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry projectee
)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static bool
vaddb_core(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t s,
  uint64_t ts,
  uint16_t thread_id,
  record r
)
{
  bool b = check_slot_bounds(s);
  if (!b)
  {
    fail(t);
    return true;
  }
  else
  {
    Zeta_Steel_LogEntry_Types_key k = r.fst;
    Zeta_Steel_LogEntry_Types_value v = r.snd;
    if (is_root_key(k))
    {
      fail(t);
      return true;
    }
    else
    {
      FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
      ropt = t.store[as_u320(s)];
      if (uu___is_Some__Zeta_Steel_ThreadStateModel_store_entry(ropt))
      {
        fail(t);
        return true;
      }
      else
      {
        FStar_Pervasives_Native_option__uint32_t lve = t.last_verified_epoch[0U];
        if (!epoch_greater_than_last_verified_epoch(lve, epoch_of_timestamp(ts)))
        {
          fail(t);
          return true;
        }
        else
        {
          bool ok = update_ht(t, epoch_of_timestamp(ts), r, ts, thread_id, HAdd);
          if (ok)
          {
            option__uint64_t ts_opt = next(ts);
            if (ts_opt.tag == FStar_Pervasives_Native_None)
            {
              fail(t);
              return true;
            }
            else if (ts_opt.tag == FStar_Pervasives_Native_Some)
            {
              uint64_t t_ = ts_opt.v;
              uint64_t clock = t.clock[0U];
              uint64_t next_clock = max(clock, t_);
              t.clock[0U] = next_clock;
              t.store[as_u320(s)] =
                (
                  (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
                    .tag = FStar_Pervasives_Native_Some,
                    .v = mk_entry(k, v, Zeta_Steel_ThreadStateModel_BAdd)
                  }
                );
              return true;
            }
            else
            {
              KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
          else
            return ok;
        }
      }
    }
  }
}

static bool
vaddb(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t s,
  uint64_t ts,
  uint16_t thread_id,
  record r
)
{
  bool b = vaddb_core(t, s, ts, thread_id, r);
  return b;
}

extern bool
Zeta_Steel_VerifierSteps_eq_base_key(
  Zeta_Steel_LogEntry_Types_base_key k0,
  Zeta_Steel_LogEntry_Types_base_key k1
);

static void
evict_from_store(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint16_t s_, bool d)
{
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
  scrut = t.store[as_u320(s_)];
  if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    Zeta_Steel_ThreadStateModel_store_entry r_ = scrut.v;
    Zeta_Steel_ThreadStateModel_store_entry e_;
    if (d)
      e_ =
        (
          (Zeta_Steel_ThreadStateModel_store_entry){
            .key = r_.key,
            .value = r_.value,
            .add_method = r_.add_method,
            .l_child_in_store = { .tag = FStar_Pervasives_Native_None },
            .r_child_in_store = r_.r_child_in_store,
            .parent_slot = r_.parent_slot
          }
        );
    else
      e_ =
        (
          (Zeta_Steel_ThreadStateModel_store_entry){
            .key = r_.key,
            .value = r_.value,
            .add_method = r_.add_method,
            .l_child_in_store = r_.l_child_in_store,
            .r_child_in_store = { .tag = FStar_Pervasives_Native_None },
            .parent_slot = r_.parent_slot
          }
        );
    t.store[as_u320(s_)] =
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
          .tag = FStar_Pervasives_Native_Some,
          .v = e_
        }
      );
    t.store[as_u320(s)] =
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
          .tag = FStar_Pervasives_Native_None
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
uu___is_Some__uint16_t___bool(FStar_Pervasives_Native_option__K___uint16_t_bool projectee)
{
  if (projectee.tag == FStar_Pervasives_Native_Some)
    return true;
  else
    return false;
}

static uint16_t fst__uint16_t_bool(K___uint16_t_bool x)
{
  return x.fst;
}

static bool snd__uint16_t_bool(K___uint16_t_bool x)
{
  return x.snd;
}

typedef struct
__FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry_FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry_s
{
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry fst;
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry snd;
}
__FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry_FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry;

static void vevictm_core(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint16_t s_)
{
  if (!check_slot_bounds(s) || !check_slot_bounds(s_))
    t.failed[0U] = true;
  else if (s == s_)
    t.failed[0U] = true;
  else
  {
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    e = t.store[as_u320(s)];
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    e_ = t.store[as_u320(s_)];
    __FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry_FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    scrut0 = { .fst = e, .snd = e_ };
    if (scrut0.fst.tag == FStar_Pervasives_Native_None)
      t.failed[0U] = true;
    else if (scrut0.snd.tag == FStar_Pervasives_Native_None)
      t.failed[0U] = true;
    else if
    (
      scrut0.fst.tag
      == FStar_Pervasives_Native_Some
      && scrut0.snd.tag == FStar_Pervasives_Native_Some
    )
    {
      Zeta_Steel_ThreadStateModel_store_entry r_ = scrut0.snd.v;
      Zeta_Steel_ThreadStateModel_store_entry r = scrut0.fst.v;
      Zeta_Steel_LogEntry_Types_key gk = r.key;
      Zeta_Steel_LogEntry_Types_value v = r.value;
      Zeta_Steel_LogEntry_Types_key gk_ = r_.key;
      Zeta_Steel_LogEntry_Types_value v_ = r_.value;
      Zeta_Steel_LogEntry_Types_base_key k = to_base_key(gk);
      Zeta_Steel_LogEntry_Types_base_key k_ = to_base_key(gk_);
      if (!is_proper_descendent(k, k_))
        t.failed[0U] = true;
      else if (entry_points_to_some_slot(r, true) || entry_points_to_some_slot(r, false))
        t.failed[0U] = true;
      else
      {
        bool d = desc_dir(k, k_);
        option__Zeta_Steel_LogEntry_Types_mval_value scrut = to_merkle_value(v_);
        if (scrut.tag == FStar_Pervasives_Native_Some)
        {
          Zeta_Steel_LogEntry_Types_mval_value v_1 = scrut.v;
          Zeta_Steel_LogEntry_Types_descendent_hash dh_ = desc_hash_dir(v_1, d);
          Zeta_Steel_LogEntry_Types_u256 h = hash_value(t.hasher, v);
          if (dh_.tag == Zeta_Steel_LogEntry_Types_Dh_vnone)
            fail(t);
          else if (dh_.tag == Zeta_Steel_LogEntry_Types_Dh_vsome)
          {
            Zeta_Steel_LogEntry_Types_base_key k2 = dh_._0.dhd_key;
            if (!Zeta_Steel_VerifierSteps_eq_base_key(k2, k))
              fail(t);
            else
            {
              bool has_parent_slot = uu___is_Some__uint16_t___bool(r.parent_slot);
              if (has_parent_slot)
              {
                K___uint16_t_bool p_slot;
                if (r.parent_slot.tag == FStar_Pervasives_Native_Some)
                  p_slot = r.parent_slot.v;
                else
                  p_slot =
                    KRML_EABORT(K___uint16_t_bool,
                      "unreachable (pattern matches are exhaustive in F*)");
                bool b1 = fst__uint16_t_bool(p_slot) != s_;
                bool b21 = snd__uint16_t_bool(p_slot) != d;
                if (b1 || b21)
                  fail(t);
                else
                {
                  Zeta_Steel_LogEntry_Types_mval_value
                  v__upd = update_merkle_value(v_1, d, k, h, false);
                  update_value(t,
                    s_,
                    (
                      (Zeta_Steel_LogEntry_Types_value){
                        .tag = Zeta_Steel_LogEntry_Types_MValue,
                        { .case_MValue = v__upd }
                      }
                    ));
                  evict_from_store(t, s, s_, d);
                }
              }
              else
              {
                bool b = entry_points_to_some_slot(r_, d);
                if (b)
                  fail(t);
                else
                {
                  Zeta_Steel_LogEntry_Types_mval_value
                  v__upd = update_merkle_value(v_1, d, k, h, false);
                  update_value(t,
                    s_,
                    (
                      (Zeta_Steel_LogEntry_Types_value){
                        .tag = Zeta_Steel_LogEntry_Types_MValue,
                        { .case_MValue = v__upd }
                      }
                    ));
                  evict_from_store(t, s, s_, d);
                }
              }
            }
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
              __FILE__,
              __LINE__,
              "unreachable (pattern matches are exhaustive in F*)");
            KRML_HOST_EXIT(255U);
          }
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
}

static void vevictm(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint16_t s_)
{
  vevictm_core(t, s, s_);
}

static bool
sat_evictb_checks(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint64_t ts)
{
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
  ropt = t.store[as_u320(s)];
  if (ropt.tag == FStar_Pervasives_Native_None)
    return false;
  else if (ropt.tag == FStar_Pervasives_Native_Some)
  {
    Zeta_Steel_ThreadStateModel_store_entry r = ropt.v;
    Zeta_Steel_LogEntry_Types_key k = r.key;
    uint64_t clock = t.clock[0U];
    bool
    b =
      !is_root_key(k)
      && timestamp_lt(clock, ts)
      && !entry_points_to_some_slot(r, true)
      && !entry_points_to_some_slot(r, false);
    return b;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
vevictb_update_hash_clock(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint64_t ts)
{
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
  scrut = t.store[as_u320(s)];
  if (scrut.tag == FStar_Pervasives_Native_Some)
  {
    Zeta_Steel_ThreadStateModel_store_entry r = scrut.v;
    Zeta_Steel_LogEntry_Types_key k = r.key;
    Zeta_Steel_LogEntry_Types_value v = r.value;
    uint32_t e = epoch_of_timestamp(ts);
    bool b = update_ht(t, e, ((record){ .fst = k, .snd = v }), ts, t.thread_id, HEvict);
    if (b)
    {
      t.clock[0U] = ts;
      return b;
    }
    else
      return b;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool vevictb_core(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint64_t ts)
{
  bool bounds_failed = !check_slot_bounds(s);
  if (bounds_failed)
  {
    t.failed[0U] = true;
    return true;
  }
  else
  {
    bool b = sat_evictb_checks(t, s, ts);
    if (!b)
    {
      fail(t);
      return true;
    }
    else
    {
      FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
      scrut = t.store[as_u320(s)];
      if (scrut.tag == FStar_Pervasives_Native_Some)
      {
        Zeta_Steel_ThreadStateModel_store_entry r = scrut.v;
        if (r.add_method != Zeta_Steel_ThreadStateModel_BAdd)
        {
          fail(t);
          return true;
        }
        else
        {
          bool b1 = vevictb_update_hash_clock(t, s, ts);
          if (b1)
          {
            t.store[as_u320(s)] =
              (
                (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
                  .tag = FStar_Pervasives_Native_None
                }
              );
            return true;
          }
          else
            return false;
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  }
}

static bool vevictb(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint64_t ts)
{
  bool b = vevictb_core(t, s, ts);
  return b;
}

static bool
uu___is_None__uint16_t___bool(FStar_Pervasives_Native_option__K___uint16_t_bool projectee)
{
  if (projectee.tag == FStar_Pervasives_Native_None)
    return true;
  else
    return false;
}

static bool
vevictbm_core(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint16_t s_, uint64_t ts)
{
  bool bounds_failed = !check_slot_bounds(s) || !check_slot_bounds(s_);
  if (bounds_failed)
    return fail_as(t);
  else if (s == s_)
    return fail_as(t);
  else
  {
    bool se_checks = sat_evictb_checks(t, s, ts);
    if (!se_checks)
      return fail_as(t);
    else
    {
      FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
      ropt = t.store[as_u320(s_)];
      if (ropt.tag == FStar_Pervasives_Native_None)
        return fail_as(t);
      else if (ropt.tag == FStar_Pervasives_Native_Some)
      {
        Zeta_Steel_ThreadStateModel_store_entry r_ = ropt.v;
        FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
        scrut0 = t.store[as_u320(s)];
        if (scrut0.tag == FStar_Pervasives_Native_Some)
        {
          Zeta_Steel_ThreadStateModel_store_entry r = scrut0.v;
          if (r.add_method != Zeta_Steel_ThreadStateModel_MAdd)
          {
            bool b = fail_as(t);
            return b;
          }
          else
          {
            Zeta_Steel_LogEntry_Types_key gk = r.key;
            Zeta_Steel_LogEntry_Types_key gk_ = r_.key;
            Zeta_Steel_LogEntry_Types_value v_ = r_.value;
            Zeta_Steel_LogEntry_Types_base_key k = to_base_key(gk);
            Zeta_Steel_LogEntry_Types_base_key k_ = to_base_key(gk_);
            if (!is_proper_descendent(k, k_))
            {
              bool b = fail_as(t);
              return b;
            }
            else
            {
              option__Zeta_Steel_LogEntry_Types_mval_value scrut = to_merkle_value(v_);
              if (scrut.tag == FStar_Pervasives_Native_Some)
              {
                Zeta_Steel_LogEntry_Types_mval_value mv_ = scrut.v;
                bool d = desc_dir(k, k_);
                Zeta_Steel_LogEntry_Types_descendent_hash dh_ = desc_hash_dir(mv_, d);
                if (dh_.tag == Zeta_Steel_LogEntry_Types_Dh_vnone)
                {
                  bool b = fail_as(t);
                  return b;
                }
                else if (dh_.tag == Zeta_Steel_LogEntry_Types_Dh_vsome)
                {
                  Zeta_Steel_LogEntry_Types_vbool b2 = dh_._0.evicted_to_blum;
                  Zeta_Steel_LogEntry_Types_u256 h2 = dh_._0.dhd_h;
                  Zeta_Steel_LogEntry_Types_base_key k2 = dh_._0.dhd_key;
                  if
                  (
                    !Zeta_Steel_VerifierSteps_eq_base_key(k2,
                      k)
                    || b2 == Zeta_Steel_LogEntry_Types_Vtrue
                  )
                  {
                    bool b = fail_as(t);
                    return b;
                  }
                  else
                  {
                    bool parent_slot_none = uu___is_None__uint16_t___bool(r.parent_slot);
                    if (parent_slot_none)
                    {
                      bool b = fail_as(t);
                      return b;
                    }
                    else
                    {
                      K___uint16_t_bool parent_slot;
                      if (r.parent_slot.tag == FStar_Pervasives_Native_Some)
                        parent_slot = r.parent_slot.v;
                      else
                        parent_slot =
                          KRML_EABORT(K___uint16_t_bool,
                            "unreachable (pattern matches are exhaustive in F*)");
                      bool b1 = fst__uint16_t_bool(parent_slot) != s_;
                      bool b21 = snd__uint16_t_bool(parent_slot) != d;
                      if (b1 || b21)
                      {
                        bool b = fail_as(t);
                        return b;
                      }
                      else
                      {
                        bool b = vevictb_update_hash_clock(t, s, ts);
                        if (b)
                        {
                          Zeta_Steel_LogEntry_Types_mval_value
                          mv__upd = update_merkle_value(mv_, d, k, h2, true);
                          update_value(t,
                            s_,
                            (
                              (Zeta_Steel_LogEntry_Types_value){
                                .tag = Zeta_Steel_LogEntry_Types_MValue,
                                { .case_MValue = mv__upd }
                              }
                            ));
                          evict_from_store(t, s, s_, d);
                          return true;
                        }
                        else
                          return false;
                      }
                    }
                  }
                }
                else
                {
                  KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
                    __FILE__,
                    __LINE__,
                    "unreachable (pattern matches are exhaustive in F*)");
                  KRML_HOST_EXIT(255U);
                }
              }
              else
              {
                KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
                  __FILE__,
                  __LINE__,
                  "unreachable (pattern matches are exhaustive in F*)");
                KRML_HOST_EXIT(255U);
              }
            }
          }
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  }
}

static bool
vevictbm(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t s, uint16_t s_, uint64_t ts)
{
  bool b = vevictbm_core(t, s, s_, ts);
  return b;
}

static Zeta_Steel_EpochHashes_epoch_hashes_t new_epoch(uint32_t e)
{
  Zeta_Steel_HashAccumulator_ha hadd = create();
  Zeta_Steel_HashAccumulator_ha hev = create();
  return ((Zeta_Steel_EpochHashes_epoch_hashes_t){ .hadd = hadd, .hevict = hev });
}

static void
put__Zeta_Steel_EpochHashes_epoch_hashes_t(
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes a,
  uint32_t i,
  Zeta_Steel_EpochHashes_epoch_hashes_t x
)
{
  uint32_t idx = i % a.etbl.store_len;
  a.etbl.store[idx] =
    (
      (FStar_Pervasives_Native_option__K___uint32_t_Zeta_Steel_EpochHashes_epoch_hashes_t){
        .tag = FStar_Pervasives_Native_Some,
        .v = { .fst = i, .snd = x }
      }
    );
  uint32_t high = a.high[0U];
  bool r = high < i;
  if (r)
    a.high[0U] = i;
}

static void
epoch_map_add__Zeta_Steel_EpochHashes_epoch_hashes_t(
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes a,
  uint32_t i,
  Zeta_Steel_EpochHashes_epoch_hashes_t x
)
{
  put__Zeta_Steel_EpochHashes_epoch_hashes_t(a, i, x);
}

static void nextepoch_core(Zeta_Steel_VerifierTypes_thread_state_t t)
{
  uint64_t c = t.clock[0U];
  uint32_t e = epoch_of_timestamp(c);
  FStar_Pervasives_Native_option__uint32_t res = st_check_overflow_add32(e, (uint32_t)1U);
  if (res.tag == FStar_Pervasives_Native_None)
    fail(t);
  else if (res.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t nxt = res.v;
    uint64_t c1 = (uint64_t)nxt << (uint32_t)32U;
    t.clock[0U] = c1;
    Zeta_Steel_EpochHashes_epoch_hashes_t eht = new_epoch(epoch_of_timestamp(c1));
    epoch_map_add__Zeta_Steel_EpochHashes_epoch_hashes_t(t.epoch_hashes,
      epoch_of_timestamp(c1),
      eht);
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static void nextepoch(Zeta_Steel_VerifierTypes_thread_state_t t)
{
  nextepoch_core(t);
}

static bool
aggregate_epoch_hashes_t(
  Zeta_Steel_EpochHashes_epoch_hashes_t src,
  Zeta_Steel_EpochHashes_epoch_hashes_t dst
)
{
  bool b = aggregate(dst.hadd, src.hadd);
  if (b)
  {
    bool b1 = aggregate(dst.hevict, src.hevict);
    if (b1)
      return true;
    else
      return false;
  }
  else
    return false;
}

static bool
propagate_epoch_hash(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes hashes,
  uint32_t e
)
{
  get_result__Zeta_Steel_EpochHashes_epoch_hashes_t
  dst = get__Zeta_Steel_EpochHashes_epoch_hashes_t(hashes, e);
  if (dst.tag == NotFound)
    return false;
  else if (dst.tag == Fresh)
  {
    Zeta_Steel_EpochHashes_epoch_hashes_t eh = new_epoch(e);
    epoch_map_add__Zeta_Steel_EpochHashes_epoch_hashes_t(hashes, e, eh);
    bool b = propagate_epoch_hash(t, hashes, e);
    if (b)
      return true;
    else
      return false;
  }
  else if (dst.tag == Found)
  {
    Zeta_Steel_EpochHashes_epoch_hashes_t dst1 = dst._0;
    get_result__Zeta_Steel_EpochHashes_epoch_hashes_t
    src = get__Zeta_Steel_EpochHashes_epoch_hashes_t(t.epoch_hashes, e);
    if (src.tag == NotFound)
      return false;
    else if (src.tag == Fresh)
      return false;
    else if (src.tag == Found)
    {
      Zeta_Steel_EpochHashes_epoch_hashes_t src1 = src._0;
      bool b = aggregate_epoch_hashes_t(src1, dst1);
      if (b)
        return true;
      else
        return false;
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static void
put___bool_(Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps a, uint32_t i, bool *x)
{
  uint32_t idx = i % a.etbl.store_len;
  a.etbl.store[idx] =
    (
      (FStar_Pervasives_Native_option__K___uint32_t__bool_){
        .tag = FStar_Pervasives_Native_Some,
        .v = { .fst = i, .snd = x }
      }
    );
  uint32_t high = a.high[0U];
  bool r = high < i;
  if (r)
    a.high[0U] = i;
}

static bool
update_bitmap(
  Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps tid_bitmaps,
  uint32_t e,
  uint16_t tid
)
{
  get_result___bool_ res = get___bool_(tid_bitmaps, e);
  if (res.tag == NotFound)
    return false;
  else if (res.tag == Fresh)
  {
    KRML_CHECK_SIZE(sizeof (bool), Zeta_Steel_ApplicationTypes_n_threads);
    bool *new_bm = KRML_HOST_MALLOC(sizeof (bool) * Zeta_Steel_ApplicationTypes_n_threads);
    for (uint32_t _i = 0U; _i < Zeta_Steel_ApplicationTypes_n_threads; ++_i)
      new_bm[_i] = false;
    new_bm[as_u320(tid)] = true;
    put___bool_(tid_bitmaps, e, new_bm);
    return true;
  }
  else if (res.tag == Found)
  {
    bool *v = res._0;
    v[as_u320(tid)] = true;
    return true;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
verify_epoch_core(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes hashes,
  Zeta_Steel_AggregateEpochHashes_epoch_tid_bitmaps tid_bitmaps,
  Steel_ST_CancellableSpinLock_cancellable_lock lock
)
{
  FStar_Pervasives_Native_option__uint32_t e = t.last_verified_epoch[0U];
  FStar_Pervasives_Native_option__uint32_t e_ = maybe_increment_last_verified_epoch(e);
  if (e_.tag == FStar_Pervasives_Native_None)
  {
    t.failed[0U] = true;
    return true;
  }
  else if (e_.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t e1 = e_.v;
    uint64_t clock = t.clock[0U];
    if (epoch_of_timestamp(clock) == e1)
    {
      t.failed[0U] = true;
      return true;
    }
    else
    {
      bool acquired = acquire0(lock);
      if (!acquired)
        return false;
      else
      {
        bool b0 = propagate_epoch_hash(t, hashes, e1);
        bool b1 = update_bitmap(tid_bitmaps, e1, t.thread_id);
        if (!b0 || !b1)
        {
          cancel(lock);
          return false;
        }
        else
        {
          t.last_verified_epoch[0U] =
            (
              (FStar_Pervasives_Native_option__uint32_t){
                .tag = FStar_Pervasives_Native_Some,
                .v = e1
              }
            );
          release_lock(lock);
          return true;
        }
      }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static bool
verify_epoch(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh
)
{
  bool b = verify_epoch_core(t, aeh.hashes, aeh.tid_bitmaps, aeh.lock);
  return b;
}

static Zeta_Steel_VerifierTypes_thread_state_t create_basic(uint16_t tid)
{
  KRML_CHECK_SIZE(sizeof (bool), (uint32_t)1U);
  bool *failed = KRML_HOST_MALLOC(sizeof (bool));
  failed[0U] = false;
  KRML_CHECK_SIZE(sizeof (
      FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    ),
    as_u320(Zeta_Steel_ApplicationTypes_store_size));
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
  *store =
    KRML_HOST_MALLOC(sizeof (
        FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
      )
      * as_u320(Zeta_Steel_ApplicationTypes_store_size));
  for (uint32_t _i = 0U; _i < as_u320(Zeta_Steel_ApplicationTypes_store_size); ++_i)
    store[_i]
    =
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
          .tag = FStar_Pervasives_Native_None
        }
      );
  uint64_t *clock = KRML_HOST_CALLOC((uint32_t)1U, sizeof (uint64_t));
  Zeta_Steel_AggregateEpochHashes_all_epoch_hashes
  epoch_hashes = create__Zeta_Steel_EpochHashes_epoch_hashes_t((uint32_t)64U);
  KRML_CHECK_SIZE(sizeof (FStar_Pervasives_Native_option__uint32_t), (uint32_t)1U);
  FStar_Pervasives_Native_option__uint32_t
  *last_verified_epoch = KRML_HOST_MALLOC(sizeof (FStar_Pervasives_Native_option__uint32_t));
  last_verified_epoch[0U]
  = ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_None });
  uint8_t *serialization_buffer = KRML_HOST_CALLOC((uint32_t)4096U, sizeof (uint8_t));
  Zeta_Steel_HashValue_hasher_t hasher = alloc();
  return
    (
      (Zeta_Steel_VerifierTypes_thread_state_t){
        .thread_id = tid,
        .failed = failed,
        .store = store,
        .clock = clock,
        .epoch_hashes = epoch_hashes,
        .last_verified_epoch = last_verified_epoch,
        .serialization_buffer = serialization_buffer,
        .hasher = hasher
      }
    );
}

static void
madd_to_store_root(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t s,
  Zeta_Steel_LogEntry_Types_value v
)
{
  bool b = is_value_of(Zeta_Steel_ThreadStateModel_root_key, v);
  if (!!b)
  {
    FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
    ropt = t.store[as_u320(s)];
    if (!(ropt.tag == FStar_Pervasives_Native_Some))
    {
      Zeta_Steel_ThreadStateModel_store_entry
      new_entry =
        {
          .key = Zeta_Steel_ThreadStateModel_root_key, .value = v,
          .add_method = Zeta_Steel_ThreadStateModel_MAdd,
          .l_child_in_store = { .tag = FStar_Pervasives_Native_None },
          .r_child_in_store = { .tag = FStar_Pervasives_Native_None },
          .parent_slot = { .tag = FStar_Pervasives_Native_None }
        };
      t.store[as_u320(s)] =
        (
          (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
            .tag = FStar_Pervasives_Native_Some,
            .v = new_entry
          }
        );
    }
  }
}

static Zeta_Steel_VerifierTypes_thread_state_t create1(uint16_t tid)
{
  Zeta_Steel_VerifierTypes_thread_state_t ts = create_basic(tid);
  if (tid == (uint16_t)0U)
  {
    madd_to_store_root(ts, (uint16_t)0U, init_value(Zeta_Steel_ThreadStateModel_root_key));
    return ts;
  }
  else
    return ts;
}

static void fail0()
{
  
}

static FStar_Pervasives_Native_option__uint32_t verify_entry_cases(bool b)
{
  if (b)
    return
      (
        (FStar_Pervasives_Native_option__uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = (uint32_t)0U
        }
      );
  else
  {
    fail0();
    return ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_None });
  }
}

static FStar_Pervasives_Native_option__uint32_t
verify_log_entry(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh,
  log_entry le
)
{
  if (le.tag == VerifyEpoch)
  {
    bool b = verify_epoch(t, aeh);
    if (b)
      return
        (
          (FStar_Pervasives_Native_option__uint32_t){
            .tag = FStar_Pervasives_Native_Some,
            .v = (uint32_t)0U
          }
        );
    else
    {
      fail0();
      return ((FStar_Pervasives_Native_option__uint32_t){ .tag = FStar_Pervasives_Native_None });
    }
  }
  else if (le.tag == AddM)
  {
    record r = le.case_AddM.r;
    uint16_t s_ = le.case_AddM.s_;
    uint16_t s = le.case_AddM.s;
    bool b = vaddm(t, s, s_, r);
    return verify_entry_cases(b);
  }
  else if (le.tag == AddB)
  {
    record r = le.case_AddB.r;
    uint16_t tid = le.case_AddB.tid;
    uint64_t ts = le.case_AddB.ts;
    uint16_t s = le.case_AddB.s;
    bool b = vaddb(t, s, ts, tid, r);
    return verify_entry_cases(b);
  }
  else if (le.tag == EvictM)
  {
    evictM_payload pl = le.case_EvictM;
    vevictm(t, pl.s, pl.s_);
    return verify_entry_cases(true);
  }
  else if (le.tag == EvictB)
  {
    evictB_payload pl = le.case_EvictB;
    bool b = vevictb(t, pl.s1, pl.t);
    return verify_entry_cases(b);
  }
  else if (le.tag == EvictBM)
  {
    evictBM_payload pl = le.case_EvictBM;
    bool b = vevictbm(t, pl.s2, pl.s_1, pl.t1);
    return verify_entry_cases(b);
  }
  else if (le.tag == NextEpoch)
  {
    nextepoch(t);
    return verify_entry_cases(true);
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Zeta_Steel_Verifier_verify_result
verify_step(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint32_t len,
  uint32_t log_pos,
  uint8_t *log,
  uint32_t out_len,
  uint32_t out_offset,
  uint8_t *out,
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh
)
{
  option__K___Zeta_Steel_LogEntry_Types_log_entry_uint32_t
  res = zeta__parser_log_entry(len, log_pos, len - log_pos, log);
  if (res.tag == FStar_Pervasives_Native_None)
    return
      (
        (Zeta_Steel_Verifier_verify_result){
          .tag = Zeta_Steel_Verifier_Parsing_failure,
          { .case_Parsing_failure = log_pos }
        }
      );
  else if (res.tag == FStar_Pervasives_Native_Some)
  {
    uint32_t read = res.v.snd;
    log_entry le = res.v.fst;
    if (le.tag == RunApp)
    {
      runApp_payload pl = le.case_RunApp;
      uint32_t pl_pos0 = zeta__runapp_payload_offset(le);
      uint32_t pl_pos = log_pos + pl_pos0;
      verify_runapp_result
      app_res =
        Zeta_Steel_Application_run_app_function(pl,
          pl_pos,
          log,
          out_len,
          out_offset,
          out,
          t);
      if (app_res.tag == Run_app_parsing_failure)
        return
          (
            (Zeta_Steel_Verifier_verify_result){
              .tag = Zeta_Steel_Verifier_App_failure,
              { .case_App_failure = log_pos }
            }
          );
      else if (app_res.tag == Run_app_verify_failure)
        return
          (
            (Zeta_Steel_Verifier_verify_result){
              .tag = Zeta_Steel_Verifier_App_failure,
              { .case_App_failure = log_pos }
            }
          );
      else if (app_res.tag == Run_app_success)
      {
        uint32_t written = app_res.wrote;
        return
          (
            (Zeta_Steel_Verifier_verify_result){
              .tag = Zeta_Steel_Verifier_Verify_success,
              { .case_Verify_success = { .read = read, .wrote = written } }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      FStar_Pervasives_Native_option__uint32_t b = verify_log_entry(t, aeh, le);
      if (b.tag == FStar_Pervasives_Native_None)
        return
          (
            (Zeta_Steel_Verifier_verify_result){
              .tag = Zeta_Steel_Verifier_Verify_entry_failure,
              { .case_Verify_entry_failure = log_pos }
            }
          );
      else if (b.tag == FStar_Pervasives_Native_Some)
      {
        uint32_t written = b.v;
        return
          (
            (Zeta_Steel_Verifier_verify_result){
              .tag = Zeta_Steel_Verifier_Verify_success,
              { .case_Verify_success = { .read = read, .wrote = written } }
            }
          );
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static Zeta_Steel_Verifier_verify_result
verify_log_ind(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint32_t len,
  uint8_t *log,
  uint32_t log_pos,
  uint32_t outlen,
  uint32_t out_pos,
  uint8_t *out,
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh
)
{
  if (log_pos == len)
    return
      (
        (Zeta_Steel_Verifier_verify_result){
          .tag = Zeta_Steel_Verifier_Verify_success,
          { .case_Verify_success = { .read = log_pos, .wrote = out_pos } }
        }
      );
  else
  {
    bool is_failed = check_failed(t);
    if (is_failed)
      return
        (
          (Zeta_Steel_Verifier_verify_result){
            .tag = Zeta_Steel_Verifier_Verify_entry_failure,
            { .case_Verify_entry_failure = log_pos }
          }
        );
    else
    {
      Zeta_Steel_Verifier_verify_result
      res = verify_step(t, len, log_pos, log, outlen, out_pos, out, aeh);
      if (res.tag == Zeta_Steel_Verifier_Parsing_failure)
      {
        uint32_t loc = res.case_Parsing_failure;
        return
          (
            (Zeta_Steel_Verifier_verify_result){
              .tag = Zeta_Steel_Verifier_Parsing_failure,
              { .case_Parsing_failure = loc }
            }
          );
      }
      else if (res.tag == Zeta_Steel_Verifier_App_failure)
      {
        uint32_t loc = res.case_App_failure;
        return
          (
            (Zeta_Steel_Verifier_verify_result){
              .tag = Zeta_Steel_Verifier_App_failure,
              { .case_App_failure = loc }
            }
          );
      }
      else if (res.tag == Zeta_Steel_Verifier_Verify_entry_failure)
        return res;
      else if (res.tag == Zeta_Steel_Verifier_Verify_success)
      {
        uint32_t wrote = res.case_Verify_success.wrote;
        uint32_t read = res.case_Verify_success.read;
        return verify_log_ind(t, len, log, log_pos + read, outlen, out_pos + wrote, out, aeh);
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
  }
}

static Zeta_Steel_Verifier_verify_result
verify_log(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint32_t len,
  uint8_t *log,
  uint32_t outlen,
  uint8_t *out,
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh
)
{
  return verify_log_ind(t, len, log, (uint32_t)0U, outlen, (uint32_t)0U, out, aeh);
}

typedef struct Zeta_Steel_Main_thread_state_s
{
  uint16_t tid;
  Zeta_Steel_VerifierTypes_thread_state_t tsm;
  Steel_ST_CancellableSpinLock_cancellable_lock lock;
}
Zeta_Steel_Main_thread_state;

typedef struct Zeta_Steel_Main_top_level_state_s
{
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh;
  Zeta_Steel_Main_thread_state *all_threads;
}
Zeta_Steel_Main_top_level_state;

static Zeta_Steel_Main_thread_state init_thread_state(uint16_t i)
{
  Zeta_Steel_VerifierTypes_thread_state_t st = create1(i);
  Steel_ST_CancellableSpinLock_cancellable_lock lock = new_cancellable_lock();
  return ((Zeta_Steel_Main_thread_state){ .tid = i, .tsm = st, .lock = lock });
}

static void init_all_threads_state(Zeta_Steel_Main_thread_state *all_threads, uint16_t i)
{
  bool b = (uint32_t)i == Zeta_Steel_ApplicationTypes_n_threads;
  if (!b)
  {
    Zeta_Steel_Main_thread_state st = init_thread_state(i);
    all_threads[(uint32_t)i] = st;
    init_all_threads_state(all_threads, i + (uint16_t)1U);
  }
}

Zeta_Steel_Main_top_level_state *Zeta_Steel_Main_init()
{
  Zeta_Steel_AggregateEpochHashes_aggregate_epoch_hashes aeh = create0();
  Zeta_Steel_Main_thread_state st0 = init_thread_state((uint16_t)0U);
  KRML_CHECK_SIZE(sizeof (Zeta_Steel_Main_thread_state), Zeta_Steel_ApplicationTypes_n_threads);
  Zeta_Steel_Main_thread_state
  *all_threads =
    KRML_HOST_MALLOC(sizeof (Zeta_Steel_Main_thread_state) * Zeta_Steel_ApplicationTypes_n_threads);
  for (uint32_t _i = 0U; _i < Zeta_Steel_ApplicationTypes_n_threads; ++_i)
    all_threads[_i] = st0;
  init_all_threads_state(all_threads, (uint16_t)1U);
  Zeta_Steel_Main_top_level_state r = { .aeh = aeh, .all_threads = all_threads };
  KRML_CHECK_SIZE(sizeof (Zeta_Steel_Main_top_level_state), (uint32_t)1U);
  Zeta_Steel_Main_top_level_state
  *t = KRML_HOST_MALLOC(sizeof (Zeta_Steel_Main_top_level_state));
  t[0U] = r;
  return t;
}

static FStar_Pervasives_Native_option__Zeta_Steel_Verifier_verify_result
verify_log_aux(
  Zeta_Steel_Main_top_level_state t,
  uint16_t tid,
  uint32_t len,
  uint8_t *input,
  uint32_t out_len,
  uint8_t *output
)
{
  Zeta_Steel_Main_thread_state st_tid = t.all_threads[(uint32_t)tid];
  bool b = acquire0(st_tid.lock);
  if (b == false)
    return
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_Verifier_verify_result){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    Zeta_Steel_Verifier_verify_result
    vr = verify_log(st_tid.tsm, len, input, out_len, output, t.aeh);
    if (vr.tag == Zeta_Steel_Verifier_Verify_success)
    {
      bool b_failed = check_failed(st_tid.tsm);
      if (b_failed)
      {
        cancel(st_tid.lock);
        return
          (
            (FStar_Pervasives_Native_option__Zeta_Steel_Verifier_verify_result){
              .tag = FStar_Pervasives_Native_None
            }
          );
      }
      else
      {
        release0(st_tid.lock);
        return
          (
            (FStar_Pervasives_Native_option__Zeta_Steel_Verifier_verify_result){
              .tag = FStar_Pervasives_Native_Some,
              .v = vr
            }
          );
      }
    }
    else
    {
      cancel(st_tid.lock);
      return
        (
          (FStar_Pervasives_Native_option__Zeta_Steel_Verifier_verify_result){
            .tag = FStar_Pervasives_Native_None
          }
        );
    }
  }
}

FStar_Pervasives_Native_option__Zeta_Steel_Verifier_verify_result
Zeta_Steel_Main_verify_log(
  Zeta_Steel_Main_top_level_state *r,
  uint16_t tid,
  uint32_t len,
  uint8_t *input,
  uint32_t out_len,
  uint8_t *output
)
{
  Zeta_Steel_Main_top_level_state t_ = r[0U];
  FStar_Pervasives_Native_option__Zeta_Steel_Verifier_verify_result
  res = verify_log_aux(t_, tid, len, input, out_len, output);
  return res;
}

Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result
Zeta_Steel_Main_max_certified_epoch(Zeta_Steel_Main_top_level_state *r)
{
  Zeta_Steel_Main_top_level_state t_ = r[0U];
  Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result
  res = advance_and_read_max_certified_epoch(t_.aeh);
  if (res.tag == Zeta_Steel_AggregateEpochHashes_Read_max_error)
    return
      (
        (Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result){
          .tag = Zeta_Steel_AggregateEpochHashes_Read_max_error
        }
      );
  else if (res.tag == Zeta_Steel_AggregateEpochHashes_Read_max_none)
    return
      (
        (Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result){
          .tag = Zeta_Steel_AggregateEpochHashes_Read_max_none
        }
      );
  else if (res.tag == Zeta_Steel_AggregateEpochHashes_Read_max_some)
  {
    uint32_t max = res._0;
    return
      (
        (Zeta_Steel_AggregateEpochHashes_max_certified_epoch_result){
          .tag = Zeta_Steel_AggregateEpochHashes_Read_max_some,
          ._0 = max
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

FStar_Pervasives_Native_option__Zeta_Steel_VerifierTypes_kv
Zeta_Steel_Main_read_store(Zeta_Steel_VerifierTypes_thread_state_t t, uint16_t slot)
{
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
  se_opt = t.store[as_u32(slot)];
  if (se_opt.tag == FStar_Pervasives_Native_None)
    return
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_VerifierTypes_kv){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else if (se_opt.tag == FStar_Pervasives_Native_Some)
  {
    Zeta_Steel_ThreadStateModel_store_entry se = se_opt.v;
    Zeta_Steel_ThreadStateModel_store_entry se1 = se;
    return
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_VerifierTypes_kv){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .key = se1.key, .value = se1.value }
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

void
Zeta_Steel_Main_write_store(
  Zeta_Steel_VerifierTypes_thread_state_t t,
  uint16_t slot,
  Zeta_Steel_LogEntry_Types_value v
)
{
  FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry
  se_opt = t.store[as_u32(slot)];
  if (se_opt.tag == FStar_Pervasives_Native_Some)
  {
    Zeta_Steel_ThreadStateModel_store_entry se = se_opt.v;
    Zeta_Steel_ThreadStateModel_store_entry se1 = se;
    Zeta_Steel_ThreadStateModel_store_entry
    se_ =
      {
        .key = se1.key, .value = v, .add_method = se1.add_method,
        .l_child_in_store = se1.l_child_in_store, .r_child_in_store = se1.r_child_in_store,
        .parent_slot = se1.parent_slot
      };
    t.store[as_u32(slot)] =
      (
        (FStar_Pervasives_Native_option__Zeta_Steel_ThreadStateModel_store_entry){
          .tag = FStar_Pervasives_Native_Some,
          .v = se_
        }
      );
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

