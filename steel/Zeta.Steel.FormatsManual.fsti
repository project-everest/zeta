module Zeta.Steel.FormatsManual
include Zeta.Steel.LogEntry.Types
(* This file should eventually be generated by EverParse and renamed
   to Zeta.Steel.Formats *)
open FStar.Ghost
open Zeta.Steel.ApplicationTypes
module A = Zeta.App
module U8 = FStar.UInt8
module U16 = FStar.UInt16
module U32 = FStar.UInt32
module U64 = FStar.UInt64

(*
//remove the _base from the name
noeq
type log_entry_base =
  | AddM of addM_payload
  | AddB of addB_payload
  | EvictM of evictM_payload
  | EvictB of evictB_payload
  | EvictBM of evictBM_payload
  | NextEpoch of unit
  | VerifyEpoch of unit
  | AddMApp of addMApp_payload
  | AddBApp of addBApp_payload
  | RunApp of runApp_payload
*)

/// Factored into another module?

let slot = x:slot_id{ U16.v x < U16.v store_size }

let is_internal_key_for_data (k:base_key)
  : bool
  = k.significant_digits = 256us

let is_internal_key_root (k:base_key)
  : bool
  = k.significant_digits = 0us

type stamped_record = {
  record : record;
  timestamp : timestamp;
  thread_id : thread_id;
}

module P = Zeta.Steel.Parser
val spec_parser_app_record: P.spec_parser (key_type & option value_type)
val parse_app_record: P.parser spec_parser_app_record

val spec_parser_stamped_record : P.spec_parser stamped_record
val spec_serializer_stamped_record : P.spec_serializer spec_parser_stamped_record
val serialize_stamped_record : P.serializer spec_serializer_stamped_record

/// This is an ad hoc bound due to a bound on Blake hashable inputs
val serialized_stamped_record_length (s:stamped_record)
  : Lemma (Seq.length (spec_serializer_stamped_record s) <= 4096)

