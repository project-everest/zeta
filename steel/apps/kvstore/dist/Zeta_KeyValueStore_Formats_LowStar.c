/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/tahina/everest/master/karamel/krml -warn-error +9 -skip-compilation -no-prefix Zeta.KeyValueStore.Formats.LowStar -bundle Zeta.KeyValueStore.Formats.LowStar=Zeta.*,Prims,FStar.*,Hacl.*,Steel.*,LowStar.*,C.*,LowParse.* -library Zeta.Steel.VerifierTypes -library Steel.ST.Loops -library Steel.ST.Reference -static-header Steel.ST.Reference -no-prefix Zeta.Steel.LogEntry -no-prefix Zeta.Steel.LogEntry.Spec -hand-written Steel.ST.Reference ../_output/C_Loops.krml ../_output/FStar_Algebra_CommMonoid_Equiv.krml ../_output/FStar_All.krml ../_output/FStar_BV.krml ../_output/FStar_BigOps.krml ../_output/FStar_BitVector.krml ../_output/FStar_Bytes.krml ../_output/FStar_Calc.krml ../_output/FStar_Char.krml ../_output/FStar_Classical.krml ../_output/FStar_Classical_Sugar.krml ../_output/FStar_Endianness.krml ../_output/FStar_ErasedLogic.krml ../_output/FStar_Exn.krml ../_output/FStar_FunctionalExtensionality.krml ../_output/FStar_GSet.krml ../_output/FStar_Ghost.krml ../_output/FStar_Heap.krml ../_output/FStar_HyperStack.krml ../_output/FStar_HyperStack_ST.krml ../_output/FStar_IndefiniteDescription.krml ../_output/FStar_Int.krml ../_output/FStar_Int16.krml ../_output/FStar_Int32.krml ../_output/FStar_Int64.krml ../_output/FStar_Int8.krml ../_output/FStar_Int_Cast.krml ../_output/FStar_IntegerIntervals.krml ../_output/FStar_List.krml ../_output/FStar_List_Tot.krml ../_output/FStar_List_Tot_Base.krml ../_output/FStar_List_Tot_Properties.krml ../_output/FStar_Map.krml ../_output/FStar_Math_Lemmas.krml ../_output/FStar_Math_Lib.krml ../_output/FStar_ModifiesGen.krml ../_output/FStar_Monotonic_Heap.krml ../_output/FStar_Monotonic_HyperHeap.krml ../_output/FStar_Monotonic_HyperStack.krml ../_output/FStar_Monotonic_Pure.krml ../_output/FStar_Monotonic_Witnessed.krml ../_output/FStar_Mul.krml ../_output/FStar_Order.krml ../_output/FStar_PCM.krml ../_output/FStar_PartialMap.krml ../_output/FStar_Pervasives.krml ../_output/FStar_Pervasives_Native.krml ../_output/FStar_PredicateExtensionality.krml ../_output/FStar_Preorder.krml ../_output/FStar_PropositionalExtensionality.krml ../_output/FStar_Range.krml ../_output/FStar_Real.krml ../_output/FStar_Reflection.krml ../_output/FStar_Reflection_Builtins.krml ../_output/FStar_Reflection_Const.krml ../_output/FStar_Reflection_Data.krml ../_output/FStar_Reflection_Derived.krml ../_output/FStar_Reflection_Derived_Lemmas.krml ../_output/FStar_Reflection_Formula.krml ../_output/FStar_Reflection_Types.krml ../_output/FStar_ST.krml ../_output/FStar_Seq.krml ../_output/FStar_Seq_Base.krml ../_output/FStar_Seq_Equiv.krml ../_output/FStar_Seq_Permutation.krml ../_output/FStar_Seq_Properties.krml ../_output/FStar_Set.krml ../_output/FStar_Squash.krml ../_output/FStar_String.krml ../_output/FStar_StrongExcludedMiddle.krml ../_output/FStar_TSet.krml ../_output/FStar_Tactics.krml ../_output/FStar_Tactics_Builtins.krml ../_output/FStar_Tactics_CanonCommMonoidSimple_Equiv.krml ../_output/FStar_Tactics_CanonCommSwaps.krml ../_output/FStar_Tactics_Common.krml ../_output/FStar_Tactics_Derived.krml ../_output/FStar_Tactics_Effect.krml ../_output/FStar_Tactics_Logic.krml ../_output/FStar_Tactics_Print.krml ../_output/FStar_Tactics_Result.krml ../_output/FStar_Tactics_SyntaxHelpers.krml ../_output/FStar_Tactics_Types.krml ../_output/FStar_Tactics_Util.krml ../_output/FStar_UInt.krml ../_output/FStar_UInt128.krml ../_output/FStar_UInt16.krml ../_output/FStar_UInt32.krml ../_output/FStar_UInt64.krml ../_output/FStar_UInt8.krml ../_output/FStar_Universe.krml ../_output/FStar_Universe_PCM.krml ../_output/FStar_VConfig.krml ../_output/FStar_WellFounded.krml ../_output/Hacl_Blake2b_32.krml ../_output/LowParse_BitFields.krml ../_output/LowParse_Bytes.krml ../_output/LowParse_Bytes32.krml ../_output/LowParse_Endianness.krml ../_output/LowParse_Endianness_BitFields.krml ../_output/LowParse_Low.krml ../_output/LowParse_Low_Array.krml ../_output/LowParse_Low_BCVLI.krml ../_output/LowParse_Low_Base.krml ../_output/LowParse_Low_Base_Spec.krml ../_output/LowParse_Low_BoundedInt.krml ../_output/LowParse_Low_Bytes.krml ../_output/LowParse_Low_Combinators.krml ../_output/LowParse_Low_DER.krml ../_output/LowParse_Low_Endianness.krml ../_output/LowParse_Low_Enum.krml ../_output/LowParse_Low_ErrorCode.krml ../_output/LowParse_Low_FLData.krml ../_output/LowParse_Low_IfThenElse.krml ../_output/LowParse_Low_Int.krml ../_output/LowParse_Low_List.krml ../_output/LowParse_Low_Option.krml ../_output/LowParse_Low_Sum.krml ../_output/LowParse_Low_Tac_Sum.krml ../_output/LowParse_Low_VCList.krml ../_output/LowParse_Low_VLData.krml ../_output/LowParse_Low_VLGen.krml ../_output/LowParse_Math.krml ../_output/LowParse_Norm.krml ../_output/LowParse_Slice.krml ../_output/LowParse_Spec.krml ../_output/LowParse_Spec_AllIntegers.krml ../_output/LowParse_Spec_Array.krml ../_output/LowParse_Spec_BCVLI.krml ../_output/LowParse_Spec_Base.krml ../_output/LowParse_Spec_BoundedInt.krml ../_output/LowParse_Spec_Bytes.krml ../_output/LowParse_Spec_Combinators.krml ../_output/LowParse_Spec_DER.krml ../_output/LowParse_Spec_Enum.krml ../_output/LowParse_Spec_FLData.krml ../_output/LowParse_Spec_IfThenElse.krml ../_output/LowParse_Spec_Int.krml ../_output/LowParse_Spec_List.krml ../_output/LowParse_Spec_Option.krml ../_output/LowParse_Spec_Seq.krml ../_output/LowParse_Spec_SeqBytes.krml ../_output/LowParse_Spec_SeqBytes_Base.krml ../_output/LowParse_Spec_Sum.krml ../_output/LowParse_Spec_Tac_Enum.krml ../_output/LowParse_Spec_Tac_Sum.krml ../_output/LowParse_Spec_VCList.krml ../_output/LowParse_Spec_VLData.krml ../_output/LowParse_Spec_VLGen.krml ../_output/LowParse_TacLib.krml ../_output/LowStar_Buffer.krml ../_output/LowStar_BufferOps.krml ../_output/LowStar_Comment.krml ../_output/LowStar_Endianness.krml ../_output/LowStar_Failure.krml ../_output/LowStar_Modifies.krml ../_output/LowStar_Monotonic_Buffer.krml ../_output/Spec_Loops.krml ../_output/Zeta_App.krml ../_output/Zeta_AppSimulate.krml ../_output/Zeta_BinTree.krml ../_output/Zeta_Formats_Lib.krml ../_output/Zeta_Ghost.krml ../_output/Zeta_Hash.krml ../_output/Zeta_IdxFn.krml ../_output/Zeta_Interleave.krml ../_output/Zeta_Key.krml ../_output/Zeta_KeyValueStore_Formats.krml ../_output/Zeta_KeyValueStore_Formats_LowStar.krml ../_output/Zeta_KeyValueStore_Formats_Spec.krml ../_output/Zeta_KeyValueStore_Formats_Types.krml ../_output/Zeta_KeyValueStore_Spec.krml ../_output/Zeta_KeyValueStore_StateMachine.krml ../_output/Zeta_LowStar_Parser.krml ../_output/Zeta_MultiSet.krml ../_output/Zeta_SSeq.krml ../_output/Zeta_SeqAux.krml ../_output/Zeta_SeqIdx.krml ../_output/Zeta_Steel_AggregateEpochHashes.krml ../_output/Zeta_Steel_Application.krml ../_output/Zeta_Steel_ApplicationRecord.krml ../_output/Zeta_Steel_ApplicationResult.krml ../_output/Zeta_Steel_ApplicationTypes.krml ../_output/Zeta_Steel_BitUtils.krml ../_output/Zeta_Steel_EpochHashes.krml ../_output/Zeta_Steel_EpochMap.krml ../_output/Zeta_Steel_FormatsManual.krml ../_output/Zeta_Steel_HashAccumulator.krml ../_output/Zeta_Steel_HashValue.krml ../_output/Zeta_Steel_KeyUtils.krml ../_output/Zeta_Steel_LogEntry.krml ../_output/Zeta_Steel_LogEntry_Spec.krml ../_output/Zeta_Steel_LogEntry_Types.krml ../_output/Zeta_Steel_Parser.krml ../_output/Zeta_Steel_ThreadLogMap.krml ../_output/Zeta_Steel_ThreadStateModel.krml ../_output/Zeta_Steel_Util.krml ../_output/Zeta_Steel_VerifierTypes.krml ../_output/out.krml -tmpdir=../_output
  F* version: c75b6da5
  KaRaMeL version: 9760cc33
 */

#include "Zeta_KeyValueStore_Formats_LowStar.h"



#define VALIDATOR_MAX_LENGTH ((uint64_t)4294967295U)

static inline bool is_error(uint64_t positionOrError)
{
  return positionOrError > VALIDATOR_MAX_LENGTH;
}

#define VALIDATOR_ERROR_NOT_ENOUGH_DATA ((uint64_t)8589934592U)

typedef struct __uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
}
__uint64_t_uint64_t;

typedef struct __uint64_t___uint64_t_uint16_t_s
{
  __uint64_t_uint64_t fst;
  uint16_t snd;
}
__uint64_t___uint64_t_uint16_t;

static Zeta_KeyValueStore_Formats_Types_vget_args_t
synth_vget_args(__uint64_t___uint64_t_uint16_t uu___)
{
  uint16_t vget_slot = uu___.snd;
  uint64_t vget_value = uu___.fst.snd;
  uint64_t vget_key = uu___.fst.fst;
  return
    (
      (Zeta_KeyValueStore_Formats_Types_vget_args_t){
        .vget_key = vget_key,
        .vget_value = vget_value,
        .vget_slot = vget_slot
      }
    );
}

static Zeta_KeyValueStore_Formats_Types_vput_args_t
synth_vput_args(__uint64_t___uint64_t_uint16_t uu___)
{
  uint16_t vput_slot = uu___.snd;
  uint64_t vput_value = uu___.fst.snd;
  uint64_t vput_key = uu___.fst.fst;
  return
    (
      (Zeta_KeyValueStore_Formats_Types_vput_args_t){
        .vput_key = vput_key,
        .vput_value = vput_value,
        .vput_slot = vput_slot
      }
    );
}

FStar_Pervasives_Native_option__uint64_t___uint32_t
kvstore_key_parser(uint32_t len, uint32_t offset, uint32_t slice_len, uint8_t *a)
{
  uint8_t *a_ = a + offset;
  uint64_t is_err;
  if ((uint64_t)slice_len - (uint64_t)0U < (uint64_t)8U)
    is_err = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    is_err = (uint64_t)8U;
  if (is_error(is_err))
    return
      ((FStar_Pervasives_Native_option__uint64_t___uint32_t){ .tag = FStar_Pervasives_Native_None });
  else
  {
    uint64_t res = load64_be(a_);
    return
      (
        (FStar_Pervasives_Native_option__uint64_t___uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = res, .snd = (uint32_t)is_err }
        }
      );
  }
}

uint32_t kvstore_key_serializer(uint32_t len, uint32_t offset, uint8_t *a, uint64_t v)
{
  uint8_t *a_ = a + offset;
  store64_be(a_, v);
  return (uint32_t)8U;
}

FStar_Pervasives_Native_option__uint64_t___uint32_t
kvstore_value_parser(uint32_t len, uint32_t offset, uint32_t slice_len, uint8_t *a)
{
  uint8_t *a_ = a + offset;
  uint64_t is_err;
  if ((uint64_t)slice_len - (uint64_t)0U < (uint64_t)8U)
    is_err = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    is_err = (uint64_t)8U;
  if (is_error(is_err))
    return
      ((FStar_Pervasives_Native_option__uint64_t___uint32_t){ .tag = FStar_Pervasives_Native_None });
  else
  {
    uint64_t res = load64_be(a_);
    return
      (
        (FStar_Pervasives_Native_option__uint64_t___uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = res, .snd = (uint32_t)is_err }
        }
      );
  }
}

uint32_t kvstore_value_serializer(uint32_t len, uint32_t offset, uint8_t *a, uint64_t v)
{
  uint8_t *a_ = a + offset;
  store64_be(a_, v);
  return (uint32_t)8U;
}

FStar_Pervasives_Native_option__Zeta_KeyValueStore_Formats_Types_vget_args_t___uint32_t
kvstore_vget_args_parser(uint32_t len, uint32_t offset, uint32_t slice_len, uint8_t *a)
{
  uint8_t *a_ = a + offset;
  uint64_t pos10;
  if ((uint64_t)slice_len - (uint64_t)0U < (uint64_t)8U)
    pos10 = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos10 = (uint64_t)8U;
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else if ((uint64_t)slice_len - pos10 < (uint64_t)8U)
    pos1 = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos1 = pos10 + (uint64_t)8U;
  uint64_t is_err;
  if (is_error(pos1))
    is_err = pos1;
  else if ((uint64_t)slice_len - pos1 < (uint64_t)2U)
    is_err = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    is_err = pos1 + (uint64_t)2U;
  if (is_error(is_err))
    return
      (
        (FStar_Pervasives_Native_option__Zeta_KeyValueStore_Formats_Types_vget_args_t___uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    uint64_t x1 = load64_be(a_);
    uint32_t pos20 = (uint32_t)8U;
    uint64_t x2 = load64_be(a_ + pos20);
    __uint64_t_uint64_t x10 = { .fst = x1, .snd = x2 };
    uint32_t pos2 = (uint32_t)8U + (uint32_t)8U;
    uint16_t x20 = load16_be(a_ + pos2);
    __uint64_t___uint64_t_uint16_t res = { .fst = x10, .snd = x20 };
    Zeta_KeyValueStore_Formats_Types_vget_args_t res0 = synth_vget_args(res);
    return
      (
        (FStar_Pervasives_Native_option__Zeta_KeyValueStore_Formats_Types_vget_args_t___uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = res0, .snd = (uint32_t)is_err }
        }
      );
  }
}

FStar_Pervasives_Native_option__Zeta_KeyValueStore_Formats_Types_vput_args_t___uint32_t
kvstore_vput_args_parser(uint32_t len, uint32_t offset, uint32_t slice_len, uint8_t *a)
{
  uint8_t *a_ = a + offset;
  uint64_t pos10;
  if ((uint64_t)slice_len - (uint64_t)0U < (uint64_t)8U)
    pos10 = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos10 = (uint64_t)8U;
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else if ((uint64_t)slice_len - pos10 < (uint64_t)8U)
    pos1 = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    pos1 = pos10 + (uint64_t)8U;
  uint64_t is_err;
  if (is_error(pos1))
    is_err = pos1;
  else if ((uint64_t)slice_len - pos1 < (uint64_t)2U)
    is_err = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    is_err = pos1 + (uint64_t)2U;
  if (is_error(is_err))
    return
      (
        (FStar_Pervasives_Native_option__Zeta_KeyValueStore_Formats_Types_vput_args_t___uint32_t){
          .tag = FStar_Pervasives_Native_None
        }
      );
  else
  {
    uint64_t x1 = load64_be(a_);
    uint32_t pos20 = (uint32_t)8U;
    uint64_t x2 = load64_be(a_ + pos20);
    __uint64_t_uint64_t x10 = { .fst = x1, .snd = x2 };
    uint32_t pos2 = (uint32_t)8U + (uint32_t)8U;
    uint16_t x20 = load16_be(a_ + pos2);
    __uint64_t___uint64_t_uint16_t res = { .fst = x10, .snd = x20 };
    Zeta_KeyValueStore_Formats_Types_vput_args_t res0 = synth_vput_args(res);
    return
      (
        (FStar_Pervasives_Native_option__Zeta_KeyValueStore_Formats_Types_vput_args_t___uint32_t){
          .tag = FStar_Pervasives_Native_Some,
          .v = { .fst = res0, .snd = (uint32_t)is_err }
        }
      );
  }
}

