module Zeta.Steel.Application

open Steel.ST.Effect.Atomic

module U16 = FStar.UInt16

module App = Zeta.App

module TSM = Zeta.Steel.ThreadStateModel

module VT = Zeta.Steel.VerifierTypes

module KAT = Zeta.Steel.ApplicationTypes
module KVS = Zeta.KeyValueStore.Spec
module KVF = Zeta.KeyValueStore.Formats

friend Zeta.Steel.ApplicationTypes

assume val admit__ (#a:Type) (#p:vprop) (#q:post_t a) (_:unit)
  : STF a p q (True) (fun _ -> False)

let run_app_function #log_perm #log_bytes log_len pl pl_pos log_array
  #out_bytes out_len out_offset out
  #tsm t
  = // Is this a precondition?
    assume (not tsm.failed);
    if pl.fid = KVS.vget_id
    then begin
      // parse the arguments
      let ropt = KVF.vget_args_parser log_len pl_pos pl.rest.len log_array in
      match ropt with
      | None -> return Run_app_parsing_failure
      | Some (r, consumed) ->
        //
        // TODO: need to change the type in Zeta.Steel.Formats.fsti,
        //       that file is generated by EverParse
        //
        assume (consumed == pl.rest.len);
        assume (U16.v r.vget_slot < U16.v KAT.store_size);
        let kvopt = VT.read_store t r.vget_slot in
        match kvopt with
        | None -> return Run_app_verify_failure
        | Some kv ->
          match kv.key, kv.value with
          | InternalKey _, _ -> return Run_app_verify_failure
          | _, MValue _ -> return Run_app_verify_failure
          | ApplicationKey k, DValue vopt ->
            //
            // This comparison requires us to friend Zeta.Steel.ApplicationTypes
            // Since k:Zeta.Steel.ApplicationTypes.key_type
            // and r.vget_key:KVS.key_t
            // and both are related only in ApplicationTypes.fst
            //
            if r.vget_key = k && Some r.vget_value = vopt
            then begin
              assert (Map.contains aprm.tbl pl.fid);
              assert (spec_app_parser pl.fid pl.rest.ebytes ==
                      Some (((r.vget_key, r.vget_value), Seq.create 1 r.vget_slot), U32.v consumed));
              assert (consumed == pl.rest.len);
              assert (Zeta.SeqAux.distinct_elems_comp (Seq.create 1 r.vget_slot));
              assert (Some? (TSM.read_slots tsm (Seq.create 1 r.vget_slot)));
              assert (let (Some recs) = TSM.read_slots tsm (Seq.create 1 r.vget_slot) in
                      TSM.check_distinct_keys recs);
              assert (let (Some recs) = TSM.read_slots tsm (Seq.create 1 r.vget_slot) in
                      let kv = Seq.index recs 0 in
                      fst kv == r.vget_key /\
                      snd kv == DValue r.vget_value);
              assert (let (Some recs) = TSM.read_slots tsm (Seq.create 1 r.vget_slot) in
                      let fsig = Map.sel aprm.tbl pl.fid in
                      let (r, v, out_vals) = fsig.f (r.vget_key, r.vget_value) recs in
                      r == App.Fn_success /\
                      v == () /\
                      out_vals == Seq.create 1 (snd (Seq.index recs 0)));
              admit__ ()
            end
            else return Run_app_verify_failure
    end
    else begin
      admit__ ()
    end
