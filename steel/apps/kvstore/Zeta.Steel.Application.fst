module Zeta.Steel.Application

open Steel.ST.Effect.Atomic

module U16 = FStar.UInt16

module App = Zeta.App

module TSM = Zeta.Steel.ThreadStateModel

module VT = Zeta.Steel.VerifierTypes

module KAT = Zeta.Steel.ApplicationTypes
module KVS = Zeta.KeyValueStore.Spec
module KVF = Zeta.KeyValueStore.Formats

friend Zeta.Steel.ApplicationTypes

assume val admit__ (#a:Type) (#p:vprop) (#q:post_t a) (_:unit)
  : STF a p q (True) (fun _ -> False)

let seq_create_singleton_contains (#a:Type) (x:a) (y:a)
  : Lemma (Seq.Properties.contains (Seq.create 1 x) y <==> x == y)
          [SMTPat (Seq.Properties.contains (Seq.create 1 x) y)]
  = admit ()

let restore_thread_state_inv (#opened:_)
  (t:VT.thread_state_t)
  (tsm:TSM.thread_state_model)
  (e:log_entry)
  : STGhostT unit opened
      (VT.thread_state_inv t tsm)
      (fun _ -> VT.thread_state_inv t (TSM.verify_step_model tsm e))
  = VT.elim_thread_state_inv t;
    TSM.tsm_entries_invariant_verify_step tsm e;
    let tsm' = TSM.verify_step_model tsm e in
    assert (VT.thread_id t == tsm'.thread_id);
    assert (VT.tsm_entries_invariant tsm');
    // TODO: need a lemma to establish VT.thread_state_inv_core for tsm'
    //       it is missing from the interface
    // VT.intro_thread_state_inv #_ #(TSM.verify_step_model tsm e) t
    admit_ ()

let restore_thread_state_inv_core_put (#opened:_)
  (t:VT.thread_state_t)
  (tsm:TSM.thread_state_model)
  (app_results:TSM.app_results)
  (es:Seq.seq log_entry)
  : STGhostT unit opened
      (VT.thread_state_inv_core t tsm)
      (fun _ -> VT.thread_state_inv_core t ({tsm with app_results=app_results;
                                                processed_entries=es}))
  = admit_ ()
  
//#push-options "--z3rlimit 100 --fuel 4 --ifuel 4 --using_facts_from '* -FStar.Tactics -FStar.Reflection' --split_queries --query_stats"
#set-options "--print_full_names"
let run_app_function #log_perm #log_bytes log_len pl pl_pos log_array
  #out_bytes out_len out_offset out
  #tsm t
  = if pl.fid = KVS.vget_id
    then begin
      let ropt = KVF.vget_args_parser log_len pl_pos pl.rest.len log_array in
      match ropt with
      | None -> return Run_app_parsing_failure
      | Some (r, _) ->
        //
        // TODO: need to change the type in Zeta.Steel.Formats.fsti,
        //       that file is generated by EverParse
        //
        assume (U16.v r.vget_slot < U16.v KAT.store_size);
        let kvopt = VT.read_store t r.vget_slot in
        match kvopt with
        | None -> return Run_app_verify_failure
        | Some kv ->
          match kv.key, kv.value with
          | InternalKey _, _ -> return Run_app_verify_failure
          | _, MValue _ -> return Run_app_verify_failure
          | ApplicationKey k, DValue vopt ->
            //
            // This comparison requires us to friend Zeta.Steel.ApplicationTypes
            // Since k:Zeta.Steel.ApplicationTypes.key_type
            // and r.vget_key:KVS.key_t
            // and both are related only in ApplicationTypes.fst
            //
            if r.vget_key = k && Some r.vget_value = vopt
            then begin
              restore_thread_state_inv t tsm (RunApp pl);
              let wrote = 0ul in
              assume (n_out_bytes
                        tsm
                        (TSM.verify_step_model tsm (RunApp pl))
                        out_offset
                        wrote
                        out_bytes
                        out_bytes);
              intro_pure (n_out_bytes
                            tsm
                            (TSM.verify_step_model tsm (RunApp pl))
                            out_offset
                            wrote
                            out_bytes
                            out_bytes);
              return (Run_app_success wrote)
            end
            else return Run_app_verify_failure
    end
    else admit__ ()

    // if pl.fid = KVS.vput_id
    // then begin
    //   assume (not tsm.failed);
    //   let ropt = KVF.vput_args_parser log_len pl_pos pl.rest.len log_array in
    //   match ropt with
    //   | None -> return Run_app_parsing_failure
    //   | Some (r, consumed) ->
    //     //
    //     // TODO: need to change the type in Zeta.Steel.Formats.fsti,
    //     //       that file is generated by EverParse
    //     //
    //     assume (U16.v r.vput_slot < U16.v KAT.store_size);
    //     let kvopt = VT.read_store t r.vput_slot in
    //     match kvopt with
    //     | None -> return Run_app_verify_failure
    //     | Some kv ->
    //       match kv.key, kv.value with
    //       | InternalKey _, _ -> return Run_app_verify_failure
    //       | _, MValue _ -> return Run_app_verify_failure
    //       | ApplicationKey k, DValue v_store ->
    //         if r.vput_key = k
    //         then begin
    //           VT.elim_thread_state_inv t;
    //           VT.write_store #tsm t r.vput_slot (DValue (Some r.vput_value));
    //           assert (ApplicationKey? (TSM.key_of_slot tsm r.vput_slot));
    //           assert (TSM.has_slot tsm r.vput_slot);
    //           assert (Map.contains aprm.tbl pl.fid);
    //           assert (spec_app_parser pl.fid pl.rest.ebytes ==
    //                   Some (((r.vput_key, r.vput_value), Seq.create 1 r.vput_slot), U32.v consumed));
    //           assume (consumed == pl.rest.len);
    //           assert (Zeta.SeqAux.distinct_elems_comp (Seq.create 1 r.vput_slot));
    //           assert (
    //             let slots = Seq.create 1 r.vput_slot in
    //             let arg = r.vput_key, r.vput_value in
    //             let recs = Some?.v (TSM.read_slots tsm (Seq.create 1 r.vput_slot)) in
    //             let out_vals = Seq.create 1 (App.DValue r.vput_value) in
    //             let tsm' = {tsm with app_results=Seq.Properties.snoc tsm.app_results (| pl.fid, arg, recs, () |)} in
    //             let tsm' = TSM.write_slots tsm' slots out_vals in
    //             let tsm' = {tsm' with processed_entries = Seq.snoc tsm.processed_entries (RunApp pl)} in
    //             tsm' == TSM.verify_step_model tsm (RunApp pl) /\
    //             tsm' == {(VT.update_tsm_slot_value tsm r.vput_slot (DValue (Some r.vput_value))) with
    //                      TSM.app_results=Seq.Properties.snoc tsm.app_results (| pl.fid, arg, recs, () |);
    //                      TSM.processed_entries = Seq.snoc tsm.processed_entries (RunApp pl)});
    //           let tsm' = {(VT.update_tsm_slot_value tsm r.vput_slot (DValue (Some r.vput_value))) with
    //                      TSM.app_results=Seq.Properties.snoc tsm.app_results (| pl.fid, (r.vput_key, r.vput_value), (Some?.v (TSM.read_slots tsm (Seq.create 1 r.vput_slot))), () |);
    //                      TSM.processed_entries = Seq.snoc tsm.processed_entries (RunApp pl)} in
    //           restore_thread_state_inv_core_put t
    //             (VT.update_tsm_slot_value tsm r.vput_slot (DValue (Some r.vput_value)))
    //             (Seq.Properties.snoc tsm.app_results (| pl.fid, (r.vput_key, r.vput_value), (Some?.v (TSM.read_slots tsm (Seq.create 1 r.vput_slot))), () |))
    //             (Seq.snoc tsm.processed_entries (RunApp pl));
    //           assert (VT.tsm_entries_invariant tsm');
    //           VT.intro_thread_state_inv #_ #tsm' t;
    //           let wrote = 0ul in
    //           assume (n_out_bytes
    //                     tsm
    //                     (TSM.verify_step_model tsm (RunApp pl))
    //                     out_offset
    //                     wrote
    //                     out_bytes
    //                     out_bytes);
    //           intro_pure (n_out_bytes
    //                         tsm
    //                         (TSM.verify_step_model tsm (RunApp pl))
    //                         out_offset
    //                         wrote
    //                         out_bytes
    //                         out_bytes);
    //           return (Run_app_success wrote)
    //         end
    //         else return Run_app_verify_failure
    // end
    // else return Run_app_verify_failure

let key_type_to_base_key _ = admit__ ()
