module Zeta.Steel.Application

open Steel.ST.Effect.Atomic

module U16 = FStar.UInt16

module App = Zeta.App

module TSM = Zeta.Steel.ThreadStateModel

module VT = Zeta.Steel.VerifierTypes

module KAT = Zeta.Steel.ApplicationTypes
module KVS = Zeta.KeyValueStore.Spec
module KVF = Zeta.KeyValueStore.Formats

friend Zeta.Steel.ApplicationTypes

assume val admit__ (#a:Type) (#p:vprop) (#q:post_t a) (_:unit)
  : STF a p q (True) (fun _ -> False)

let seq_create_singleton_contains (#a:Type) (x:a) (y:a)
  : Lemma (Seq.Properties.contains (Seq.create 1 x) y <==> x == y)
          [SMTPat (Seq.Properties.contains (Seq.create 1 x) y)]
  = admit ()

let restore_thread_state_inv (#opened:_)
  (t:VT.thread_state_t)
  (tsm:TSM.thread_state_model)
  (e:log_entry)
  : STGhostT unit opened
      (VT.thread_state_inv t tsm)
      (fun _ -> VT.thread_state_inv t (TSM.verify_step_model tsm e))
  = VT.elim_thread_state_inv t;
    TSM.tsm_entries_invariant_verify_step tsm e;
    let tsm' = TSM.verify_step_model tsm e in
    assert (VT.thread_id t == tsm'.thread_id);
    assert (VT.tsm_entries_invariant tsm');
    // TODO: need a lemma to establish VT.thread_state_inv_core for tsm'
    //       it is missing from the interface
    // VT.intro_thread_state_inv #_ #(TSM.verify_step_model tsm e) t
    admit_ ()

let run_app_function #log_perm #log_bytes log_len pl pl_pos log_array
  #out_bytes out_len out_offset out
  #tsm t
  = if pl.fid = KVS.vget_id
    then begin
      let ropt = KVF.vget_args_parser log_len pl_pos pl.rest.len log_array in
      match ropt with
      | None -> return Run_app_parsing_failure
      | Some (r, _) ->
        //
        // TODO: need to change the type in Zeta.Steel.Formats.fsti,
        //       that file is generated by EverParse
        //
        assume (U16.v r.vget_slot < U16.v KAT.store_size);
        let kvopt = VT.read_store t r.vget_slot in
        match kvopt with
        | None -> return Run_app_verify_failure
        | Some kv ->
          match kv.key, kv.value with
          | InternalKey _, _ -> return Run_app_verify_failure
          | _, MValue _ -> return Run_app_verify_failure
          | ApplicationKey k, DValue vopt ->
            //
            // This comparison requires us to friend Zeta.Steel.ApplicationTypes
            // Since k:Zeta.Steel.ApplicationTypes.key_type
            // and r.vget_key:KVS.key_t
            // and both are related only in ApplicationTypes.fst
            //
            if r.vget_key = k && Some r.vget_value = vopt
            then begin
              // assert (ApplicationKey? (TSM.key_of_slot tsm r.vget_slot));
              // assert (TSM.has_slot tsm r.vget_slot);
              // assert (Map.contains aprm.tbl pl.fid);
              // assert (spec_app_parser pl.fid pl.rest.ebytes ==
              //         Some (((r.vget_key, r.vget_value), Seq.create 1 r.vget_slot), U32.v consumed));
              // assert (consumed == pl.rest.len);
              // assert (Zeta.SeqAux.distinct_elems_comp (Seq.create 1 r.vget_slot));
              // assert (Some? (TSM.read_slots tsm (Seq.create 1 r.vget_slot)));
              // assert (let (Some recs) = TSM.read_slots tsm (Seq.create 1 r.vget_slot) in
              //         TSM.check_distinct_keys recs);
              // assert (let (Some recs) = TSM.read_slots tsm (Seq.create 1 r.vget_slot) in
              //         let kv = Seq.index recs 0 in
              //         fst kv == r.vget_key /\
              //         snd kv == App.DValue r.vget_value);
              // assert (let (Some recs) = TSM.read_slots tsm (Seq.create 1 r.vget_slot) in
              //         Seq.equal recs (Seq.create 1 (r.vget_key, App.DValue r.vget_value)));
              // assert (let (Some recs) = TSM.read_slots tsm (Seq.create 1 r.vget_slot) in
              //         let fsig = Map.sel aprm.tbl pl.fid in
              //         let (r, v, out_vals) = fsig.f (r.vget_key, r.vget_value) recs in
              //         r == App.Fn_success /\
              //         v == () /\
              //         out_vals == Seq.create 1 (snd (Seq.index recs 0)));
              // assert (
              //   let slots = Seq.create 1 r.vget_slot in
              //   let arg = r.vget_key, r.vget_value in
              //   let recs = Seq.create 1 (r.vget_key, App.DValue r.vget_value) in
              //   let out_vals = Seq.create 1 (App.DValue r.vget_value) in
              //   let tsm' = {tsm with app_results=Seq.Properties.snoc tsm.app_results (| pl.fid, arg, recs, () |)} in
              //   let tsm' = TSM.write_slots tsm' slots out_vals in
              //   let tsm' = {tsm' with processed_entries = Seq.snoc tsm.processed_entries (RunApp pl)} in
              //   TSM.verify_step_model tsm (RunApp pl) == tsm');

              restore_thread_state_inv t tsm (RunApp pl);
              let wrote = 0ul in
              assume (n_out_bytes
                        tsm
                        (TSM.verify_step_model tsm (RunApp pl))
                        out_offset
                        wrote
                        out_bytes
                        out_bytes);
              intro_pure (n_out_bytes
                            tsm
                            (TSM.verify_step_model tsm (RunApp pl))
                            out_offset
                            wrote
                            out_bytes
                            out_bytes);
              return (Run_app_success wrote)
            end
            else return Run_app_verify_failure
    end
    else begin
      admit__ ()
    end
