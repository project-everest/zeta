/*
  This file has been automatically generated by EverParse.
 */


#include "Zeta_Formats.h"

#define VALIDATOR_MAX_LENGTH ((uint64_t)4294967295U)

static inline bool is_error(uint64_t positionOrError)
{
  return positionOrError > VALIDATOR_MAX_LENGTH;
}

#define VALIDATOR_ERROR_GENERIC ((uint64_t)4294967296U)

#define VALIDATOR_ERROR_NOT_ENOUGH_DATA ((uint64_t)8589934592U)

typedef struct slice_s
{
  uint8_t *base;
  uint32_t len;
}
slice;

static uint32_t vbool_size32(Zeta_Formats_Types_vbool x)
{
  return (uint32_t)1U;
}

static uint64_t vbool_validator(slice input, uint64_t pos)
{
  uint64_t res;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    res = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    res = pos + (uint64_t)1U;
  if (is_error(res))
    return res;
  else
  {
    uint8_t va = input.base[(uint32_t)pos];
    bool ite;
    if (va == (uint8_t)0U)
      ite = true;
    else if (va == (uint8_t)1U)
      ite = true;
    else
      ite = false;
    if (!ite)
      return VALIDATOR_ERROR_GENERIC;
    else
      return res;
  }
}

static Zeta_Formats_Types_vbool vbool_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  if (res == (uint8_t)0U)
    return Zeta_Formats_Types_Vfalse;
  else if (res == (uint8_t)1U)
    return Zeta_Formats_Types_Vtrue;
  else
    return Zeta_Formats_Types_Vfalse;
}

static uint32_t vbool_writer(Zeta_Formats_Types_vbool x, slice input, uint32_t pos)
{
  uint8_t ite;
  if (Zeta_Formats_Types_Vfalse == x)
    ite = (uint8_t)0U;
  else
    ite = (uint8_t)1U;
  input.base[pos] = ite;
  uint32_t len = (uint32_t)1U;
  uint32_t res = pos + len;
  uint32_t pos_ = res;
  uint32_t pos_0 = pos_;
  return pos_0;
}

static uint32_t vbool_lserializer(Zeta_Formats_Types_vbool x, uint8_t *b, uint32_t pos)
{
  uint32_t pos_ = vbool_writer(x, ((slice){ .base = b, .len = pos + (uint32_t)1U }), pos);
  return pos_ - pos;
}

static uint32_t u256_size32(Zeta_Formats_Types_u256 input)
{
  uint32_t v1 = (uint32_t)8U;
  uint32_t v20 = (uint32_t)8U;
  uint32_t res0;
  if ((uint32_t)4294967295U - v20 < v1)
    res0 = (uint32_t)4294967295U;
  else
    res0 = v1 + v20;
  uint32_t v10 = res0;
  uint32_t v11 = (uint32_t)8U;
  uint32_t v2 = (uint32_t)8U;
  uint32_t res;
  if ((uint32_t)4294967295U - v2 < v11)
    res = (uint32_t)4294967295U;
  else
    res = v11 + v2;
  uint32_t v21 = res;
  if ((uint32_t)4294967295U - v21 < v10)
    return (uint32_t)4294967295U;
  else
    return v10 + v21;
}

static uint64_t u256_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t u256_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

typedef struct __uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
}
__uint64_t_uint64_t;

typedef struct u256__s
{
  __uint64_t_uint64_t fst;
  __uint64_t_uint64_t snd;
}
u256_;

static Zeta_Formats_Types_u256 u256_reader(slice input, uint32_t pos)
{
  uint8_t *x00 = input.base;
  uint64_t x1 = load64_be(x00 + pos);
  uint32_t pos20 = pos + (uint32_t)8U;
  uint8_t *x01 = input.base;
  uint64_t x2 = load64_be(x01 + pos20);
  __uint64_t_uint64_t x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = pos + (uint32_t)8U + (uint32_t)8U;
  uint8_t *x02 = input.base;
  uint64_t x11 = load64_be(x02 + pos2);
  uint32_t pos21 = pos2 + (uint32_t)8U;
  uint8_t *x0 = input.base;
  uint64_t x20 = load64_be(x0 + pos21);
  __uint64_t_uint64_t x21 = { .fst = x11, .snd = x20 };
  u256_ res = { .fst = x10, .snd = x21 };
  uint64_t v0 = res.snd.snd;
  uint64_t v1 = res.snd.fst;
  uint64_t v2 = res.fst.snd;
  uint64_t v3 = res.fst.fst;
  return ((Zeta_Formats_Types_u256){ .v3 = v3, .v2 = v2, .v1 = v1, .v0 = v0 });
}

static uint32_t u256_lserializer(Zeta_Formats_Types_u256 x, uint8_t *input, uint32_t pos)
{
  store64_be(input + pos, x.v3);
  uint32_t res0 = (uint32_t)8U;
  uint32_t len1 = res0;
  uint32_t pos10 = pos + len1;
  store64_be(input + pos10, x.v2);
  uint32_t res1 = (uint32_t)8U;
  uint32_t len2 = res1;
  uint32_t res2 = len1 + len2;
  uint32_t len10 = res2;
  uint32_t pos1 = pos + len10;
  store64_be(input + pos1, x.v1);
  uint32_t res = (uint32_t)8U;
  uint32_t len11 = res;
  uint32_t pos11 = pos1 + len11;
  store64_be(input + pos11, x.v0);
  uint32_t res3 = (uint32_t)8U;
  uint32_t len20 = res3;
  uint32_t res4 = len11 + len20;
  uint32_t len21 = res4;
  return len10 + len21;
}

static uint32_t (*hash_value_size32)(Zeta_Formats_Types_u256 x0) = u256_size32;

static uint64_t hash_value_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t hash_value_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

static Zeta_Formats_Types_u256 (*hash_value_reader)(slice x0, uint32_t x1) = u256_reader;

static uint32_t
(*hash_value_lserializer)(Zeta_Formats_Types_u256 x0, uint8_t *x1, uint32_t x2) =
  u256_lserializer;

static uint32_t significant_digits_t_size32(uint16_t x)
{
  return (uint32_t)2U;
}

static uint64_t significant_digits_t_validator(slice input, uint64_t pos)
{
  uint64_t res;
  if ((uint64_t)input.len - pos < (uint64_t)2U)
    res = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    res = pos + (uint64_t)2U;
  if (is_error(res))
    return res;
  else
  {
    uint8_t *x0 = input.base;
    uint16_t va = load16_be(x0 + (uint32_t)pos);
    if (!(va <= (uint16_t)256U))
      return VALIDATOR_ERROR_GENERIC;
    else
      return res;
  }
}

static uint16_t significant_digits_t_reader(slice input, uint32_t pos)
{
  uint8_t *x0 = input.base;
  uint16_t res = load16_be(x0 + pos);
  return res;
}

static uint32_t significant_digits_t_lserializer(uint16_t x, uint8_t *input, uint32_t pos)
{
  store16_be(input + pos, x);
  return (uint32_t)2U;
}

static uint32_t key_size32(Zeta_Formats_Types_key input)
{
  uint32_t v1 = u256_size32(input.k);
  uint32_t v2 = significant_digits_t_size32(input.significant_digits);
  if ((uint32_t)4294967295U - v2 < v1)
    return (uint32_t)4294967295U;
  else
    return v1 + v2;
}

static uint64_t key_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = u256_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return significant_digits_t_validator(input, pos1);
}

static uint32_t key_jumper(uint32_t pos)
{
  return pos + (uint32_t)34U;
}

typedef struct key__s
{
  Zeta_Formats_Types_u256 fst;
  uint16_t snd;
}
key_;

static Zeta_Formats_Types_key key_reader(slice input, uint32_t pos)
{
  Zeta_Formats_Types_u256 x1 = u256_reader(input, pos);
  uint32_t pos2 = u256_jumper(pos);
  uint16_t x2 = significant_digits_t_reader(input, pos2);
  key_ res = { .fst = x1, .snd = x2 };
  Zeta_Formats_Types_u256 k = res.fst;
  uint16_t significant_digits = res.snd;
  return ((Zeta_Formats_Types_key){ .k = k, .significant_digits = significant_digits });
}

static uint32_t key_lserializer(Zeta_Formats_Types_key x, uint8_t *input, uint32_t pos)
{
  uint32_t res = u256_lserializer(x.k, input, pos);
  uint32_t len1 = res;
  uint32_t pos1 = pos + len1;
  uint32_t res0 = significant_digits_t_lserializer(x.significant_digits, input, pos1);
  uint32_t len2 = res0;
  return len1 + len2;
}

static uint32_t descendent_hash_desc_size32(Zeta_Formats_Types_descendent_hash_desc input)
{
  uint32_t v1 = key_size32(input.dhd_key);
  uint32_t v20 = hash_value_size32(input.dhd_h);
  uint32_t res;
  if ((uint32_t)4294967295U - v20 < v1)
    res = (uint32_t)4294967295U;
  else
    res = v1 + v20;
  uint32_t v10 = res;
  uint32_t v2 = vbool_size32(input.evicted_to_blum);
  if ((uint32_t)4294967295U - v2 < v10)
    return (uint32_t)4294967295U;
  else
    return v10 + v2;
}

static uint64_t descendent_hash_desc_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = key_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = hash_value_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
    return vbool_validator(input, pos1);
}

static uint32_t descendent_hash_desc_jumper(uint32_t pos)
{
  return pos + (uint32_t)67U;
}

typedef struct __Zeta_Formats_Types_key_Zeta_Formats_Types_u256_s
{
  Zeta_Formats_Types_key fst;
  Zeta_Formats_Types_u256 snd;
}
__Zeta_Formats_Types_key_Zeta_Formats_Types_u256;

typedef struct descendent_hash_desc__s
{
  __Zeta_Formats_Types_key_Zeta_Formats_Types_u256 fst;
  Zeta_Formats_Types_vbool snd;
}
descendent_hash_desc_;

static Zeta_Formats_Types_descendent_hash_desc
descendent_hash_desc_reader(slice input, uint32_t pos)
{
  Zeta_Formats_Types_key x1 = key_reader(input, pos);
  uint32_t pos20 = key_jumper(pos);
  Zeta_Formats_Types_u256 x2 = hash_value_reader(input, pos20);
  __Zeta_Formats_Types_key_Zeta_Formats_Types_u256 x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = hash_value_jumper(key_jumper(pos));
  Zeta_Formats_Types_vbool x20 = vbool_reader(input, pos2);
  descendent_hash_desc_ res = { .fst = x10, .snd = x20 };
  Zeta_Formats_Types_vbool evicted_to_blum = res.snd;
  Zeta_Formats_Types_u256 dhd_h = res.fst.snd;
  Zeta_Formats_Types_key dhd_key = res.fst.fst;
  return
    (
      (Zeta_Formats_Types_descendent_hash_desc){
        .dhd_key = dhd_key,
        .dhd_h = dhd_h,
        .evicted_to_blum = evicted_to_blum
      }
    );
}

static uint32_t
descendent_hash_desc_lserializer(
  Zeta_Formats_Types_descendent_hash_desc x,
  uint8_t *input,
  uint32_t pos
)
{
  uint32_t res = key_lserializer(x.dhd_key, input, pos);
  uint32_t len1 = res;
  uint32_t pos10 = pos + len1;
  uint32_t res0 = hash_value_lserializer(x.dhd_h, input, pos10);
  uint32_t len2 = res0;
  uint32_t res1 = len1 + len2;
  uint32_t len10 = res1;
  uint32_t pos1 = pos + len10;
  uint32_t res2 = vbool_lserializer(x.evicted_to_blum, input, pos1);
  uint32_t len20 = res2;
  return len10 + len20;
}

static uint32_t descendent_hash_size32(Zeta_Formats_Types_descendent_hash x)
{
  Zeta_Formats_Types_voption tg;
  if (x.tag == Zeta_Formats_Types_Dh_vnone)
    tg = Zeta_Formats_Types_Vnone;
  else if (x.tag == Zeta_Formats_Types_Dh_vsome)
    tg = Zeta_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Zeta_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (Zeta_Formats_Types_Vnone == tg)
    s2 = (uint32_t)0U;
  else
  {
    Zeta_Formats_Types_descendent_hash_desc ite;
    if (x.tag == Zeta_Formats_Types_Dh_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_descendent_hash_desc,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = descendent_hash_desc_size32(ite);
  }
  return s1 + s2;
}

static uint64_t descendent_hash_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      if ((uint64_t)input.len - len_after_tag < (uint64_t)0U)
        return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        return len_after_tag + (uint64_t)0U;
    else if (k_ == (uint8_t)1U)
      return descendent_hash_desc_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t descendent_hash_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return pos_after_tag + (uint32_t)0U;
  else if (k_ == (uint8_t)1U)
    return descendent_hash_desc_jumper(pos_after_tag);
  else
    return (uint32_t)0U;
}

static Zeta_Formats_Types_descendent_hash descendent_hash_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Zeta_Formats_Types_voption k;
  if (res == (uint8_t)0U)
    k = Zeta_Formats_Types_Vnone;
  else if (res == (uint8_t)1U)
    k = Zeta_Formats_Types_Vsome;
  else
    k = Zeta_Formats_Types_Vnone;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (Zeta_Formats_Types_Vnone == k)
    return ((Zeta_Formats_Types_descendent_hash){ .tag = Zeta_Formats_Types_Dh_vnone });
  else
  {
    Zeta_Formats_Types_descendent_hash_desc res = descendent_hash_desc_reader(input, pos_);
    return ((Zeta_Formats_Types_descendent_hash){ .tag = Zeta_Formats_Types_Dh_vsome, ._0 = res });
  }
}

static uint32_t
descendent_hash_lserializer(Zeta_Formats_Types_descendent_hash x, uint8_t *b, uint32_t pos)
{
  Zeta_Formats_Types_voption tg;
  if (x.tag == Zeta_Formats_Types_Dh_vnone)
    tg = Zeta_Formats_Types_Vnone;
  else if (x.tag == Zeta_Formats_Types_Dh_vsome)
    tg = Zeta_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Zeta_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (Zeta_Formats_Types_Vnone == tg)
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (Zeta_Formats_Types_Vnone == tg)
    res = (uint32_t)0U;
  else
  {
    Zeta_Formats_Types_descendent_hash_desc ite;
    if (x.tag == Zeta_Formats_Types_Dh_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_descendent_hash_desc,
          "unreachable (pattern matches are exhaustive in F*)");
    res = descendent_hash_desc_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint32_t mval_value_size32(Zeta_Formats_Types_mval_value input)
{
  uint32_t v1 = descendent_hash_size32(input.l);
  uint32_t v2 = descendent_hash_size32(input.r);
  if ((uint32_t)4294967295U - v2 < v1)
    return (uint32_t)4294967295U;
  else
    return v1 + v2;
}

static uint64_t mval_value_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = descendent_hash_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return descendent_hash_validator(input, pos1);
}

static uint32_t mval_value_jumper(slice input, uint32_t pos)
{
  return descendent_hash_jumper(input, descendent_hash_jumper(input, pos));
}

typedef struct mval_value__s
{
  Zeta_Formats_Types_descendent_hash fst;
  Zeta_Formats_Types_descendent_hash snd;
}
mval_value_;

static Zeta_Formats_Types_mval_value mval_value_reader(slice input, uint32_t pos)
{
  Zeta_Formats_Types_descendent_hash x1 = descendent_hash_reader(input, pos);
  uint32_t pos2 = descendent_hash_jumper(input, pos);
  Zeta_Formats_Types_descendent_hash x2 = descendent_hash_reader(input, pos2);
  mval_value_ res = { .fst = x1, .snd = x2 };
  Zeta_Formats_Types_descendent_hash l = res.fst;
  Zeta_Formats_Types_descendent_hash r = res.snd;
  return ((Zeta_Formats_Types_mval_value){ .l = l, .r = r });
}

static uint32_t
mval_value_lserializer(Zeta_Formats_Types_mval_value x, uint8_t *input, uint32_t pos)
{
  uint32_t res = descendent_hash_lserializer(x.l, input, pos);
  uint32_t len1 = res;
  uint32_t pos1 = pos + len1;
  uint32_t res0 = descendent_hash_lserializer(x.r, input, pos1);
  uint32_t len2 = res0;
  return len1 + len2;
}

static uint32_t (*data_t_size32)(Zeta_Formats_Types_u256 x0) = u256_size32;

static uint64_t data_t_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)32U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)32U;
}

static uint32_t data_t_jumper(uint32_t pos)
{
  return pos + (uint32_t)32U;
}

static Zeta_Formats_Types_u256 (*data_t_reader)(slice x0, uint32_t x1) = u256_reader;

static uint32_t
(*data_t_lserializer)(Zeta_Formats_Types_u256 x0, uint8_t *x1, uint32_t x2) = u256_lserializer;

static uint32_t data_value_size32(Zeta_Formats_Types_data_value x)
{
  Zeta_Formats_Types_voption tg;
  if (x.tag == Zeta_Formats_Types_Dv_vnone)
    tg = Zeta_Formats_Types_Vnone;
  else if (x.tag == Zeta_Formats_Types_Dv_vsome)
    tg = Zeta_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Zeta_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (Zeta_Formats_Types_Vnone == tg)
    s2 = (uint32_t)0U;
  else
  {
    Zeta_Formats_Types_u256 ite;
    if (x.tag == Zeta_Formats_Types_Dv_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_u256,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = data_t_size32(ite);
  }
  return s1 + s2;
}

static uint64_t data_value_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      if ((uint64_t)input.len - len_after_tag < (uint64_t)0U)
        return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
      else
        return len_after_tag + (uint64_t)0U;
    else if (k_ == (uint8_t)1U)
      return data_t_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t data_value_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return pos_after_tag + (uint32_t)0U;
  else if (k_ == (uint8_t)1U)
    return data_t_jumper(pos_after_tag);
  else
    return (uint32_t)0U;
}

static Zeta_Formats_Types_data_value data_value_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Zeta_Formats_Types_voption k;
  if (res == (uint8_t)0U)
    k = Zeta_Formats_Types_Vnone;
  else if (res == (uint8_t)1U)
    k = Zeta_Formats_Types_Vsome;
  else
    k = Zeta_Formats_Types_Vnone;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (Zeta_Formats_Types_Vnone == k)
    return ((Zeta_Formats_Types_data_value){ .tag = Zeta_Formats_Types_Dv_vnone });
  else
  {
    Zeta_Formats_Types_u256 res = data_t_reader(input, pos_);
    return ((Zeta_Formats_Types_data_value){ .tag = Zeta_Formats_Types_Dv_vsome, ._0 = res });
  }
}

static uint32_t
data_value_lserializer(Zeta_Formats_Types_data_value x, uint8_t *b, uint32_t pos)
{
  Zeta_Formats_Types_voption tg;
  if (x.tag == Zeta_Formats_Types_Dv_vnone)
    tg = Zeta_Formats_Types_Vnone;
  else if (x.tag == Zeta_Formats_Types_Dv_vsome)
    tg = Zeta_Formats_Types_Vsome;
  else
    tg =
      KRML_EABORT(Zeta_Formats_Types_voption,
        "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (Zeta_Formats_Types_Vnone == tg)
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (Zeta_Formats_Types_Vnone == tg)
    res = (uint32_t)0U;
  else
  {
    Zeta_Formats_Types_u256 ite;
    if (x.tag == Zeta_Formats_Types_Dv_vsome)
      ite = x._0;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_u256,
          "unreachable (pattern matches are exhaustive in F*)");
    res = data_t_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint32_t value_size32(Zeta_Formats_Types_value x)
{
  Zeta_Formats_Types_value_kind tg;
  if (x.tag == Zeta_Formats_Types_V_mval)
    tg = Zeta_Formats_Types_Mval;
  else if (x.tag == Zeta_Formats_Types_V_dval)
    tg = Zeta_Formats_Types_Dval;
  else
    tg =
      KRML_EABORT(Zeta_Formats_Types_value_kind,
        "unreachable (pattern matches are exhaustive in F*)");
  uint32_t s1 = (uint32_t)1U;
  uint32_t s2;
  if (Zeta_Formats_Types_Mval == tg)
  {
    Zeta_Formats_Types_mval_value ite;
    if (x.tag == Zeta_Formats_Types_V_mval)
      ite = x.case_V_mval;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_mval_value,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = mval_value_size32(ite);
  }
  else
  {
    Zeta_Formats_Types_data_value ite;
    if (x.tag == Zeta_Formats_Types_V_dval)
      ite = x.case_V_dval;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_data_value,
          "unreachable (pattern matches are exhaustive in F*)");
    s2 = data_value_size32(ite);
  }
  return s1 + s2;
}

static uint64_t value_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      return mval_value_validator(input, len_after_tag);
    else if (k_ == (uint8_t)1U)
      return data_value_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static uint32_t value_jumper(slice input, uint32_t pos)
{
  uint32_t pos_after_tag = pos + (uint32_t)1U;
  uint8_t k_ = input.base[pos];
  if (k_ == (uint8_t)0U)
    return mval_value_jumper(input, pos_after_tag);
  else if (k_ == (uint8_t)1U)
    return data_value_jumper(input, pos_after_tag);
  else
    return (uint32_t)0U;
}

static Zeta_Formats_Types_value value_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Zeta_Formats_Types_value_kind k;
  if (res == (uint8_t)0U)
    k = Zeta_Formats_Types_Mval;
  else if (res == (uint8_t)1U)
    k = Zeta_Formats_Types_Dval;
  else
    k = Zeta_Formats_Types_Mval;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (Zeta_Formats_Types_Mval == k)
  {
    Zeta_Formats_Types_mval_value res = mval_value_reader(input, pos_);
    return
      ((Zeta_Formats_Types_value){ .tag = Zeta_Formats_Types_V_mval, { .case_V_mval = res } });
  }
  else
  {
    Zeta_Formats_Types_data_value res = data_value_reader(input, pos_);
    return
      ((Zeta_Formats_Types_value){ .tag = Zeta_Formats_Types_V_dval, { .case_V_dval = res } });
  }
}

static uint32_t value_lserializer(Zeta_Formats_Types_value x, uint8_t *b, uint32_t pos)
{
  Zeta_Formats_Types_value_kind tg;
  if (x.tag == Zeta_Formats_Types_V_mval)
    tg = Zeta_Formats_Types_Mval;
  else if (x.tag == Zeta_Formats_Types_V_dval)
    tg = Zeta_Formats_Types_Dval;
  else
    tg =
      KRML_EABORT(Zeta_Formats_Types_value_kind,
        "unreachable (pattern matches are exhaustive in F*)");
  uint8_t ite0;
  if (Zeta_Formats_Types_Mval == tg)
    ite0 = (uint8_t)0U;
  else
    ite0 = (uint8_t)1U;
  b[pos] = ite0;
  uint32_t len = (uint32_t)1U;
  uint32_t res0 = pos + len;
  uint32_t pos_ = res0;
  uint32_t pos_0 = pos_;
  uint32_t res1 = pos_0 - pos;
  uint32_t len1 = res1;
  uint32_t pos1 = pos + len1;
  uint32_t res;
  if (Zeta_Formats_Types_Mval == tg)
  {
    Zeta_Formats_Types_mval_value ite;
    if (x.tag == Zeta_Formats_Types_V_mval)
      ite = x.case_V_mval;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_mval_value,
          "unreachable (pattern matches are exhaustive in F*)");
    res = mval_value_lserializer(ite, b, pos1);
  }
  else
  {
    Zeta_Formats_Types_data_value ite;
    if (x.tag == Zeta_Formats_Types_V_dval)
      ite = x.case_V_dval;
    else
      ite =
        KRML_EABORT(Zeta_Formats_Types_data_value,
          "unreachable (pattern matches are exhaustive in F*)");
    res = data_value_lserializer(ite, b, pos1);
  }
  uint32_t len2 = res;
  return len1 + len2;
}

static uint64_t slot_id_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)2U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)2U;
}

static uint32_t slot_id_jumper(uint32_t pos)
{
  return pos + (uint32_t)2U;
}

static uint16_t slot_id_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load16_be(x0 + pos);
}

static uint64_t vlog_entry_evictm_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)4U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)4U;
}

typedef struct vlog_entry_evictm__s
{
  uint16_t fst;
  uint16_t snd;
}
vlog_entry_evictm_;

static Zeta_Formats_Types_vlog_entry_evictm vlog_entry_evictm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  uint16_t x2 = slot_id_reader(input, pos2);
  vlog_entry_evictm_ res = { .fst = x1, .snd = x2 };
  uint16_t veem_s = res.fst;
  uint16_t veem_s2 = res.snd;
  return ((Zeta_Formats_Types_vlog_entry_evictm){ .veem_s = veem_s, .veem_s2 = veem_s2 });
}

static uint64_t thread_id_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)2U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)2U;
}

static uint16_t thread_id_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load16_be(x0 + pos);
}

static uint32_t thread_id_lserializer(uint16_t v, uint8_t *b, uint32_t pos)
{
  store16_be(b + pos, v);
  return (uint32_t)2U;
}

static uint64_t timestamp_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)8U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)8U;
}

static uint32_t timestamp_jumper(uint32_t pos)
{
  return pos + (uint32_t)8U;
}

static uint64_t timestamp_reader(slice sl, uint32_t pos)
{
  uint8_t *x0 = sl.base;
  return load64_be(x0 + pos);
}

static uint32_t timestamp_lserializer(uint64_t v, uint8_t *b, uint32_t pos)
{
  store64_be(b + pos, v);
  return (uint32_t)8U;
}

static uint64_t record_validator(slice input, uint64_t pos)
{
  uint64_t pos1 = key_validator(input, pos);
  if (is_error(pos1))
    return pos1;
  else
    return value_validator(input, pos1);
}

static uint32_t record_jumper(slice input, uint32_t pos)
{
  return value_jumper(input, key_jumper(pos));
}

typedef struct record__s
{
  Zeta_Formats_Types_key fst;
  Zeta_Formats_Types_value snd;
}
record_;

static Zeta_Formats_Types_record record_reader(slice input, uint32_t pos)
{
  Zeta_Formats_Types_key x1 = key_reader(input, pos);
  uint32_t pos2 = key_jumper(pos);
  Zeta_Formats_Types_value x2 = value_reader(input, pos2);
  record_ res = { .fst = x1, .snd = x2 };
  Zeta_Formats_Types_key record_key = res.fst;
  Zeta_Formats_Types_value record_value = res.snd;
  return ((Zeta_Formats_Types_record){ .record_key = record_key, .record_value = record_value });
}

static uint32_t record_lserializer(Zeta_Formats_Types_record x, uint8_t *input, uint32_t pos)
{
  uint32_t res = key_lserializer(x.record_key, input, pos);
  uint32_t len1 = res;
  uint32_t pos1 = pos + len1;
  uint32_t res0 = value_lserializer(x.record_value, input, pos1);
  uint32_t len2 = res0;
  return len1 + len2;
}

static uint32_t
stamped_record_lserializer(Zeta_Formats_Types_stamped_record x, uint8_t *input, uint32_t pos)
{
  uint32_t res = record_lserializer(x.sr_record, input, pos);
  uint32_t len1 = res;
  uint32_t pos10 = pos + len1;
  uint32_t res0 = timestamp_lserializer(x.sr_timestamp, input, pos10);
  uint32_t len2 = res0;
  uint32_t res1 = len1 + len2;
  uint32_t len10 = res1;
  uint32_t pos1 = pos + len10;
  uint32_t res2 = thread_id_lserializer(x.sr_thread_id, input, pos1);
  uint32_t len20 = res2;
  return len10 + len20;
}

static uint64_t vlog_entry_evictbm_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)12U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)12U;
}

typedef struct vlog_entry_evictbm__s
{
  vlog_entry_evictm_ fst;
  uint64_t snd;
}
vlog_entry_evictbm_;

static Zeta_Formats_Types_vlog_entry_evictbm
vlog_entry_evictbm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  uint16_t x2 = slot_id_reader(input, pos20);
  vlog_entry_evictm_ x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = slot_id_jumper(slot_id_jumper(pos));
  uint64_t x20 = timestamp_reader(input, pos2);
  vlog_entry_evictbm_ res = { .fst = x10, .snd = x20 };
  uint64_t veebm_t = res.snd;
  uint16_t veebm_s2 = res.fst.snd;
  uint16_t veebm_s = res.fst.fst;
  return
    (
      (Zeta_Formats_Types_vlog_entry_evictbm){
        .veebm_s = veebm_s,
        .veebm_s2 = veebm_s2,
        .veebm_t = veebm_t
      }
    );
}

static uint64_t vlog_entry_evictb_validator(slice sl, uint64_t pos)
{
  if ((uint64_t)sl.len - pos < (uint64_t)10U)
    return VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    return pos + (uint64_t)10U;
}

typedef struct vlog_entry_evictb__s
{
  uint16_t fst;
  uint64_t snd;
}
vlog_entry_evictb_;

static Zeta_Formats_Types_vlog_entry_evictb vlog_entry_evictb_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos2 = slot_id_jumper(pos);
  uint64_t x2 = timestamp_reader(input, pos2);
  vlog_entry_evictb_ res = { .fst = x1, .snd = x2 };
  uint16_t veeb_s = res.fst;
  uint64_t veeb_t = res.snd;
  return ((Zeta_Formats_Types_vlog_entry_evictb){ .veeb_s = veeb_s, .veeb_t = veeb_t });
}

static uint64_t vlog_entry_addb_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = slot_id_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = record_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
  {
    uint64_t pos11 = timestamp_validator(input, pos1);
    if (is_error(pos11))
      return pos11;
    else
      return thread_id_validator(input, pos11);
  }
}

typedef struct __uint16_t_Zeta_Formats_Types_record_s
{
  uint16_t fst;
  Zeta_Formats_Types_record snd;
}
__uint16_t_Zeta_Formats_Types_record;

typedef struct __uint64_t_uint16_t_s
{
  uint64_t fst;
  uint16_t snd;
}
__uint64_t_uint16_t;

typedef struct vlog_entry_addb__s
{
  __uint16_t_Zeta_Formats_Types_record fst;
  __uint64_t_uint16_t snd;
}
vlog_entry_addb_;

static Zeta_Formats_Types_vlog_entry_addb vlog_entry_addb_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  Zeta_Formats_Types_record x2 = record_reader(input, pos20);
  __uint16_t_Zeta_Formats_Types_record x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = record_jumper(input, slot_id_jumper(pos));
  uint64_t x11 = timestamp_reader(input, pos2);
  uint32_t pos21 = timestamp_jumper(pos2);
  uint16_t x20 = thread_id_reader(input, pos21);
  __uint64_t_uint16_t x21 = { .fst = x11, .snd = x20 };
  vlog_entry_addb_ res = { .fst = x10, .snd = x21 };
  uint16_t veab_j = res.snd.snd;
  uint64_t veab_t = res.snd.fst;
  Zeta_Formats_Types_record veab_r = res.fst.snd;
  uint16_t veab_s = res.fst.fst;
  return
    (
      (Zeta_Formats_Types_vlog_entry_addb){
        .veab_s = veab_s,
        .veab_r = veab_r,
        .veab_t = veab_t,
        .veab_j = veab_j
      }
    );
}

static uint64_t vlog_entry_addm_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = slot_id_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = record_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
    return slot_id_validator(input, pos1);
}

typedef struct vlog_entry_addm__s
{
  __uint16_t_Zeta_Formats_Types_record fst;
  uint16_t snd;
}
vlog_entry_addm_;

static Zeta_Formats_Types_vlog_entry_addm vlog_entry_addm_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  Zeta_Formats_Types_record x2 = record_reader(input, pos20);
  __uint16_t_Zeta_Formats_Types_record x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = record_jumper(input, slot_id_jumper(pos));
  uint16_t x20 = slot_id_reader(input, pos2);
  vlog_entry_addm_ res = { .fst = x10, .snd = x20 };
  uint16_t veam_s2 = res.snd;
  Zeta_Formats_Types_record veam_r = res.fst.snd;
  uint16_t veam_s = res.fst.fst;
  return
    (
      (Zeta_Formats_Types_vlog_entry_addm){ .veam_s = veam_s, .veam_r = veam_r, .veam_s2 = veam_s2 }
    );
}

static uint64_t vlog_entry_get_put_validator(slice input, uint64_t pos)
{
  uint64_t pos10 = slot_id_validator(input, pos);
  uint64_t pos1;
  if (is_error(pos10))
    pos1 = pos10;
  else
    pos1 = key_validator(input, pos10);
  if (is_error(pos1))
    return pos1;
  else
    return data_value_validator(input, pos1);
}

typedef struct __uint16_t_Zeta_Formats_Types_key_s
{
  uint16_t fst;
  Zeta_Formats_Types_key snd;
}
__uint16_t_Zeta_Formats_Types_key;

typedef struct vlog_entry_get_put__s
{
  __uint16_t_Zeta_Formats_Types_key fst;
  Zeta_Formats_Types_data_value snd;
}
vlog_entry_get_put_;

static Zeta_Formats_Types_vlog_entry_get_put
vlog_entry_get_put_reader(slice input, uint32_t pos)
{
  uint16_t x1 = slot_id_reader(input, pos);
  uint32_t pos20 = slot_id_jumper(pos);
  Zeta_Formats_Types_key x2 = key_reader(input, pos20);
  __uint16_t_Zeta_Formats_Types_key x10 = { .fst = x1, .snd = x2 };
  uint32_t pos2 = key_jumper(slot_id_jumper(pos));
  Zeta_Formats_Types_data_value x20 = data_value_reader(input, pos2);
  vlog_entry_get_put_ res = { .fst = x10, .snd = x20 };
  Zeta_Formats_Types_data_value vegp_v = res.snd;
  Zeta_Formats_Types_key vegp_k = res.fst.snd;
  uint16_t vegp_s = res.fst.fst;
  return
    (
      (Zeta_Formats_Types_vlog_entry_get_put){
        .vegp_s = vegp_s,
        .vegp_k = vegp_k,
        .vegp_v = vegp_v
      }
    );
}

static uint64_t vlog_entry_validator(slice input, uint64_t pos)
{
  uint64_t len_after_tag;
  if ((uint64_t)input.len - pos < (uint64_t)1U)
    len_after_tag = VALIDATOR_ERROR_NOT_ENOUGH_DATA;
  else
    len_after_tag = pos + (uint64_t)1U;
  if (is_error(len_after_tag))
    return len_after_tag;
  else
  {
    uint8_t k_ = input.base[(uint32_t)pos];
    if (k_ == (uint8_t)0U)
      return vlog_entry_get_put_validator(input, len_after_tag);
    else if (k_ == (uint8_t)1U)
      return vlog_entry_get_put_validator(input, len_after_tag);
    else if (k_ == (uint8_t)2U)
      return vlog_entry_addm_validator(input, len_after_tag);
    else if (k_ == (uint8_t)3U)
      return vlog_entry_evictm_validator(input, len_after_tag);
    else if (k_ == (uint8_t)4U)
      return vlog_entry_addb_validator(input, len_after_tag);
    else if (k_ == (uint8_t)5U)
      return vlog_entry_evictb_validator(input, len_after_tag);
    else if (k_ == (uint8_t)6U)
      return vlog_entry_evictbm_validator(input, len_after_tag);
    else
      return VALIDATOR_ERROR_GENERIC;
  }
}

static Zeta_Formats_Types_vlog_entry vlog_entry_reader(slice input, uint32_t pos)
{
  uint8_t res = input.base[pos];
  Zeta_Formats_Types_vlog_entry_kind k;
  if (res == (uint8_t)0U)
    k = Zeta_Formats_Types_Get;
  else if (res == (uint8_t)1U)
    k = Zeta_Formats_Types_Put;
  else if (res == (uint8_t)2U)
    k = Zeta_Formats_Types_AddM;
  else if (res == (uint8_t)3U)
    k = Zeta_Formats_Types_EvictM;
  else if (res == (uint8_t)4U)
    k = Zeta_Formats_Types_AddB;
  else if (res == (uint8_t)5U)
    k = Zeta_Formats_Types_EvictB;
  else if (res == (uint8_t)6U)
    k = Zeta_Formats_Types_EvictBM;
  else
    k = Zeta_Formats_Types_Get;
  uint32_t pos_ = pos + (uint32_t)1U;
  if (Zeta_Formats_Types_Get == k)
  {
    Zeta_Formats_Types_vlog_entry_get_put res = vlog_entry_get_put_reader(input, pos_);
    return
      ((Zeta_Formats_Types_vlog_entry){ .tag = Zeta_Formats_Types_Ve_Get, { .case_Ve_Get = res } });
  }
  else if (Zeta_Formats_Types_Put == k)
  {
    Zeta_Formats_Types_vlog_entry_get_put res = vlog_entry_get_put_reader(input, pos_);
    return
      ((Zeta_Formats_Types_vlog_entry){ .tag = Zeta_Formats_Types_Ve_Put, { .case_Ve_Put = res } });
  }
  else if (Zeta_Formats_Types_AddM == k)
  {
    Zeta_Formats_Types_vlog_entry_addm res = vlog_entry_addm_reader(input, pos_);
    return
      (
        (Zeta_Formats_Types_vlog_entry){
          .tag = Zeta_Formats_Types_Ve_AddM,
          { .case_Ve_AddM = res }
        }
      );
  }
  else if (Zeta_Formats_Types_EvictM == k)
  {
    Zeta_Formats_Types_vlog_entry_evictm res = vlog_entry_evictm_reader(input, pos_);
    return
      (
        (Zeta_Formats_Types_vlog_entry){
          .tag = Zeta_Formats_Types_Ve_EvictM,
          { .case_Ve_EvictM = res }
        }
      );
  }
  else if (Zeta_Formats_Types_AddB == k)
  {
    Zeta_Formats_Types_vlog_entry_addb res = vlog_entry_addb_reader(input, pos_);
    return
      (
        (Zeta_Formats_Types_vlog_entry){
          .tag = Zeta_Formats_Types_Ve_AddB,
          { .case_Ve_AddB = res }
        }
      );
  }
  else if (Zeta_Formats_Types_EvictB == k)
  {
    Zeta_Formats_Types_vlog_entry_evictb res = vlog_entry_evictb_reader(input, pos_);
    return
      (
        (Zeta_Formats_Types_vlog_entry){
          .tag = Zeta_Formats_Types_Ve_EvictB,
          { .case_Ve_EvictB = res }
        }
      );
  }
  else
  {
    Zeta_Formats_Types_vlog_entry_evictbm res = vlog_entry_evictbm_reader(input, pos_);
    return
      (
        (Zeta_Formats_Types_vlog_entry){
          .tag = Zeta_Formats_Types_Ve_EvictBM,
          { .case_Ve_EvictBM = res }
        }
      );
  }
}

void Zeta_Formats_serialize_value(Zeta_Formats_Types_value v, uint8_t *dst)
{
  uint32_t uu____0 = value_lserializer(v, (uint8_t *)dst, (uint32_t)0U);
}

FStar_Pervasives_either__K___Zeta_Formats_Types_vlog_entry_uint32_t_K___uint32_t_Prims_string
Zeta_Formats_extract_log_entry_from(uint32_t len, uint8_t *buf, uint32_t pos)
{
  slice sl = { .base = buf, .len = len };
  uint64_t pos_ = vlog_entry_validator(sl, (uint64_t)pos);
  if (is_error(pos_))
    return
      (
        (FStar_Pervasives_either__K___Zeta_Formats_Types_vlog_entry_uint32_t_K___uint32_t_Prims_string){
          .tag = FStar_Pervasives_Inr,
          { .case_Inr = { .fst = pos, .snd = "extract_log_entry: no valid log entry" } }
        }
      );
  else
    return
      (
        (FStar_Pervasives_either__K___Zeta_Formats_Types_vlog_entry_uint32_t_K___uint32_t_Prims_string){
          .tag = FStar_Pervasives_Inl,
          { .case_Inl = { .fst = vlog_entry_reader(sl, pos), .snd = (uint32_t)pos_ } }
        }
      );
}

uint32_t
Zeta_Formats_serialize_stamped_record(uint8_t *dst, Zeta_Formats_Types_stamped_record r)
{
  return stamped_record_lserializer(r, (uint8_t *)dst, (uint32_t)0U);
}

uint32_t Zeta_Formats_Pure_serialize_length(Zeta_Formats_Types_value x)
{
  return value_size32(x);
}

uint64_t Zeta_Formats_Types___proj__Mku256__item__v3(Zeta_Formats_Types_u256 projectee)
{
  return projectee.v3;
}

uint64_t Zeta_Formats_Types___proj__Mku256__item__v2(Zeta_Formats_Types_u256 projectee)
{
  return projectee.v2;
}

uint64_t Zeta_Formats_Types___proj__Mku256__item__v1(Zeta_Formats_Types_u256 projectee)
{
  return projectee.v1;
}

uint64_t Zeta_Formats_Types___proj__Mku256__item__v0(Zeta_Formats_Types_u256 projectee)
{
  return projectee.v0;
}

Zeta_Formats_Types_u256
Zeta_Formats_Types___proj__Mkkey__item__k(Zeta_Formats_Types_key projectee)
{
  return projectee.k;
}

uint16_t
Zeta_Formats_Types___proj__Mkkey__item__significant_digits(Zeta_Formats_Types_key projectee)
{
  return projectee.significant_digits;
}

bool Zeta_Formats_Types_uu___is_Vnone(Zeta_Formats_Types_voption projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Vnone:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_Vsome(Zeta_Formats_Types_voption projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Vsome:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_Dv_vnone(Zeta_Formats_Types_data_value projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Dv_vnone)
    return true;
  else
    return false;
}

bool Zeta_Formats_Types_uu___is_Dv_vsome(Zeta_Formats_Types_data_value projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Dv_vsome)
    return true;
  else
    return false;
}

Zeta_Formats_Types_u256
Zeta_Formats_Types___proj__Dv_vsome__item___0(Zeta_Formats_Types_data_value projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Dv_vsome)
    return projectee._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Vfalse(Zeta_Formats_Types_vbool projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Vfalse:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_Vtrue(Zeta_Formats_Types_vbool projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Vtrue:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

Zeta_Formats_Types_key
Zeta_Formats_Types___proj__Mkdescendent_hash_desc__item__dhd_key(
  Zeta_Formats_Types_descendent_hash_desc projectee
)
{
  return projectee.dhd_key;
}

Zeta_Formats_Types_u256
Zeta_Formats_Types___proj__Mkdescendent_hash_desc__item__dhd_h(
  Zeta_Formats_Types_descendent_hash_desc projectee
)
{
  return projectee.dhd_h;
}

Zeta_Formats_Types_vbool
Zeta_Formats_Types___proj__Mkdescendent_hash_desc__item__evicted_to_blum(
  Zeta_Formats_Types_descendent_hash_desc projectee
)
{
  return projectee.evicted_to_blum;
}

bool Zeta_Formats_Types_uu___is_Dh_vnone(Zeta_Formats_Types_descendent_hash projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Dh_vnone)
    return true;
  else
    return false;
}

bool Zeta_Formats_Types_uu___is_Dh_vsome(Zeta_Formats_Types_descendent_hash projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Dh_vsome)
    return true;
  else
    return false;
}

Zeta_Formats_Types_descendent_hash_desc
Zeta_Formats_Types___proj__Dh_vsome__item___0(Zeta_Formats_Types_descendent_hash projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Dh_vsome)
    return projectee._0;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Mval(Zeta_Formats_Types_value_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Mval:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_Dval(Zeta_Formats_Types_value_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Dval:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

Zeta_Formats_Types_descendent_hash
Zeta_Formats_Types___proj__Mkmval_value__item__l(Zeta_Formats_Types_mval_value projectee)
{
  return projectee.l;
}

Zeta_Formats_Types_descendent_hash
Zeta_Formats_Types___proj__Mkmval_value__item__r(Zeta_Formats_Types_mval_value projectee)
{
  return projectee.r;
}

bool Zeta_Formats_Types_uu___is_V_mval(Zeta_Formats_Types_value projectee)
{
  if (projectee.tag == Zeta_Formats_Types_V_mval)
    return true;
  else
    return false;
}

Zeta_Formats_Types_mval_value
Zeta_Formats_Types___proj__V_mval__item___0(Zeta_Formats_Types_value projectee)
{
  if (projectee.tag == Zeta_Formats_Types_V_mval)
    return projectee.case_V_mval;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_V_dval(Zeta_Formats_Types_value projectee)
{
  if (projectee.tag == Zeta_Formats_Types_V_dval)
    return true;
  else
    return false;
}

Zeta_Formats_Types_data_value
Zeta_Formats_Types___proj__V_dval__item___0(Zeta_Formats_Types_value projectee)
{
  if (projectee.tag == Zeta_Formats_Types_V_dval)
    return projectee.case_V_dval;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_MAdd(Zeta_Formats_Types_add_method projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_MAdd:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_BAdd(Zeta_Formats_Types_add_method projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_BAdd:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

Zeta_Formats_Types_key
Zeta_Formats_Types___proj__Mkrecord__item__record_key(Zeta_Formats_Types_record projectee)
{
  return projectee.record_key;
}

Zeta_Formats_Types_value
Zeta_Formats_Types___proj__Mkrecord__item__record_value(Zeta_Formats_Types_record projectee)
{
  return projectee.record_value;
}

bool Zeta_Formats_Types_uu___is_Get(Zeta_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Get:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_Put(Zeta_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_Put:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_AddM(Zeta_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_AddM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_EvictM(Zeta_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_EvictM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_AddB(Zeta_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_AddB:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_EvictB(Zeta_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_EvictB:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool Zeta_Formats_Types_uu___is_EvictBM(Zeta_Formats_Types_vlog_entry_kind projectee)
{
  switch (projectee)
  {
    case Zeta_Formats_Types_EvictBM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_get_put__item__vegp_s(
  Zeta_Formats_Types_vlog_entry_get_put projectee
)
{
  return projectee.vegp_s;
}

Zeta_Formats_Types_key
Zeta_Formats_Types___proj__Mkvlog_entry_get_put__item__vegp_k(
  Zeta_Formats_Types_vlog_entry_get_put projectee
)
{
  return projectee.vegp_k;
}

Zeta_Formats_Types_data_value
Zeta_Formats_Types___proj__Mkvlog_entry_get_put__item__vegp_v(
  Zeta_Formats_Types_vlog_entry_get_put projectee
)
{
  return projectee.vegp_v;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_addm__item__veam_s(
  Zeta_Formats_Types_vlog_entry_addm projectee
)
{
  return projectee.veam_s;
}

Zeta_Formats_Types_record
Zeta_Formats_Types___proj__Mkvlog_entry_addm__item__veam_r(
  Zeta_Formats_Types_vlog_entry_addm projectee
)
{
  return projectee.veam_r;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_addm__item__veam_s2(
  Zeta_Formats_Types_vlog_entry_addm projectee
)
{
  return projectee.veam_s2;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_evictm__item__veem_s(
  Zeta_Formats_Types_vlog_entry_evictm projectee
)
{
  return projectee.veem_s;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_evictm__item__veem_s2(
  Zeta_Formats_Types_vlog_entry_evictm projectee
)
{
  return projectee.veem_s2;
}

Zeta_Formats_Types_record
Zeta_Formats_Types___proj__Mkstamped_record__item__sr_record(
  Zeta_Formats_Types_stamped_record projectee
)
{
  return projectee.sr_record;
}

uint64_t
Zeta_Formats_Types___proj__Mkstamped_record__item__sr_timestamp(
  Zeta_Formats_Types_stamped_record projectee
)
{
  return projectee.sr_timestamp;
}

uint16_t
Zeta_Formats_Types___proj__Mkstamped_record__item__sr_thread_id(
  Zeta_Formats_Types_stamped_record projectee
)
{
  return projectee.sr_thread_id;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_addb__item__veab_s(
  Zeta_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_s;
}

Zeta_Formats_Types_record
Zeta_Formats_Types___proj__Mkvlog_entry_addb__item__veab_r(
  Zeta_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_r;
}

uint64_t
Zeta_Formats_Types___proj__Mkvlog_entry_addb__item__veab_t(
  Zeta_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_t;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_addb__item__veab_j(
  Zeta_Formats_Types_vlog_entry_addb projectee
)
{
  return projectee.veab_j;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_evictb__item__veeb_s(
  Zeta_Formats_Types_vlog_entry_evictb projectee
)
{
  return projectee.veeb_s;
}

uint64_t
Zeta_Formats_Types___proj__Mkvlog_entry_evictb__item__veeb_t(
  Zeta_Formats_Types_vlog_entry_evictb projectee
)
{
  return projectee.veeb_t;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_evictbm__item__veebm_s(
  Zeta_Formats_Types_vlog_entry_evictbm projectee
)
{
  return projectee.veebm_s;
}

uint16_t
Zeta_Formats_Types___proj__Mkvlog_entry_evictbm__item__veebm_s2(
  Zeta_Formats_Types_vlog_entry_evictbm projectee
)
{
  return projectee.veebm_s2;
}

uint64_t
Zeta_Formats_Types___proj__Mkvlog_entry_evictbm__item__veebm_t(
  Zeta_Formats_Types_vlog_entry_evictbm projectee
)
{
  return projectee.veebm_t;
}

bool Zeta_Formats_Types_uu___is_Ve_Get(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_Get)
    return true;
  else
    return false;
}

Zeta_Formats_Types_vlog_entry_get_put
Zeta_Formats_Types___proj__Ve_Get__item___0(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_Get)
    return projectee.case_Ve_Get;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Ve_Put(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_Put)
    return true;
  else
    return false;
}

Zeta_Formats_Types_vlog_entry_get_put
Zeta_Formats_Types___proj__Ve_Put__item___0(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_Put)
    return projectee.case_Ve_Put;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Ve_AddM(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_AddM)
    return true;
  else
    return false;
}

Zeta_Formats_Types_vlog_entry_addm
Zeta_Formats_Types___proj__Ve_AddM__item___0(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_AddM)
    return projectee.case_Ve_AddM;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Ve_EvictM(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_EvictM)
    return true;
  else
    return false;
}

Zeta_Formats_Types_vlog_entry_evictm
Zeta_Formats_Types___proj__Ve_EvictM__item___0(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_EvictM)
    return projectee.case_Ve_EvictM;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Ve_AddB(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_AddB)
    return true;
  else
    return false;
}

Zeta_Formats_Types_vlog_entry_addb
Zeta_Formats_Types___proj__Ve_AddB__item___0(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_AddB)
    return projectee.case_Ve_AddB;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Ve_EvictB(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_EvictB)
    return true;
  else
    return false;
}

Zeta_Formats_Types_vlog_entry_evictb
Zeta_Formats_Types___proj__Ve_EvictB__item___0(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_EvictB)
    return projectee.case_Ve_EvictB;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool Zeta_Formats_Types_uu___is_Ve_EvictBM(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_EvictBM)
    return true;
  else
    return false;
}

Zeta_Formats_Types_vlog_entry_evictbm
Zeta_Formats_Types___proj__Ve_EvictBM__item___0(Zeta_Formats_Types_vlog_entry projectee)
{
  if (projectee.tag == Zeta_Formats_Types_Ve_EvictBM)
    return projectee.case_Ve_EvictBM;
  else
  {
    KRML_HOST_EPRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

