struct {
  uint64 v3;
  uint64 v2;
  uint64 v1;
  uint64 v0;
} u256;

abstract /*@has_lserializer*/
significant_digits_t = "Zeta.Formats.Aux.External.significant_digits_t" < 2..2 >

struct {
  u256 raw_key_k;
  significant_digits_t raw_key_significant_digits;
} raw_key;

abstract /*@has_lserializer*/
base_key = "Zeta.Formats.Aux.External.base_key" < 34..34 >

abstract /*@has_lserializer*/
internal_key = "Zeta.Formats.Aux.External.internal_key" < 34..34 >

enum {
  vfalse,
  vtrue,
  (255)
} vbool;

u256 hash_value;

struct {
   base_key dhd_key;
   hash_value dhd_h; /* I cannot name this field h because it would clash with the finalizer generated by QD */
   vbool evicted_to_blum;
} descendent_hash_desc;

enum {
  vnone,
  vsome,
  (255)
} voption;

struct {
  voption dh_tag;
  select(dh_tag) {
    case vnone: Empty;
    case vsome: descendent_hash_desc;
  } dh;
} descendent_hash;

struct {
  descendent_hash l;
  descendent_hash r;
} mval_value;

enum {
  key_internal,
  key_application,
  (255)
} key_kind;

abstract /*@has_lserializer*/
application_key = "Zeta.Formats.Aux.External.App.application_key" < 0..2040 > /* these constant bounds must match Zeta.Steel.ApplicationTypes */

struct {
  internal_key ir_key;
  mval_value ir_value;
} internal_record;

abstract /*@has_lserializer*/
application_value = "Zeta.Formats.Aux.External.App.application_value" < 0..2040 > /* these constant bounds must match Zeta.Steel.ApplicationTypes */

enum {
     DValueNone,
     DValueSome,
     (255)
} dvalue_kind;

struct {
  application_key ar_key;
  dvalue_kind v_tag;
  select(v_tag) {
    case DValueNone: Empty;
    case DValueSome: application_value;
  } v_payload;
} application_record;

struct {
  key_kind key_tag;
  select(key_tag) {
    case key_internal: internal_record;
    case key_application: application_record;
  } record_kv;
} record;

enum {
  MV,
  DVNone,
  DVSome,
  (255)
} value_kind;

struct {
  value_kind value_tag;
  select(value_tag) {
    case MV: mval_value;
    case DVNone: Empty;
    case DVSome: application_value;
  } value_payload;
} value;

uint16 slot_id;

struct {
  record addm_r;
  slot_id addm_s;
  slot_id addm_s2;
} addm_payload;

struct {
  uint32 epoch;
  uint32 counter;
} timestamp;
uint16 thread_id;

struct {
  record addb_r;
  slot_id addb_s;
  timestamp addb_t;
  thread_id addb_tid;
} addb_payload;

struct {
  slot_id evictm_s;
  slot_id evictm_s2;
} evictm_payload;

struct {
  slot_id evictb_s;
  timestamp evictb_t;
} evictb_payload;

struct {
  slot_id evictbm_s;
  slot_id evictbm_s2;
  timestamp evictbm_t;
} evictbm_payload;

struct {
  uint8 ra_fid;
} runapp_payload_hdr;

enum {
  AddM,
  AddB,
  EvictM,
  EvictB,
  EvictBM,
  NextEpoch,
  VerifyEpoch,
  RunApp,
  (255)
} log_entry_kind;

struct {
  log_entry_kind le_tag;
  select(le_tag) {
    case AddM: addm_payload;
    case AddB: addb_payload;
    case EvictM: evictm_payload;
    case EvictB: evictb_payload;
    case EvictBM: evictbm_payload;
    case NextEpoch: Empty;
    case VerifyEpoch: Empty;
    case RunApp: runapp_payload_hdr;
  } le_payload;
} log_entry_hdr;

struct {
  record sr_record;
  timestamp sr_timestamp;
  thread_id sr_thread_id;
} stamped_record;
